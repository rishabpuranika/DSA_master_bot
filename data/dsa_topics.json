{
  "arrays": {
    "title": "Arrays",
    "short": "An array is a fundamental data structure consisting of a collection of elements, each identified by at least one index or key. Arrays store elements of the same data type contiguously in memory, enabling efficient access to elements by their index. They are primarily used to store and retrieve ordered collections of data, making them suitable for various applications, including storing lists, representing matrices, and implementing other data structures.",
    "time": {
      "Access": "O(1)",
      "Search": "O(n) (worst and average), O(1) (best case if element is the first)",
      "Insertion": "O(n) (worst and average), O(1) (best case if inserting at the end if sufficient space is pre-allocated)",
      "Deletion": "O(n) (worst and average), O(1) (best case if deleting at the end)"
    },
    "space": "O(n)",
    "code": " #include <iostream>\n#include <vector>\n\nint main() {\n  // Static array (fixed size at compile time)\n  int static_array[5] = {10, 20, 30, 40, 50};\n\n  // Accessing elements of the static array\n  std::cout << \"Static array elements: \";\n  for (int i = 0; i < 5; ++i) {\n    std::cout << static_array[i] << \" \";\n  }\n  std::cout << std::endl;\n\n  // Dynamic array (size can change at runtime using std::vector)\n  std::vector<int> dynamic_array;\n\n  // Adding elements to the dynamic array\n  dynamic_array.push_back(100);\n  dynamic_array.push_back(200);\n  dynamic_array.push_back(300);\n\n  // Accessing elements of the dynamic array using index\n  std::cout << \"Dynamic array elements (using index): \";\n  for (size_t i = 0; i < dynamic_array.size(); ++i) {\n    std::cout << dynamic_array[i] << \" \";\n  }\n  std::cout << std::endl;\n\n  // Accessing elements of the dynamic array using iterators\n  std::cout << \"Dynamic array elements (using iterators): \";\n  for (auto it = dynamic_array.begin(); it != dynamic_array.end(); ++it) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n\n  // Inserting an element at a specific position in the dynamic array\n  dynamic_array.insert(dynamic_array.begin() + 1, 150); // Insert 150 at index 1\n\n  std::cout << \"Dynamic array after insertion: \";\n    for (int element : dynamic_array) {\n        std::cout << element << \" \";\n    }\n    std::cout << std::endl;\n\n  // Deleting an element from the dynamic array\n  dynamic_array.erase(dynamic_array.begin() + 2); // Erase element at index 2\n\n  std::cout << \"Dynamic array after deletion: \";\n    for (int element : dynamic_array) {\n        std::cout << element << \" \";\n    }\n    std::cout << std::endl;\n\n  // Getting the size of the dynamic array\n  std::cout << \"Size of dynamic array: \" << dynamic_array.size() << std::endl;\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/array-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=B35l9y3qKBE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/array/"
      ]
    ]
  },
  "linked-lists": {
    "title": "Linked Lists",
    "short": "A linked list is a linear data structure where elements, called nodes, are not stored in contiguous memory locations. Each node contains data and a pointer (or link) to the next node in the sequence. Linked lists are useful when dynamic memory allocation is required and when frequent insertions and deletions are performed at arbitrary positions within the list.",
    "time": "Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1)",
    "space": "O(n)",
    "code": "// A simple C++ implementation of a singly linked list\n#include <iostream>\n\n// Node class representing a node in the linked list\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Constructor to initialize a node with data\n    Node(int data) : data(data), next(nullptr) {}\n};\n\n// LinkedList class to manage the linked list\nclass LinkedList {\npublic:\n    Node* head;\n\n    // Constructor to initialize an empty linked list\n    LinkedList() : head(nullptr) {}\n\n    // Function to insert a new node at the beginning of the list\n    void insertAtBeginning(int data) {\n        Node* newNode = new Node(data);\n        newNode->next = head;\n        head = newNode;\n    }\n\n    // Function to insert a new node at the end of the list\n    void insertAtEnd(int data) {\n        Node* newNode = new Node(data);\n        if (head == nullptr) {\n            head = newNode;\n            return;\n        }\n        Node* current = head;\n        while (current->next != nullptr) {\n            current = current->next;\n        }\n        current->next = newNode;\n    }\n\n    // Function to delete a node with a given key\n    void deleteNode(int key) {\n        Node* temp = head, *prev = nullptr;\n\n        // If head node itself holds the key to be deleted\n        if (temp != nullptr && temp->data == key) {\n            head = temp->next;  // Changed head\n            delete temp;         // free old head\n            return;\n        }\n\n        // Search for the key to be deleted, keep track of the\n        // previous node as we need to change 'prev->next'\n        while (temp != nullptr && temp->data != key) {\n            prev = temp;\n            temp = temp->next;\n        }\n\n        // If key was not present in linked list\n        if (temp == nullptr) return;\n\n        // Unlink the node from linked list\n        prev->next = temp->next;\n\n        delete temp;  // Free memory\n    }\n\n    // Function to print the linked list\n    void printList() {\n        Node* current = head;\n        while (current != nullptr) {\n            std::cout << current->data << \" \";\n            current = current->next;\n        }\n        std::cout << std::endl;\n    }\n\n    // Function to free memory allocated to the linked list\n    ~LinkedList() {\n        Node* current = head;\n        while (current != nullptr) {\n            Node* next = current->next;\n            delete current;\n            current = next;\n        }\n        head = nullptr; // Reset head after freeing memory\n    }\n};\n\nint main() {\n    // Create a linked list\n    LinkedList myList;\n\n    // Insert elements at the beginning\n    myList.insertAtBeginning(3);\n    myList.insertAtBeginning(2);\n    myList.insertAtBeginning(1);\n\n    // Insert an element at the end\n    myList.insertAtEnd(4);\n\n    std::cout << \"Linked list elements: \";\n    myList.printList(); // Output: 1 2 3 4\n\n    // Delete a node\n    myList.deleteNode(2);\n\n    std::cout << \"Linked list after deleting 2: \";\n    myList.printList(); // Output: 1 3 4\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/data-structures/linked-list/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=WwfhLC16bis"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/linked-list/"
      ]
    ]
  },
  "stacks": {
    "title": "Stacks",
    "short": "A stack is a linear data structure that follows the Last-In, First-Out (LIFO) principle, meaning the last element added is the first one removed. It operates using two primary operations: push (adding an element to the top) and pop (removing the element from the top). Stacks are frequently used in function call management, expression evaluation, and backtracking algorithms due to their simple and efficient LIFO nature.",
    "time": "Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1)",
    "space": "O(n)",
    "code": "// Stack Implementation using C++\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n    // Creating a stack of integers\n    stack<int> myStack;\n\n    // Pushing elements onto the stack\n    myStack.push(10);\n    myStack.push(20);\n    myStack.push(30);\n\n    cout << \"Stack elements: \";\n    // Accessing the top element without removing it\n    cout << \"Top element: \" << myStack.top() << endl;\n\n    // Displaying the stack's size\n    cout << \"Stack size: \" << myStack.size() << endl;\n\n    // Popping elements from the stack (LIFO)\n    cout << \"Popping elements: \";\n    while (!myStack.empty()) {\n        cout << myStack.top() << \" \"; // Display the top element\n        myStack.pop(); // Remove the top element\n    }\n    cout << endl;\n\n    // Checking if the stack is empty after popping all elements\n    if (myStack.empty()) {\n        cout << \"Stack is now empty.\" << endl;\n    } else {\n        cout << \"Stack is not empty.\" << endl;\n    }\n\n    // Example use case: Parenthesis Matching (Simplified)\n    string expression = \"({[]})\"; // Valid expression\n    stack<char> parenthesisStack;\n    bool balanced = true;\n\n    for (char c : expression) {\n        if (c == '(' || c == '{' || c == '[') {\n            parenthesisStack.push(c);\n        } else if (c == ')' || c == '}' || c == ']') {\n            if (parenthesisStack.empty()) {\n                balanced = false;\n                break;\n            }\n\n            char top = parenthesisStack.top();\n            parenthesisStack.pop();\n\n            if ((c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[')) {\n                balanced = false;\n                break;\n            }\n        }\n    }\n\n    if (!parenthesisStack.empty()) {\n        balanced = false; //Handles cases like \"((\"\n    }\n\n    if (balanced) {\n        cout << \"Parenthesis in the expression are balanced.\" << endl;\n    } else {\n        cout << \"Parenthesis in the expression are not balanced.\" << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/stack-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=MuwxVVjZ73M"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/stack/"
      ]
    ]
  },
  "queues": {
    "title": "Queues",
    "short": "A queue is a fundamental data structure that follows the First-In-First-Out (FIFO) principle, where the first element added to the queue is the first one to be removed. It operates much like a real-world queue, such as a line at a store. Queues are commonly used in various applications like task scheduling, breadth-first search algorithms, and handling requests in web servers.",
    "time": {
      "Access": "O(n)",
      "Search": "O(n)",
      "Insertion": "O(1)",
      "Deletion": "O(1)"
    },
    "space": "O(n)",
    "code": " #include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n  // Create a queue of integers\n  queue<int> myQueue;\n\n  // Enqueue elements (add to the back)\n  myQueue.push(10);\n  myQueue.push(20);\n  myQueue.push(30);\n\n  cout << \"Queue elements: \";\n  // Print the elements of the queue (without modifying it)\n  queue<int> tempQueue = myQueue; // Create a copy to avoid modifying the original\n  while (!tempQueue.empty()) {\n    cout << tempQueue.front() << \" \"; // Access the front element\n    tempQueue.pop(); // Remove the front element from the temporary queue\n  }\n  cout << endl;\n\n  // Dequeue elements (remove from the front)\n  cout << \"Dequeuing elements: \";\n  while (!myQueue.empty()) {\n    cout << myQueue.front() << \" \"; // Print the element being dequeued\n    myQueue.pop(); // Remove the front element\n  }\n  cout << endl;\n\n  // Check if the queue is empty\n  if (myQueue.empty()) {\n    cout << \"Queue is now empty.\" << endl;\n  } else {\n    cout << \"Queue is not empty.\" << endl;\n  }\n\n  // Example of using a queue for task scheduling (simulated)\n  queue<string> taskQueue;\n  taskQueue.push(\"Task A\");\n  taskQueue.push(\"Task B\");\n  taskQueue.push(\"Task C\");\n\n  cout << \"\nSimulating Task Scheduling:\" << endl;\n  while (!taskQueue.empty()) {\n    string currentTask = taskQueue.front();\n    cout << \"Executing task: \" << currentTask << endl;\n    taskQueue.pop();\n  }\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/queue-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=M9XEu0Y9eVM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/queue/"
      ]
    ]
  },
  "linear-search": {
    "title": "Linear Search",
    "short": "Linear search, also known as sequential search, is a simple algorithm used to find a target element within a list or array. It works by sequentially checking each element of the list until the target is found or the entire list has been traversed. Linear search is best suited for small, unsorted lists or when the order of elements matters during the search.",
    "time": {
      "Access": "O(1)",
      "Search": {
        "Best": "O(1)",
        "Average": "O(n)",
        "Worst": "O(n)"
      },
      "Insertion": "N/A (Not applicable, as Linear Search itself doesn't involve insertion)",
      "Deletion": "N/A (Not applicable, as Linear Search itself doesn't involve deletion)"
    },
    "space": "O(1)",
    "code": "// C++ implementation of Linear Search\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform linear search\nint linearSearch(const vector<int>& arr, int target) {\n    // Iterate through each element of the array\n    for (size_t i = 0; i < arr.size(); ++i) {\n        // Check if the current element is equal to the target\n        if (arr[i] == target) {\n            // If found, return the index of the element\n            return i;\n        }\n    }\n    // If the target is not found, return -1\n    return -1;\n}\n\nint main() {\n    // Example usage\n    vector<int> arr = {5, 12, 8, 2, 9, 1};\n    int target = 8;\n\n    // Call the linearSearch function\n    int index = linearSearch(arr, target);\n\n    // Print the result\n    if (index != -1) {\n        cout << \"Element \" << target << \" found at index \" << index << endl;\n    } else {\n        cout << \"Element \" << target << \" not found in the array\" << endl;\n    }\n\n    target = 15; // Element not present in the array\n    index = linearSearch(arr, target);\n\n        // Print the result\n    if (index != -1) {\n        cout << \"Element \" << target << \" found at index \" << index << endl;\n    } else {\n        cout << \"Element \" << target << \" not found in the array\" << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/linear-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=CZ3y5c75vsI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/linear-search/"
      ]
    ]
  },
  "binary-search": {
    "title": "Binary Search",
    "short": "Binary search is an efficient algorithm used to find the position of a target value within a sorted array. It works by repeatedly dividing the search interval in half. If the target value matches the middle element, its index is returned; otherwise, the search continues in either the left or right half of the array, depending on whether the target is less than or greater than the middle element, respectively. Binary search excels when needing to search a sorted dataset quickly and efficiently.",
    "time": "Average: O(log n), Best: O(1), Worst: O(log n)",
    "space": "O(1)",
    "code": "// C++ implementation of Binary Search\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform binary search on a sorted vector\nint binarySearch(const vector<int>& arr, int target) {\n    int low = 0;\n    int high = arr.size() - 1;\n\n    // Continue searching while the low index is less than or equal to the high index\n    while (low <= high) {\n        // Calculate the middle index (to avoid overflow, use low + (high - low) / 2)\n        int mid = low + (high - low) / 2;\n\n        // If the target is found at the middle index, return the index\n        if (arr[mid] == target) {\n            return mid;\n        }\n\n        // If the target is smaller than the middle element, search in the left half\n        else if (arr[mid] > target) {\n            high = mid - 1;\n        }\n\n        // If the target is larger than the middle element, search in the right half\n        else {\n            low = mid + 1;\n        }\n    }\n\n    // If the target is not found, return -1\n    return -1;\n}\n\nint main() {\n    // Example usage\n    vector<int> sortedArray = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int targetValue = 23;\n\n    // Perform binary search\n    int resultIndex = binarySearch(sortedArray, targetValue);\n\n    // Print the result\n    if (resultIndex == -1) {\n        cout << \"Target value not found in the array.\" << endl;\n    } else {\n        cout << \"Target value found at index: \" << resultIndex << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=ZR_AoW-3ehs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search/"
      ]
    ]
  },
  "bubble-sort": {
    "title": "Bubble Sort",
    "short": "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. It's primarily used for educational purposes due to its simplicity, but is inefficient for large datasets.",
    "time": {
      "average": "O(n^2)",
      "best": "O(n)",
      "worst": "O(n^2)"
    },
    "space": "O(1)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform Bubble Sort\nvoid bubbleSort(vector<int>& arr) {\n  int n = arr.size();\n  bool swapped;\n  for (int i = 0; i < n - 1; i++) {\n    swapped = false; // Optimization: Check if any swaps occurred in this pass\n    for (int j = 0; j < n - i - 1; j++) {\n      // Compare adjacent elements\n      if (arr[j] > arr[j + 1]) {\n        // Swap if they are in the wrong order\n        swap(arr[j], arr[j + 1]);\n        swapped = true; // Mark that a swap occurred\n      }\n    }\n\n    // If no two elements were swapped in inner loop,\n    // the array is sorted\n    if (swapped == false)\n      break;\n  }\n}\n\n// Function to print a vector\nvoid printVector(const vector<int>& arr) {\n  for (int i = 0; i < arr.size(); i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n}\n\nint main() {\n  vector<int> arr = {64, 34, 25, 12, 22, 11, 90};\n\n  cout << \"Unsorted array: \";\n  printVector(arr);\n\n  bubbleSort(arr); // Sort the array\n\n  cout << \"Sorted array: \";\n  printVector(arr);\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/bubble-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=nmhjrI-aW5o"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/bubble-sort/"
      ]
    ]
  },
  "selection-sort": {
    "title": "Selection Sort",
    "short": "Selection sort is a simple sorting algorithm that repeatedly finds the minimum element from the unsorted portion of the list and places it at the beginning. The algorithm divides the input list into two parts: the sorted sublist, which is built up from left to right at the front (left) of the list, and the sublist of the remaining unsorted elements that occupy the rest of the list. Selection sort is known for its simplicity and ease of implementation, though it's generally inefficient for large datasets compared to more advanced algorithms.",
    "time": "Average: O(n^2), Best: O(n^2), Worst: O(n^2)",
    "space": "O(1)",
    "code": "// C++ implementation of Selection Sort\n#include <iostream>\n#include <vector>\n#include <algorithm> // For std::swap\n\nusing namespace std;\n\n// Function to perform selection sort\nvoid selectionSort(vector<int>& arr) {\n    int n = arr.size();\n\n    // One by one move boundary of unsorted subarray\n    for (int i = 0; i < n - 1; i++) {\n        // Find the minimum element in unsorted array\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++)\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n\n        // Swap the found minimum element with the first element\n        if(min_idx != i)\n            swap(arr[i], arr[min_idx]);\n    }\n}\n\n// Function to print an array\nvoid printArray(const vector<int>& arr) {\n    for (int element : arr) {\n        cout << element << \" \";\n    }\n    cout << endl;\n}\n\n// Main function to demonstrate the usage of selection sort\nint main() {\n    vector<int> arr = {64, 25, 12, 22, 11};\n    cout << \"Unsorted array: \";\n    printArray(arr);\n\n    selectionSort(arr);\n\n    cout << \"Sorted array: \";\n    printArray(arr);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/selection-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=xWBP4lUhNM0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sort/"
      ]
    ]
  },
  "insertion-sort": {
    "title": "Insertion Sort",
    "short": "Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It iterates through the input elements, taking each element and \"inserting\" it into its correct position within the already sorted portion of the array. This process continues until all elements are processed, resulting in a fully sorted array. It is efficient for small datasets or nearly sorted data.",
    "time": {
      "Access": "O(1)",
      "Search": "O(n)",
      "Insertion": "O(n)",
      "Deletion": "O(n)",
      "Best Case": "O(n)",
      "Average Case": "O(n^2)",
      "Worst Case": "O(n^2)"
    },
    "space": "O(1)",
    "code": "// Insertion Sort in C++\n#include <iostream>\n#include <vector>\n\nvoid insertionSort(std::vector<int>& arr) {\n  int n = arr.size();\n  for (int i = 1; i < n; i++) {\n    int key = arr[i]; // The element to be inserted into the sorted sequence\n    int j = i - 1; // Index of the last element in the sorted sequence\n\n    // Move elements of arr[0..i-1], that are greater than key,\n    // to one position ahead of their current position\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key; // Insert the key into its correct position\n  }\n}\n\n// Function to print the array\nvoid printArray(const std::vector<int>& arr) {\n  for (int element : arr) {\n    std::cout << element << \" \";\n  }\n  std::cout << std::endl;\n}\n\nint main() {\n  std::vector<int> arr = {12, 11, 13, 5, 6}; // Example array\n  std::cout << \"Array before sorting: \\n\";\n  printArray(arr);\n\n  insertionSort(arr); // Call the insertion sort function\n\n  std::cout << \"Array after sorting: \\n\";\n  printArray(arr);\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/insertion-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=OGzPmGSv3Nw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/insertion-sort/"
      ]
    ]
  },
  "complex-sorting-and-divide": {
    "title": "External Merge Sort",
    "short": "External merge sort is a sorting algorithm designed to handle massive datasets that are too large to fit entirely in a computer's main memory. It sorts the data in chunks that can fit in memory, then merges these sorted chunks iteratively until the entire dataset is sorted. It primarily uses disk storage to hold intermediate sorted fragments.",
    "time": "O(N log N), where N is the number of records to be sorted.",
    "space": "O(B), where B is the size of the available buffer in main memory.",
    "code": " #include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to split the input file into chunks that fit in memory\nvoid splitFile(const string& inputFile, const string& baseOutputFile, size_t chunkSize) {\n    ifstream in(inputFile, ios::binary);\n    if (!in.is_open()) {\n        cerr << \"Error: Could not open input file.\" << endl;\n        return;\n    }\n\n    size_t chunkId = 0;\n    vector<int> chunk;\n    int value;\n\n    while (in >> value) {\n        chunk.push_back(value);\n        if (chunk.size() == chunkSize) {\n            sort(chunk.begin(), chunk.end());\n            string outputFile = baseOutputFile + to_string(chunkId++) + \".txt\";\n            ofstream out(outputFile, ios::binary);\n            if (!out.is_open()) {\n                cerr << \"Error: Could not open output file \" << outputFile << endl;\n                return;\n            }\n            for (int val : chunk) {\n                out << val << \" \";\n            }\n            out.close();\n            chunk.clear();\n        }\n    }\n\n    // Handle the last chunk (if any)\n    if (!chunk.empty()) {\n        sort(chunk.begin(), chunk.end());\n        string outputFile = baseOutputFile + to_string(chunkId) + \".txt\";\n        ofstream out(outputFile, ios::binary);\n        if (!out.is_open()) {\n            cerr << \"Error: Could not open output file \" << outputFile << endl;\n            return;\n        }\n        for (int val : chunk) {\n            out << val << \" \";\n        }\n        out.close();\n    }\n    in.close();\n}\n\n// Function to merge two sorted files\nvoid mergeFiles(const string& inputFile1, const string& inputFile2, const string& outputFile) {\n    ifstream in1(inputFile1, ios::binary);\n    ifstream in2(inputFile2, ios::binary);\n    ofstream out(outputFile, ios::binary);\n\n    if (!in1.is_open() || !in2.is_open() || !out.is_open()) {\n        cerr << \"Error: Could not open input or output files for merging.\" << endl;\n        return;\n    }\n\n    int value1, value2;\n    bool hasValue1 = (in1 >> value1);\n    bool hasValue2 = (in2 >> value2);\n\n    while (hasValue1 && hasValue2) {\n        if (value1 <= value2) {\n            out << value1 << \" \";\n            hasValue1 = (in1 >> value1);\n        } else {\n            out << value2 << \" \";\n            hasValue2 = (in2 >> value2);\n        }\n    }\n\n    // Copy remaining elements from inputFile1 (if any)\n    while (hasValue1) {\n        out << value1 << \" \";\n        hasValue1 = (in1 >> value1);\n    }\n\n    // Copy remaining elements from inputFile2 (if any)\n    while (hasValue2) {\n        out << value2 << \" \";\n        hasValue2 = (in2 >> value2);\n    }\n\n    in1.close();\n    in2.close();\n    out.close();\n}\n\n// External Merge Sort function\nvoid externalMergeSort(const string& inputFile, const string& outputFile, size_t chunkSize) {\n    string baseOutputFile = \"temp_chunk_\";\n\n    // Phase 1: Split and Sort Chunks\n    splitFile(inputFile, baseOutputFile, chunkSize);\n\n    // Phase 2: Merge Chunks\n    size_t chunkId = 0;\n    while (true) {\n        string inputFile1 = baseOutputFile + to_string(chunkId++) + \".txt\";\n        string inputFile2 = baseOutputFile + to_string(chunkId++) + \".txt\";\n        string mergedFile = \"temp_merged_\" + to_string(chunkId / 2) + \".txt\";\n\n        ifstream checkFile1(inputFile1);\n        ifstream checkFile2(inputFile2);\n\n        if (!checkFile1.good()) {\n            //If the first chunk doesn't exist, then merging is complete.\n            if (chunkId==1) {\n               ifstream lastChunk (baseOutputFile + \"0.txt\");\n               ofstream finalOutput(outputFile);\n               finalOutput << lastChunk.rdbuf();\n               finalOutput.close();\n               lastChunk.close();\n            }\n\n            // Clean up temporary files. (left as an exercise to the reader!)\n            return;\n        }\n\n\n        if (!checkFile2.good()) {\n            //If only one file remains, copy to the merged file (renaming).\n\n            ifstream lastChunk(inputFile1);\n            ofstream mergedOutput(mergedFile);\n            mergedOutput << lastChunk.rdbuf();\n            lastChunk.close();\n            mergedOutput.close();\n\n\n        } else {\n            mergeFiles(inputFile1, inputFile2, mergedFile);\n        }\n\n        checkFile1.close();\n        checkFile2.close();\n\n\n        //Rename mergedFile to inputFile1.\n        remove(inputFile1.c_str()); //Delete temporary files\n        remove(inputFile2.c_str());\n\n        if (checkFile2.good()) {\n            rename(mergedFile.c_str(), inputFile1.c_str());\n            chunkId = chunkId - 1;  //Start from beginning\n        } else {\n            rename(mergedFile.c_str(), outputFile.c_str());\n\n            //Copy the result to outputFile.  This avoids an extra rename if only one file remains.\n        } \n\n        if(chunkId > 100000) { //Infinite loop protection\n            cerr << \"Stopping at max iterations.\";\n            return;   //break out of loop in case of error\n        }\n\n        //Check if there are files other than outputFile.\n    }\n\n    \n}\n\nint main() {\n    // Example usage\n    string inputFile = \"input.txt\";\n    string outputFile = \"output.txt\";\n    size_t chunkSize = 3; // Adjust chunk size based on available memory\n\n    // Create a sample input file\n    ofstream input(inputFile, ios::binary);\n    input << \"5 2 8 1 9 4 7 3 6 0\";\n    input.close();\n\n    externalMergeSort(inputFile, outputFile, chunkSize);\n\n    cout << \"External Merge Sort completed. Output in \" << outputFile << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/external-sorting/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=2Jk9-gP7VlQ"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=external%20sort"
      ]
    ]
  },
  "merge-sort": {
    "title": "Merge Sort",
    "short": "Merge Sort is a divide-and-conquer sorting algorithm. It works by recursively dividing the input array into two halves until each sub-array contains only one element (which is inherently sorted). Then, it repeatedly merges the sub-arrays to produce new sorted sub-arrays until there is only one sorted array remaining. Merge sort is often used when a stable, efficient, and predictable sorting algorithm is required.",
    "time": {
      "average": "O(n log n)",
      "best": "O(n log n)",
      "worst": "O(n log n)"
    },
    "space": "O(n)",
    "code": " #include <iostream>\n#include <vector>\n\n// Function to merge two sorted subarrays into a single sorted subarray\nvoid merge(std::vector<int>& arr, int left, int mid, int right) {\n    int n1 = mid - left + 1; // Size of the left subarray\n    int n2 = right - mid;    // Size of the right subarray\n\n    // Create temporary arrays to hold the subarrays\n    std::vector<int> L(n1), R(n2);\n\n    // Copy data to temporary arrays L[] and R[]\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    // Merge the temporary arrays back into arr[left..right]\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// Recursive function to implement Merge Sort\nvoid mergeSort(std::vector<int>& arr, int left, int right) {\n    if (left < right) {\n        // Find the middle point\n        int mid = left + (right - left) / 2;\n\n        // Recursively sort the first and second halves\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n\n        // Merge the sorted halves\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    std::vector<int> arr = {12, 11, 13, 5, 6, 7};\n    int n = arr.size();\n\n    std::cout << \"Unsorted array: \\n\";\n    for (int i = 0; i < n; i++)\n        std::cout << arr[i] << \" \";\n    std::cout << \"\\n\";\n\n    mergeSort(arr, 0, n - 1);\n\n    std::cout << \"Sorted array: \\n\";\n    for (int i = 0; i < n; i++)\n        std::cout << arr[i] << \" \";\n    std::cout << \"\\n\";\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/merge-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=KF2j-9i8lB8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/merge-sort/"
      ]
    ]
  },
  "quick-sort": {
    "title": "Quick Sort",
    "short": "Quick Sort is a divide-and-conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted. This process continues until the entire array is sorted. It's widely used due to its efficiency in practice, despite its worst-case time complexity.",
    "time": {
      "average": "O(n log n)",
      "best": "O(n log n)",
      "worst": "O(n^2)"
    },
    "space": "O(log n)",
    "code": "// C++ implementation of QuickSort\n#include <iostream>\n#include <vector>\n#include <algorithm> // For std::swap and std::random_shuffle\n#include <random>\n\nusing namespace std;\n\n// Function to partition the array and return the partition index\nint partition(vector<int>& arr, int low, int high) {\n    // Choose the pivot (in this case, the last element)\n    int pivot = arr[high];\n    \n    // Index of smaller element and indicates the right position for pivot found so far\n    int i = (low - 1);\n\n    for (int j = low; j <= high - 1; j++) {\n        // If the current element is smaller than or equal to the pivot\n        if (arr[j] <= pivot) {\n            i++; // increment index of smaller element\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\n// Function to implement QuickSort\nvoid quickSort(vector<int>& arr, int low, int high) {\n    if (low < high) {\n        // pi is partitioning index, arr[pi] is now at right place \n        int pi = partition(arr, low, high);\n\n        // Separately sort elements before partition and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Function to print an array\nvoid printArray(const vector<int>& arr) {\n    for (int value : arr) {\n        cout << value << \" \";\n    }\n    cout << endl;\n}\n\n// Function to shuffle the array to avoid worst case performance on sorted/nearly sorted arrays\nvoid shuffleArray(vector<int>& arr) {\n    random_device rd;\n    mt19937 g(rd());\n    shuffle(arr.begin(), arr.end(), g);\n}\n\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n\n    cout << \"Unsorted array: \\n\";\n    printArray(arr);\n\n    //Shuffle the array for better average case performance\n    shuffleArray(arr);\n\n    quickSort(arr, 0, n - 1);\n\n    cout << \"Sorted array: \\n\";\n    printArray(arr);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/quick-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=QN7wKt9K_nM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/quickselect/"
      ]
    ]
  },
  "heap-sort": {
    "title": "Heap Sort",
    "short": "Heap Sort is a comparison-based sorting algorithm that leverages the properties of a binary heap data structure to efficiently sort elements. It first builds a max-heap (or min-heap) from the input data. Then, it repeatedly extracts the maximum (or minimum) element from the heap and places it at the end of the sorted portion of the array. Heap sort is an in-place algorithm, meaning it doesn't require significant extra memory beyond the input array.",
    "time": {
      "Average": "O(n log n)",
      "Best": "O(n log n)",
      "Worst": "O(n log n)"
    },
    "space": "O(1)",
    "code": "// Heap Sort implementation in C++\n#include <iostream>\n#include <vector>\n\n// Function to heapify a subtree rooted at node i\n// n is the size of the heap\nvoid heapify(std::vector<int>& arr, int n, int i) {\n  int largest = i; // Initialize largest as root\n  int left = 2 * i + 1; // left = 2*i + 1\n  int right = 2 * i + 2; // right = 2*i + 2\n\n  // If left child is larger than root\n  if (left < n && arr[left] > arr[largest])\n    largest = left;\n\n  // If right child is larger than largest so far\n  if (right < n && arr[right] > arr[largest])\n    largest = right;\n\n  // If largest is not root\n  if (largest != i) {\n    std::swap(arr[i], arr[largest]);\n\n    // Recursively heapify the affected sub-tree\n    heapify(arr, n, largest);\n  }\n}\n\n// Main function to do heap sort\nvoid heapSort(std::vector<int>& arr, int n) {\n  // Build max heap\n  for (int i = n / 2 - 1; i >= 0; i--)\n    heapify(arr, n, i);\n\n  // One by one extract an element from heap\n  for (int i = n - 1; i > 0; i--) {\n    // Move current root to end\n    std::swap(arr[0], arr[i]);\n\n    // call max heapify on the reduced heap\n    heapify(arr, i, 0);\n  }\n}\n\n// Function to print an array\nvoid printArray(const std::vector<int>& arr) {\n  for (int value : arr)\n    std::cout << value << \" \";\n  std::cout << std::endl;\n}\n\nint main() {\n  std::vector<int> arr = {12, 11, 13, 5, 6, 7};\n  int n = arr.size();\n\n  std::cout << \"Unsorted array: \\n\";\n  printArray(arr);\n\n  heapSort(arr, n);\n\n  std::cout << \"Sorted array: \\n\";\n  printArray(arr);\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/heap-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=HqPJF2L5h9U"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/heap/"
      ]
    ]
  },
  "counting-sort": {
    "title": "Counting Sort",
    "short": "Counting sort is a non-comparison based sorting algorithm that sorts elements by counting the number of occurrences of each unique key in the input array. This count is then used to determine the position of each key in the sorted output array. Counting sort is most effective when the range of input values is not significantly greater than the number of elements to be sorted, and is often used as a subroutine in radix sort.",
    "time": "Average: O(n+k), Best: O(n+k), Worst: O(n+k) (where n is the number of elements in the input array and k is the range of input values)",
    "space": "O(k) (where k is the range of input values)",
    "code": "// Counting Sort Implementation\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform counting sort\nvoid countingSort(vector<int>& arr) {\n  // Find the maximum element to determine the range\n  int maxElement = 0;\n  for (int num : arr) {\n    if (num > maxElement) {\n      maxElement = num;\n    }\n  }\n\n  // Initialize the count array with size maxElement + 1 and all elements set to 0\n  vector<int> count(maxElement + 1, 0);\n\n  // Count the occurrences of each element in the input array\n  for (int num : arr) {\n    count[num]++;\n  }\n\n  // Modify the count array to store the cumulative counts\n  for (int i = 1; i <= maxElement; ++i) {\n    count[i] += count[i - 1];\n  }\n\n  // Create an output array to store the sorted elements\n  vector<int> output(arr.size());\n\n  // Place elements into the output array in sorted order\n  for (int i = arr.size() - 1; i >= 0; --i) {\n    output[count[arr[i]] - 1] = arr[i];\n    count[arr[i]]--;\n  }\n\n  // Copy the sorted elements from the output array back to the input array\n  for (int i = 0; i < arr.size(); ++i) {\n    arr[i] = output[i];\n  }\n}\n\nint main() {\n  vector<int> arr = {4, 2, 2, 8, 3, 3, 1};\n\n  cout << \"Unsorted array: \";\n  for (int num : arr) {\n    cout << num << \" \";\n  }\n  cout << endl;\n\n  countingSort(arr);\n\n  cout << \"Sorted array: \";\n  for (int num : arr) {\n    cout << num << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/counting-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=O9dN20RA-b8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sort/"
      ]
    ]
  },
  "radix-sort": {
    "title": "Radix Sort",
    "short": "Radix sort is a non-comparative sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. It's an efficient sorting method for integers and strings when the range of the data is known and the maximum length or value is not excessively large. Radix sort is particularly effective for sorting large datasets with uniformly distributed keys.",
    "time": "Average: O(nk), Best: O(nk), Worst: O(nk), where n is the number of elements and k is the number of digits or characters in the longest key.",
    "space": "O(n+k), where n is the number of elements and k is the range of possible digit values.",
    "code": "// Radix Sort Implementation in C++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to get the digit at a specific position (from right to left)\nint getDigit(int num, int place) {\n    int divisor = 1;\n    for (int i = 0; i < place; ++i) {\n        divisor *= 10;\n    }\n    return (num / divisor) % 10;\n}\n\n// Radix Sort Function\nvoid radixSort(vector<int>& arr) {\n    // Find the maximum number to determine the number of digits\n    int maxVal = *max_element(arr.begin(), arr.end());\n\n    // Count the number of digits in the maximum value\n    int numDigits = 0;\n    while (maxVal > 0) {\n        maxVal /= 10;\n        numDigits++;\n    }\n\n    // Perform counting sort for each digit, starting from the least significant digit\n    for (int place = 0; place < numDigits; ++place) {\n        // Create a count array to store the frequency of each digit (0-9)\n        vector<int> count(10, 0);\n\n        // Count the occurrences of each digit at the current place\n        for (int num : arr) {\n            int digit = getDigit(num, place);\n            count[digit]++;\n        }\n\n        // Update the count array to store the cumulative counts\n        for (int i = 1; i < 10; ++i) {\n            count[i] += count[i - 1];\n        }\n\n        // Create a temporary output array\n        vector<int> output(arr.size());\n\n        // Build the output array in reverse order to maintain stability\n        for (int i = arr.size() - 1; i >= 0; --i) {\n            int digit = getDigit(arr[i], place);\n            output[count[digit] - 1] = arr[i];\n            count[digit]--;\n        }\n\n        // Copy the output array back to the original array\n        arr = output;\n    }\n}\n\nint main() {\n    vector<int> arr = {170, 45, 75, 90, 802, 24, 2, 66};\n\n    cout << \"Unsorted array: \";\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    radixSort(arr);\n\n    cout << \"Sorted array: \";\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/radix-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=YXkCpN23-Vw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/radix-sort/"
      ]
    ]
  },
  "bucket-sort": {
    "title": "Bucket Sort",
    "short": "Bucket Sort is a distribution sort that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying bucket sort. It is mainly useful when the input is uniformly distributed over a range, leading to better performance.",
    "time": "Average: O(n+k), Best: O(n+k), Worst: O(n^2) (when elements are not uniformly distributed)",
    "space": "O(n+k)",
    "code": "// C++ implementation of Bucket Sort\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to perform bucket sort\nvoid bucketSort(float arr[], int n) {\n  // 1) Create n empty buckets\n  vector<vector<float>> buckets(n);\n\n  // 2) Put array elements in different buckets\n  for (int i = 0; i < n; i++) {\n    int bucketIndex = n * arr[i]; // Index in bucket range from 0 to n-1\n    buckets[bucketIndex].push_back(arr[i]);\n  }\n\n  // 3) Sort individual buckets\n  for (int i = 0; i < n; i++) {\n    sort(buckets[i].begin(), buckets[i].end());\n  }\n\n  // 4) Concatenate all buckets into arr[]\n  int index = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < buckets[i].size(); j++) {\n      arr[index++] = buckets[i][j];\n    }\n  }\n}\n\n// Driver program to test above function\nint main() {\n  float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n  int n = sizeof(arr) / sizeof(arr[0]);\n\n  bucketSort(arr, n);\n\n  cout << \"Sorted array is \\n\";\n  for (int i = 0; i < n; i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/bucket-sort-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=VuXyxqgC5yA"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/eY0t8JmD/"
      ]
    ]
  },
  "shell-sort": {
    "title": "Shell Sort",
    "short": "Shell sort is a generalized version of insertion sort that allows the exchange of items that are far apart. It improves upon insertion sort by first sorting elements that are far apart from each other and progressively reducing the gap between elements to be compared. This helps move misplaced elements closer to their correct positions much faster than insertion sort.",
    "time": {
      "Average": "O(n log n) to O(n (log n)^2) depending on the gap sequence",
      "Best": "O(n log n)",
      "Worst": "O(n^2)"
    },
    "space": "O(1)",
    "code": "// Shell Sort Implementation in C++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform Shell Sort\nvoid shellSort(vector<int>& arr) {\n  int n = arr.size();\n\n  // Start with a large gap and reduce it iteratively\n  for (int gap = n / 2; gap > 0; gap /= 2) {\n    // Do a gapped insertion sort for this gap size.\n    // The first gap elements arr[0..gap-1] are already in gapped order\n    // keep adding one more element until the entire array is gap sorted\n    for (int i = gap; i < n; i++) {\n      // Add arr[i] to the elements that have been gap sorted\n      // Save arr[i] in temp and make a hole at position i\n      int temp = arr[i];\n\n      // Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n      int j;\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n        arr[j] = arr[j - gap];\n      }\n\n      // Put temp (the original arr[i]) in its correct location\n      arr[j] = temp;\n    }\n  }\n}\n\n// Function to print an array\nvoid printArray(const vector<int>& arr) {\n  for (int num : arr) {\n    cout << num << \" \";\n  }\n  cout << endl;\n}\n\n// Main function for testing\nint main() {\n  vector<int> arr = {12, 34, 54, 2, 3, 33, 1, 5};\n\n  cout << \"Array before sorting: \";\n  printArray(arr);\n\n  shellSort(arr);\n\n  cout << \"Array after sorting: \";\n  printArray(arr);\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/shellsort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=CmPA7zE8mx0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/shellsort/"
      ]
    ]
  },
  "hash-tables": {
    "title": "Hash Tables",
    "short": "Hash tables, also known as hash maps, are data structures that implement an associative array abstract data type, which maps keys to values. They work by using a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Hash tables are commonly used for efficient storage and retrieval of data based on keys, especially in situations where fast lookups are crucial, like caching, indexing, and implementing symbol tables.",
    "time": {
      "Access": "Average: O(1), Best: O(1), Worst: O(n)",
      "Search": "Average: O(1), Best: O(1), Worst: O(n)",
      "Insertion": "Average: O(1), Best: O(1), Worst: O(n)",
      "Deletion": "Average: O(1), Best: O(1), Worst: O(n)"
    },
    "space": "O(n)",
    "code": " #include <iostream>\n#include <vector>\n#include <string>\n\n// Simple hash function (for demonstration purposes only)\nsize_t hash_function(const std::string& key, size_t capacity) {\n    size_t hash = 5381; // Initial hash value\n    for (char c : key) {\n        hash = ((hash << 5) + hash) + c; // hash * 33 + c\n    }\n    return hash % capacity; // Ensure hash is within the table's bounds\n}\n\n// Hash Table Implementation with Separate Chaining\ntemplate <typename K, typename V>\nclass HashTable {\nprivate:\n    std::vector<std::vector<std::pair<K, V>>> table; // The hash table itself (vector of linked lists)\n    size_t capacity; // The number of buckets in the hash table\n    size_t size; // The number of key-value pairs stored in the hash table\n\npublic:\n    // Constructor\n    HashTable(size_t capacity) : capacity(capacity), size(0) {\n        table.resize(capacity);\n    }\n\n    // Insert a key-value pair into the hash table\n    void insert(const K& key, const V& value) {\n        size_t index = hash_function(key, capacity);\n        table[index].push_back({key, value});\n        size++;\n    }\n\n    // Retrieve the value associated with a given key\n    V* get(const K& key) {\n        size_t index = hash_function(key, capacity);\n        for (auto& pair : table[index]) {\n            if (pair.first == key) {\n                return &pair.second;\n            }\n        }\n        return nullptr; // Key not found\n    }\n\n    // Delete a key-value pair from the hash table\n    void remove(const K& key) {\n        size_t index = hash_function(key, capacity);\n        for (auto it = table[index].begin(); it != table[index].end(); ++it) {\n            if (it->first == key) {\n                table[index].erase(it);\n                size--;\n                return;\n            }\n        }\n    }\n\n    // Get the current size of the hash table\n    size_t getSize() const {\n        return size;\n    }\n\n    // Get the capacity of the hash table\n    size_t getCapacity() const {\n        return capacity;\n    }\n\n    // Function to print the hash table (for debugging purposes)\n    void print() const {\n        for (size_t i = 0; i < capacity; ++i) {\n            std::cout << \"Bucket \" << i << \": \";\n            for (const auto& pair : table[i]) {\n                std::cout << \"(\" << pair.first << \", \" << pair.second << \") \";\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\nint main() {\n    // Example Usage\n    HashTable<std::string, int> hashTable(10); // Create a hash table with a capacity of 10\n\n    hashTable.insert(\"apple\", 1);\n    hashTable.insert(\"banana\", 2);\n    hashTable.insert(\"cherry\", 3);\n    hashTable.insert(\"date\", 4);\n\n    std::cout << \"Hash Table Size: \" << hashTable.getSize() << std::endl;\n\n    int* value = hashTable.get(\"banana\");\n    if (value != nullptr) {\n        std::cout << \"Value for banana: \" << *value << std::endl;\n    } else {\n        std::cout << \"Key 'banana' not found.\"\n                  << std::endl;  // Fix: Added missing endl\n    }\n\n    hashTable.remove(\"banana\");\n    std::cout << \"Hash Table Size after removing banana: \" << hashTable.getSize() << std::endl;\n\n    value = hashTable.get(\"banana\");\n    if (value != nullptr) {\n        std::cout << \"Value for banana: \" << *value << std::endl;\n    } else {\n        std::cout << \"Key 'banana' not found.\"\n                  << std::endl; // Fix: Added missing endl\n    }\n\n    hashTable.print();\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/hashing-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=shs0KM3wKv8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/hash-table/"
      ]
    ]
  },
  "principles-and-examples": {
    "title": "Binary Search",
    "short": "Binary search is an efficient algorithm for finding a target value within a sorted array. It works by repeatedly dividing the search interval in half. If the middle element matches the target, the index is returned. Otherwise, the search continues in either the left or right half of the array, depending on whether the target is less than or greater than the middle element.",
    "time": "Average: O(log n), Best: O(1), Worst: O(log n)",
    "space": "O(1)",
    "code": "// C++ implementation of Binary Search\n#include <iostream>\n#include <vector>\n\n// Function to perform binary search\nint binarySearch(const std::vector<int>& arr, int target) {\n    int low = 0;\n    int high = arr.size() - 1;\n\n    while (low <= high) {\n        int mid = low + (high - low) / 2; // Prevent potential overflow\n\n        if (arr[mid] == target) {\n            return mid; // Target found at index mid\n        } else if (arr[mid] < target) {\n            low = mid + 1; // Search in the right half\n        } else {\n            high = mid - 1; // Search in the left half\n        }\n    }\n\n    return -1; // Target not found\n}\n\nint main() {\n    std::vector<int> sortedArray = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int targetValue = 23;\n\n    int result = binarySearch(sortedArray, targetValue);\n\n    if (result == -1) {\n        std::cout << \"Element is not found in array\" << std::endl;\n    } else {\n        std::cout << \"Element is found at index: \" << result << std::endl;\n    }\n\n    targetValue = 50; // Test with a value not present\n    result = binarySearch(sortedArray, targetValue);\n\n     if (result == -1) {\n        std::cout << \"Element is not found in array\" << std::endl;\n    } else {\n        std::cout << \"Element is found at index: \" << result << std::endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=VgvKypAPYA0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search/"
      ]
    ]
  },
  "mathematical-recursion": {
    "title": "Mathematical Recursion",
    "short": "Mathematical recursion is a technique where a function is defined in terms of itself. This typically involves breaking down a problem into smaller, self-similar subproblems until a base case is reached, which can be solved directly. Recursion is a fundamental concept in computer science and mathematics, often used to solve problems with a naturally recursive structure like factorial calculation, tree traversals, and divide-and-conquer algorithms.",
    "time": "Varies depending on the function; often exponential if not optimized, can be linear or logarithmic if tail-recursive or with memoization.",
    "space": "O(n) in the worst case, where n is the maximum depth of the recursion stack. Can be O(1) if tail recursion is optimized.",
    "code": "// A simple example of mathematical recursion: calculating factorial\n#include <iostream>\n\n// Recursive function to calculate factorial of a number n\n// Factorial(n) = n * Factorial(n-1) for n > 0\n// Factorial(0) = 1 (base case)\nunsigned long long factorial(int n) {\n    // Base case: if n is 0, return 1\n    if (n == 0) {\n        return 1;\n    }\n    // Recursive step: multiply n by the factorial of n-1\n    else if (n > 0){\n        return n * factorial(n - 1);\n    }\n    else {\n        std::cerr << \"Error: Cannot compute factorial of negative number\" << std::endl;\n        return 0; // Or throw an exception\n    }\n}\n\n// Another example: Fibonacci sequence\n// F(n) = F(n-1) + F(n-2) for n > 1\n// F(0) = 0, F(1) = 1 (base cases)\n\nunsigned long long fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int num = 5;\n    std::cout << \"Factorial of \" << num << \" is: \" << factorial(num) << std::endl;\n    std::cout << \"Fibonacci of \" << num << \" is: \" << fibonacci(num) << std::endl;\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/recursion/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=KEEKn7Me-64"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/recursion-i/"
      ]
    ]
  },
  "backtracking-recursion-basics": {
    "title": "Backtracking Recursion Basics",
    "short": "Backtracking is a general algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing solutions that fail to satisfy the constraints of the problem at any point of time. It explores all possible solutions by abandoning a partial solution if it determines that the solution cannot lead to a valid full solution. Commonly used in constraint satisfaction problems like the N-Queens problem, Sudoku solvers, and generating permutations/combinations.",
    "time": "O(b^d), where b is the branching factor (number of choices at each step) and d is the depth of the search tree.",
    "space": "O(d), where d is the maximum depth of the recursion (e.g., stack space).",
    "code": "// Backtracking example: Generating all permutations of a string\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to generate permutations of a string using backtracking\nvoid permute(string str, int l, int r, vector<string>& result) {\n    // Base case: When l and r are equal, it means we have reached a leaf node\n    // and a permutation is complete\n    if (l == r) {\n        result.push_back(str);\n    } else {\n        // Try all possible swaps at each position\n        for (int i = l; i <= r; i++) {\n            // Swap the current character with str[l]\n            swap(str[l], str[i]);\n\n            // Recursively generate permutations for the remaining part of the string\n            permute(str, l + 1, r, result);\n\n            // Backtrack: Swap back to restore the original string.  This is crucial\n            // for exploring other possibilities.\n            swap(str[l], str[i]);\n        }\n    }\n}\n\nint main() {\n    string str = \"ABC\";\n    vector<string> permutations;\n    int n = str.length();\n\n    // Call the permute function to generate all permutations\n    permute(str, 0, n - 1, permutations);\n\n    // Print the permutations\n    cout << \"Permutations of \" << str << \" are:\" << endl;\n    for (const string& permutation : permutations) {\n        cout << permutation << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/backtracking-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=DKCbsiDBiAg"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/backtracking/"
      ]
    ]
  },
  "two-pointer": {
    "title": "Two Pointer Technique",
    "short": "The Two Pointer technique is an algorithm design paradigm that uses two pointers (indices) to traverse a data structure, often an array or linked list, in a coordinated manner. These pointers typically move towards each other, away from each other, or in the same direction, depending on the problem requirements.  It's primarily used to reduce time complexity by eliminating unnecessary iterations and is commonly applied to sorted arrays or lists to find pairs, triplets, or other combinations that satisfy a given condition.",
    "time": "O(n) - often linear time, but can be O(n log n) if sorting is needed beforehand",
    "space": "O(1) - typically constant space",
    "code": "// Two Pointer technique example: Find if a sorted array contains a pair with a given sum\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/*\n  This function uses the two-pointer technique to find if a sorted array\n  contains a pair of elements whose sum is equal to a given target sum.\n\n  Parameters:\n    arr: A sorted vector of integers.\n    targetSum: The target sum to find.\n\n  Returns:\n    True if a pair with the target sum is found, false otherwise.\n*/\nbool hasPairWithSum(const vector<int>& arr, int targetSum) {\n  // Check if the array is empty\n  if (arr.empty()) {\n    return false;\n  }\n\n  // Initialize two pointers, one at the beginning and one at the end of the array.\n  int left = 0;\n  int right = arr.size() - 1;\n\n  // Iterate until the two pointers meet.\n  while (left < right) {\n    // Calculate the current sum of the elements at the two pointers.\n    int currentSum = arr[left] + arr[right];\n\n    // If the current sum is equal to the target sum, return true.\n    if (currentSum == targetSum) {\n      return true;\n    } else if (currentSum < targetSum) {\n      // If the current sum is less than the target sum, move the left pointer to the right.\n      left++;\n    } else {\n      // If the current sum is greater than the target sum, move the right pointer to the left.\n      right--;\n    }\n  }\n\n  // If no pair with the target sum is found, return false.\n  return false;\n}\n\nint main() {\n  vector<int> arr = {2, 7, 11, 15};\n  int targetSum = 9;\n\n  if (hasPairWithSum(arr, targetSum)) {\n    cout << \"Array contains a pair with sum \" << targetSum << endl;\n  } else {\n    cout << \"Array does not contain a pair with sum \" << targetSum << endl;\n  }\n\n  vector<int> arr2 = {1, 2, 3, 4, 5};\n  int targetSum2 = 10;\n\n  if (hasPairWithSum(arr2, targetSum2)) {\n        cout << \"Array contains a pair with sum \" << targetSum2 << endl;\n  } else {\n        cout << \"Array does not contain a pair with sum \" << targetSum2 << endl;\n  }\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/two-pointers-technique/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=jFJu5_H_aIY"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/two-pointers/"
      ]
    ]
  },
  "two-pointer-problems": {
    "title": "Two Pointer Problems",
    "short": "The two pointer technique is an algorithmic pattern that uses two pointers to iterate through a data structure (usually an array or linked list) in a coordinated manner. It is often employed to efficiently solve problems involving searching, sorting, merging, or modifying elements while maintaining specific conditions or relationships between the elements pointed to. This approach often leads to solutions with improved time complexity compared to brute-force methods.",
    "time": "O(N) - where N is the size of the input array/linked list, in most common applications.",
    "space": "O(1) - because it generally involves using only a constant amount of extra space for the pointers.",
    "code": " #include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find a pair in a sorted array that sums up to a target value using the two pointer technique.\nbool findPairSum(vector<int>& arr, int target) {\n    // Check if the array is empty or has fewer than two elements.\n    if (arr.empty() || arr.size() < 2) {\n        return false;\n    }\n\n    // Initialize two pointers, one at the beginning and one at the end of the array.\n    int left = 0;\n    int right = arr.size() - 1;\n\n    // Iterate until the pointers meet.\n    while (left < right) {\n        // Calculate the sum of the elements pointed to by the two pointers.\n        int sum = arr[left] + arr[right];\n\n        // If the sum is equal to the target, we have found a pair.\n        if (sum == target) {\n            cout << \"Pair found: (\" << arr[left] << \", \" << arr[right] << \")\" << endl;\n            return true;\n        }\n        // If the sum is less than the target, move the left pointer to the right to increase the sum.\n        else if (sum < target) {\n            left++;\n        }\n        // If the sum is greater than the target, move the right pointer to the left to decrease the sum.\n        else {\n            right--;\n        }\n    }\n\n    // If no pair is found, return false.\n    cout << \"Pair not found.\" << endl;\n    return false;\n}\n\n// Example usage\nint main() {\n    vector<int> arr = {2, 7, 11, 15};\n    int target = 9;\n\n    findPairSum(arr, target); // Output: Pair found: (2, 7)\n\n    vector<int> arr2 = {1, 2, 3, 4, 5};\n    int target2 = 10;\n\n    findPairSum(arr2, target2); // Output: Pair not found.\n\n    vector<int> arr3 = {10, 20, 35, 50, 75, 80}; //sorted\n    int target3 = 70;\n    findPairSum(arr3, target3); //output: Pair found: (20, 50)\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/two-pointers-technique/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=j3t8T8cO868"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/two-pointers/"
      ]
    ]
  },
  "sliding-window": {
    "title": "Sliding Window",
    "short": "The sliding window technique is a problem-solving approach used to reduce the time complexity of certain algorithms, primarily those involving arrays or strings. It works by maintaining a window (a sub-array or sub-string) of a specific or variable size that slides through the data structure. This technique is efficient because it avoids redundant calculations by reusing previously computed information as the window moves, leading to optimized solutions for problems like finding the maximum sum subarray or the longest substring without repeating characters.",
    "time": "Generally O(N), where N is the size of the input array or string. In some cases, with nested loops to adjust the window size dynamically, the complexity can approach O(N*M), but it's often still significantly better than brute-force approaches.",
    "space": "O(1) for fixed-size windows; O(K) for variable-size windows, where K represents the maximum size of the window or the number of distinct elements being tracked within the window (e.g., using a hash map).",
    "code": "// Sliding Window Example: Find the maximum sum of a subarray of size k\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the maximum sum of a subarray of size k\nint maxSubarraySum(const vector<int>& arr, int k) {\n    // Check for invalid input\n    if (arr.empty() || k <= 0 || k > arr.size()) {\n        return -1; // Indicate an error or invalid input\n    }\n\n    int maxSum = 0; // Initialize the maximum sum\n    int currentSum = 0; // Initialize the current sum for the window\n\n    // Calculate the initial sum of the first k elements\n    for (int i = 0; i < k; ++i) {\n        currentSum += arr[i];\n    }\n    maxSum = currentSum;\n\n    // Slide the window through the array\n    for (int i = k; i < arr.size(); ++i) {\n        // Subtract the first element of the previous window and add the next element\n        currentSum += arr[i] - arr[i - k];\n\n        // Update the maximum sum if the current sum is greater\n        maxSum = max(maxSum, currentSum);\n    }\n\n    return maxSum;\n}\n\nint main() {\n    vector<int> arr = {1, 4, 2, 10, 2, 3, 1, 0, 20};\n    int k = 4; // Size of the subarray\n\n    int maxSum = maxSubarraySum(arr, k);\n\n    if (maxSum != -1) {\n        cout << \"Maximum sum of a subarray of size \" << k << \" is: \" << maxSum << endl;\n    } else {\n        cout << \"Invalid input or error occurred.\" << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/window-sliding-technique/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=MK-NZ4hN7rs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sliding-window/"
      ]
    ]
  },
  "advanced-data-structures": {
    "title": "B-Tree",
    "short": "A B-Tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. It is optimized for disk-oriented storage because it minimizes the number of disk accesses required. B-Trees are commonly used in database and file systems where data is organized in blocks on disk.",
    "time": "Average: Access - O(log n), Search - O(log n), Insertion - O(log n), Deletion - O(log n); Best: Access - O(1), Search - O(1), Insertion - O(1) if space available, Deletion - O(1) if leaf node; Worst: Access - O(log n), Search - O(log n), Insertion - O(log n), Deletion - O(log n)",
    "space": "O(n)",
    "code": "#include <iostream>\n#include <vector>\n\n// Assuming a minimum degree t for the B-Tree\nclass BTreeNode {\npublic:\n    std::vector<int> keys; // Array to hold the keys\n    int t;             // Minimum degree (defines range for number of keys)\n    BTreeNode** children; // Array of child pointers\n    int n;             // Current number of keys\n    bool leaf;         // Is true when node is leaf. Otherwise false\n\n    BTreeNode(int t, bool leaf);\n\n    // Function to traverse all nodes in a subtree rooted with this node\n    void traverse();\n\n    // Function to search key k in subtree rooted with this node\n    BTreeNode* search(int k);   // returns NULL if k is not present.\n\n    // A function to split the child y of this node\n    // Note that y must be full when this function is called\n    void splitChild(int i, BTreeNode* y);\n\n    // A function to insert a new key in this B-Tree node\n    void insertNonFull(int k);\n\n    // A function to delete a key from this node.\n    void deleteKey(int k);\n\n    // A function to find the predecessor of a node\n    int findPredecessor();\n\n    // A function to find the successor of a node\n    int findSuccessor();\n\n    // A function to remove a key from a leaf node\n    void removeFromLeaf(int idx);\n\n    // A function to remove a key from a non-leaf node\n    void removeFromNonLeaf(int idx);\n\n    // A function to fill the child node (at index idx) if it has less than t keys\n    void fill(int idx);\n\n    // A function to borrow a key from the previous child\n    void borrowFromPrev(int idx);\n\n    // A function to borrow a key from the next child\n    void borrowFromNext(int idx);\n\n    // A function to merge the child node (at index idx) with its sibling\n    void merge(int idx);\n};\n\nclass BTree {\npublic:\n    BTreeNode* root; // Pointer to root node\n    int t;      // Minimum degree\n\n    BTree(int t);\n\n    // function to traverse the tree\n    void traverse();\n\n    // function to search a key in the tree\n    BTreeNode* search(int k); // returns NULL if k is not present.\n\n    // The main function that inserts a new key in this B-Tree\n    void insert(int k);\n\n    // The main function that deletes a new key in this B-Tree\n    void remove(int k);\n};\n\n// Constructor for BTreeNode class\nBTreeNode::BTreeNode(int t1, bool leaf1) {\n    t = t1;\n    leaf = leaf1;\n\n    keys.resize(2 * t - 1); // Allocate memory for maximum keys\n    children = new BTreeNode* [2 * t]; // Allocate memory for maximum children\n\n    n = 0; // Initialize number of keys as 0\n}\n\n// Function to traverse all nodes in a subtree rooted with this node\nvoid BTreeNode::traverse() {\n    // There are n keys and n+1 children, travers through n keys\n    int i;\n    for (i = 0; i < n; i++) {\n        // If this is not leaf, then before printing key[i],\n        // traverse the subtree rooted with child children[i].\n        if (leaf == false)\n            children[i]->traverse();\n        std::cout << \" \" << keys[i];\n    }\n\n    // After printing the last key, traverse the subtree rooted\n    // with last child\n    if (leaf == false)\n        children[i]->traverse();\n}\n\n// Function to search key k in subtree rooted with this node\nBTreeNode* BTreeNode::search(int k) {\n    // Find the first key greater than or equal to k\n    int i = 0;\n    while (i < n && k > keys[i])\n        i++;\n\n    // If the key is found at the current node\n    if (keys[i] == k)\n        return this;\n\n    // If the key is not found here and this is a leaf node\n    if (leaf == true)\n        return nullptr;\n\n    // Go to the appropriate child\n    return children[i]->search(k);\n}\n\n// The main function that inserts a new key in this B-Tree\nvoid BTree::insert(int k) {\n    // If tree is empty\n    if (root == nullptr) {\n        // Allocate memory for root\n        root = new BTreeNode(t, true);\n        root->keys[0] = k;  // Insert key\n        root->n = 1;  // Update number of keys in root\n    } else {\n        // If root is full, then tree grows in height\n        if (root->n == 2 * t - 1) {\n            // Allocate memory for new root\n            BTreeNode* s = new BTreeNode(t, false);\n\n            // Make old root as child of new root\n            s->children[0] = root;\n\n            // Split the old root and move 1 key to the new root\n            s->splitChild(0, root);\n\n            // New root has two children now.  Decide which of the\n            // two children is going to have new key\n            int i = 0;\n            if (s->keys[0] < k)\n                i++;\n            s->children[i]->insertNonFull(k);\n\n            // Change root\n            root = s;\n        } else  // If root is not full, call insertNonFull for root\n            root->insertNonFull(k);\n    }\n}\n\n// A function to insert a new key in this B-Tree node\nvoid BTreeNode::insertNonFull(int k) {\n    // Initialize index as index of rightmost element\n    int i = n - 1;\n\n    // If this is a leaf node\n    if (leaf == true) {\n        // The following loop does two things\n        // a) Finds the location of new key to be inserted\n        // b) Moves all greater keys to one place ahead\n        while (i >= 0 && keys[i] > k) {\n            keys[i + 1] = keys[i];\n            i--;\n        }\n\n        // Insert the new key at found location\n        keys[i + 1] = k;\n        n = n + 1;\n    } else  // If this node is not leaf\n    {\n        // Find the child which is going to have the new key\n        while (i >= 0 && keys[i] > k)\n            i--;\n\n        // See if the found child is full\n        if (children[i + 1]->n == 2 * t - 1) {\n            // If the child is full, then split it\n            splitChild(i + 1, children[i + 1]);\n\n            // After split, the middle key of children[i] moves up and\n            // children[i] is splitted into two.  See which of the two\n            // is going to have the new key\n            if (keys[i + 1] < k)\n                i++;\n        }\n        children[i + 1]->insertNonFull(k);\n    }\n}\n\n// A function to split the child y of this node\n// Note that y must be full when this function is called\nvoid BTreeNode::splitChild(int i, BTreeNode* y) {\n    // Create a new node which is going to store t-1 keys\n    // of y\n    BTreeNode* z = new BTreeNode(y->t, y->leaf);\n    z->n = t - 1;\n\n    // Copy the last t-1 keys of y to z\n    for (int j = 0; j < t - 1; j++)\n        z->keys[j] = y->keys[j + t];\n\n    // Copy the last t children of y to z\n    if (y->leaf == false) {\n        for (int j = 0; j < t; j++)\n            z->children[j] = y->children[j + t];\n    }\n\n    // Reduce the number of keys in y\n    y->n = t - 1;\n\n    // Since this node is going to have a new child, create space of new\n    // child\n    for (int j = n; j >= i + 1; j--)\n        children[j + 1] = children[j];\n\n    // Link the new child to this node\n    children[i + 1] = z;\n\n    // A key of y will move to this node. Find the location of\n    // new key and move all greater keys one space ahead\n    for (int j = n - 1; j >= i; j--)\n        keys[j + 1] = keys[j];\n\n    // Copy the middle key of y to this node\n    keys[i] = y->keys[t - 1];\n\n    // Increment number of keys in this node\n    n = n + 1;\n}\n\n// Constructor for BTree class\nBTree::BTree(int t1) {\n    root = nullptr;\n    t = t1;\n}\n\n// Function to traverse the B-Tree\nvoid BTree::traverse() {\n    if (root != nullptr)\n        root->traverse();\n}\n\n// Function to search the B-Tree\nBTreeNode* BTree::search(int k) {\n    return (root == nullptr) ? nullptr : root->search(k);\n}\n\n// Function to remove the key from B-Tree\nvoid BTree::remove(int k) {\n    if (!root) {\n        std::cout << \"The tree is empty\\n\";\n        return;\n    }\n\n    root->deleteKey(k);\n\n    if (root->n == 0) {\n        BTreeNode* tmp = root;\n        if (root->leaf) {\n            root = nullptr;\n        } else {\n            root = root->children[0];\n        }\n\n        delete tmp;\n    }\n}\n\n// A function to delete a key from this node.\nvoid BTreeNode::deleteKey(int k) {\n    int idx = 0;\n    while (idx < n && keys[idx] < k) {\n        ++idx;\n    }\n\n    if (idx < n && keys[idx] == k) {\n        // The key to be removed is present in this node\n        if (leaf) {\n            removeFromLeaf(idx);\n        } else {\n            removeFromNonLeaf(idx);\n        }\n    } else {\n        // If the key is not present in this node, it is present in the\n        // subtree rooted with one of the children, we have to check if the child is full\n        if (leaf) {\n            std::cout << \"The key \" << k << \" is does not exist in the tree\\n\";\n            return;\n        }\n\n        // If the key is not present in this node, then the key will be present\n        // in the subtree rooted with the child children[idx]\n        bool flag = (idx == n);\n\n        // If the child[idx] has less than t keys, we fill that child\n        if (children[idx]->n < t) {\n            fill(idx);\n        }\n\n        // If the last child has been merged, then we must have\n        // merged it with the previous child and so we recurse on the (idx-1)th child. Else, we recurse on the (idx)th child.\n        if (flag && idx > n) {\n            children[idx - 1]->deleteKey(k);\n        } else {\n            children[idx]->deleteKey(k);\n        }\n    }\n}\n\n// A function to remove the key from a leaf node\nvoid BTreeNode::removeFromLeaf(int idx) {\n    // Move all the keys after the idx-th key one step back\n    for (int i = idx + 1; i < n; ++i) {\n        keys[i - 1] = keys[i];\n    }\n\n    // Reduce the count of keys\n    n--;\n}\n\n// A function to remove the key from a non-leaf node\nvoid BTreeNode::removeFromNonLeaf(int idx) {\n    int k = keys[idx];\n\n    // If the child that precedes k (children[idx]) has at least t keys, find the predecessor 'pred' of k in the subtree rooted at\n    // children[idx]. Replace k by pred. Recursively delete pred in children[idx]\n    if (children[idx]->n >= t) {\n        int pred = findPredecessor();\n        keys[idx] = pred;\n        children[idx]->deleteKey(pred);\n    } else if (children[idx + 1]->n >= t) {\n        // If the child children[idx+1] that succeeds k has at least t keys, find the successor 'succ' of k in the subtree rooted at\n        // children[idx+1]. Replace k by succ. Recursively delete succ in children[idx+1]\n        int succ = findSuccessor();\n        keys[idx] = succ;\n        children[idx + 1]->deleteKey(succ);\n    } else {\n        // If both children[idx] and children[idx+1] has less than t keys,merge k and all of children[idx+1] into children[idx]\n        // Now children[idx] contains 2t-1 keys\n        // Free children[idx+1] and recursively delete k from children[idx]\n        merge(idx);\n        children[idx]->deleteKey(k);\n    }\n}\n\n// A function to find predecessor of k (or the key at index idx in keys[])\nint BTreeNode::findPredecessor() {\n    // Keep moving to the rightmost node until we reach a leaf\n    BTreeNode* cur = children[0];\n    while (!cur->leaf) {\n        cur = cur->children[cur->n];\n    }\n\n    // Return the last key of the leaf\n    return cur->keys[cur->n - 1];\n}\n\n// A function to find successor of k (or the key at index idx in keys[])\nint BTreeNode::findSuccessor() {\n    // Keep moving the leftmost node starting from children[idx+1] until we reach a leaf\n    BTreeNode* cur = children[1];\n    while (!cur->leaf) {\n        cur = cur->children[0];\n    }\n\n    // Return the first key of the leaf\n    return cur->keys[0];\n}\n\n// A function to fill child children[idx] which has less than t-1 keys\nvoid BTreeNode::fill(int idx) {\n    // If the previous child(children[idx-1]) has more than t-1 keys, borrow a key from that child\n    if (idx != 0 && children[idx - 1]->n >= t) {\n        borrowFromPrev(idx);\n    } else if (idx != n && children[idx + 1]->n >= t) {\n        // If the next child(children[idx+1]) has more than t-1 keys, borrow a key from that child\n        borrowFromNext(idx);\n    } else {\n        // Merge children[idx] with its sibling\n        // If children[idx] is the last child, merge it with with its previous sibling\n        // Otherwise merge it with its next sibling\n        if (idx != n) {\n            merge(idx);\n        } else {\n            merge(idx - 1);\n        }\n    }\n}\n\n// A function to borrow a key from children[idx-1] and insert it into children[idx]\nvoid BTreeNode::borrowFromPrev(int idx) {\n    BTreeNode* child = children[idx];\n    BTreeNode* sibling = children[idx - 1];\n\n    // The last key from children[idx-1] goes to the parent and children[idx-1]'s rightmost child moves to children[idx]'s leftmost place\n    // Keys[idx-1] is inserted as the first key in children[idx].\n    // children[idx-1]'s last child is inserted as children[idx]'s first child\n\n    // Moving all key in children[idx] one step ahead\n    for (int i = child->n - 1; i >= 0; --i) {\n        child->keys[i + 1] = child->keys[i];\n    }\n\n    // If children[idx] is not a leaf, move all its child pointers one step ahead\n    if (!child->leaf) {\n        for (int i = child->n; i >= 0; --i) {\n            child->children[i + 1] = child->children[i];\n        }\n    }\n\n    // Setting children[idx]'s first key equal to keys[idx-1] from the current node\n    child->keys[0] = keys[idx - 1];\n\n    // Moving sibling's last child as children[idx]'s first child\n    if (!child->leaf) {\n        child->children[0] = sibling->children[sibling->n];\n    }\n\n    // Moving the key from the sibling to the parent\n    // This key will be inserted at keys[idx-1]\n    keys[idx - 1] = sibling->keys[sibling->n - 1];\n\n    // Increase children[idx] key count and decrease sibling's key count\n    child->n += 1;\n    sibling->n -= 1;\n}\n\n// A function to borrow a key from the children[idx+1] and insert it into children[idx]\nvoid BTreeNode::borrowFromNext(int idx) {\n    BTreeNode* child = children[idx];\n    BTreeNode* sibling = children[idx + 1];\n\n    // keys[idx] is inserted as the last key in children[idx]\n    child->keys[(child->n)] = keys[idx];\n\n    // Sibling's first child is inserted as children[idx]'s last child\n    if (!child->leaf) {\n        child->children[(child->n) + 1] = sibling->children[0];\n    }\n\n    //The first key from sibling is inserted in keys[idx]\n    keys[idx] = sibling->keys[0];\n\n    // Moving all keys in sibling one step behind\n    for (int i = 1; i < sibling->n; ++i) {\n        sibling->keys[i - 1] = sibling->keys[i];\n    }\n\n    // Moving the child pointers one step behind\n    if (!sibling->leaf) {\n        for (int i = 1; i <= sibling->n; ++i) {\n            sibling->children[i - 1] = sibling->children[i];\n        }\n    }\n\n    // Increasing and decreasing the key count of children[idx] and children[idx+1]\n    child->n += 1;\n    sibling->n -= 1;\n}\n\n// A function to merge children[idx] with children[idx+1]\n// children[idx+1] is freed after merging\nvoid BTreeNode::merge(int idx) {\n    BTreeNode* child = children[idx];\n    BTreeNode* sibling = children[idx + 1];\n\n    // Pulling a key from the current node and inserting it into (t-1)th\n    // position of children[idx]\n    child->keys[t - 1] = keys[idx];\n\n    // Copying all keys from children[idx+1] to children[idx]\n    for (int i = 0; i < sibling->n; ++i) {\n        child->keys[i + t] = sibling->keys[i];\n    }\n\n    // Copying the child pointers from children[idx+1] to children[idx]\n    if (!child->leaf) {\n        for (int i = 0; i <= sibling->n; ++i) {\n            child->children[i + t] = sibling->children[i];\n        }\n    }\n\n    // Moving all keys after idx in the current node one step before - to fill the gap created by moving keys[idx] to children[idx]\n    for (int i = idx + 1; i < n; ++i) {\n        keys[i - 1] = keys[i];\n    }\n\n    // Moving the child pointers after (idx+1) in the current node one step before\n    for (int i = idx + 2; i <= n; ++i) {\n        children[i - 1] = children[i];\n    }\n\n    // Updating the key count of child\n    child->n += sibling->n + 1;\n\n    // Reducing the key count of current node\n    n--;\n\n    // Freeing the memory occupied by sibling\n    delete sibling;\n}\n\nint main() {\n    BTree t(3); // A B-Tree with minium degree 3\n    t.insert(10);\n    t.insert(20);\n    t.insert(5);\n    t.insert(6);\n    t.insert(12);\n    t.insert(30);\n    t.insert(7);\n    t.insert(17);\n\n    std::cout << \"Traversal of the constucted tree is \";\n    t.traverse();\n    std::cout << std::endl;\n\n    int k = 6;\n    (t.search(k) != nullptr) ? std::cout << \"\\nPresent \" : std::cout << \"\\nNot Present \";\n\n    k = 15;\n    (t.search(k) != nullptr) ? std::cout << \"\\nPresent \" : std::cout << \"\\nNot Present \";\n\n    std::cout << \"\\nDeleting 12\\n\";\n    t.remove(12);\n    std::cout << \"Traversal of the tree after deleting 12\\n\";\n    t.traverse();\n    std::cout << std::endl;\n\n    std::cout << \"\\nDeleting 6\\n\";\n    t.remove(6);\n    std::cout << \"Traversal of the tree after deleting 6\\n\";\n    t.traverse();\n    std::cout << std::endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=Paj7Q6Nbg1c"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/n-ary-tree/"
      ]
    ]
  },
  "trie": {
    "title": "Trie (Prefix Tree)",
    "short": "A Trie, also known as a prefix tree, is a tree-like data structure primarily used to store a dynamic set of strings, offering efficient retrieval and insertion operations based on string prefixes. Each node in the Trie represents a character, and paths from the root to leaf nodes represent stored strings. It excels at tasks like autocomplete, spell checking, and IP routing, where prefix-based searching is crucial.",
    "time": "Average: Access - O(k), Search - O(k), Insertion - O(k), Deletion - O(k). Best: Access - O(k), Search - O(k), Insertion - O(k), Deletion - O(k). Worst: Access - O(k), Search - O(k), Insertion - O(k), Deletion - O(k). Where 'k' is the length of the key.",
    "space": "O(m*n), where 'm' is the number of words and 'n' is the average word length.",
    "code": "// C++ implementation of Trie data structure\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int ALPHABET_SIZE = 26; // Assuming lowercase English alphabet\n\n// Represents a node in the Trie\nstruct TrieNode {\n    TrieNode* children[ALPHABET_SIZE];\n    bool isEndOfWord;\n\n    TrieNode() {\n        isEndOfWord = false;\n        for (int i = 0; i < ALPHABET_SIZE; i++)\n            children[i] = nullptr;\n    }\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the Trie\n    void insert(string key) {\n        TrieNode* curr = root;\n        for (char c : key) {\n            int index = c - 'a'; // Calculate the index for the character\n            if (curr->children[index] == nullptr) {\n                curr->children[index] = new TrieNode();\n            }\n            curr = curr->children[index];\n        }\n        curr->isEndOfWord = true; // Mark the last node as the end of the word\n    }\n\n    // Searches for a word in the Trie\n    bool search(string key) {\n        TrieNode* curr = root;\n        for (char c : key) {\n            int index = c - 'a';\n            if (curr->children[index] == nullptr) {\n                return false; // Key not found\n            }\n            curr = curr->children[index];\n        }\n        return (curr != nullptr && curr->isEndOfWord); // Return true if the key exists and is the end of a word\n    }\n\n    // Checks if there is any word in the trie that starts with the given prefix\n    bool startsWith(string prefix) {\n        TrieNode* curr = root;\n        for (char c : prefix) {\n            int index = c - 'a';\n            if (curr->children[index] == nullptr) {\n                return false; // Prefix not found\n            }\n            curr = curr->children[index];\n        }\n        return true; // Prefix found (it may or may not be a complete word)\n    }\n};\n\nint main() {\n    Trie trie;\n\n    // Inserting words into the trie\n    trie.insert(\"apple\");\n    trie.insert(\"app\");\n    trie.insert(\"application\");\n\n    // Searching for words\n    cout << \"Search \\\"apple\\\": \" << trie.search(\"apple\") << endl;      // Output: 1 (true)\n    cout << \"Search \\\"app\\\": \" << trie.search(\"app\") << endl;          // Output: 1 (true)\n    cout << \"Search \\\"appl\\\": \" << trie.search(\"appl\") << endl;        // Output: 0 (false)\n    cout << \"Search \\\"application\\\": \" << trie.search(\"application\") << endl; // Output: 1 (true)\n    cout << \"Search \\\"banana\\\": \" << trie.search(\"banana\") << endl;     // Output: 0 (false)\n\n    // Checking for prefixes\n    cout << \"Starts with \\\"app\\\": \" << trie.startsWith(\"app\") << endl;      // Output: 1 (true)\n    cout << \"Starts with \\\"appl\\\": \" << trie.startsWith(\"appl\") << endl;     // Output: 1 (true)\n    cout << \"Starts with \\\"bana\\\": \" << trie.startsWith(\"bana\") << endl;    // Output: 0 (false)\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/trie-insert-and-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=AXjmTQ8LEoI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/trie/"
      ]
    ]
  },
  "segment-tree": {
    "title": "Segment Tree",
    "short": "A segment tree is a tree data structure used for efficiently answering range queries over an array. Each node in the tree represents an interval (segment) of the array. It allows for logarithmic time complexity for both query and update operations on ranges. Its primary use is to efficiently compute aggregations (sum, min, max, etc.) over specified ranges of an array.",
    "time": "Query: O(log n), Update: O(log n), Construction: O(n)",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Segment Tree implementation for Range Sum Queries\n\nclass SegmentTree {\nprivate:\n    vector<int> tree; // The segment tree array\n    vector<int> arr;  // The original array\n    int n;           // The size of the original array\n\n    // Build the segment tree recursively\n    void buildTree(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start]; // Leaf node stores the value from the original array\n        } else {\n            int mid = (start + end) / 2;\n            buildTree(2 * node + 1, start, mid); // Build left subtree\n            buildTree(2 * node + 2, mid + 1, end); // Build right subtree\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2]; // Internal node stores the sum of its children\n        }\n    }\n\n    // Perform a range sum query recursively\n    int queryRange(int node, int start, int end, int left, int right) {\n        if (right < start || end < left) {\n            return 0; // No overlap\n        } else if (left <= start && end <= right) {\n            return tree[node]; // Complete overlap\n        } else {\n            int mid = (start + end) / 2;\n            int p1 = queryRange(2 * node + 1, start, mid, left, right); // Query left subtree\n            int p2 = queryRange(2 * node + 2, mid + 1, end, left, right); // Query right subtree\n            return p1 + p2; // Sum of the results from the subtrees\n        }\n    }\n\n    // Update a value in the array and update the segment tree accordingly\n    void updateValue(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            arr[idx] = val; // Update the original array\n            tree[node] = val; // Update the leaf node\n        } else {\n            int mid = (start + end) / 2;\n            if (idx >= start && idx <= mid) {\n                updateValue(2 * node + 1, start, mid, idx, val); // Update left subtree\n            } else {\n                updateValue(2 * node + 2, mid + 1, end, idx, val); // Update right subtree\n            }\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2]; // Update the internal node\n        }\n    }\n\npublic:\n    // Constructor: Initializes the segment tree with the given array\n    SegmentTree(const vector<int>& input_arr) : arr(input_arr), n(input_arr.size()) {\n        // The size of the segment tree is approximately 4*n\n        tree.resize(4 * n); \n        buildTree(0, 0, n - 1); // Build the segment tree from the root node\n    }\n\n    // Public method to perform a range sum query\n    int query(int left, int right) {\n        return queryRange(0, 0, n - 1, left, right); // Start the query from the root node\n    }\n\n    // Public method to update a value in the array and the segment tree\n    void update(int idx, int val) {\n        updateValue(0, 0, n - 1, idx, val); // Start the update from the root node\n    }\n};\n\nint main() {\n    vector<int> arr = {1, 3, 5, 7, 9, 11};\n    SegmentTree st(arr);\n\n    // Example usage:\n    cout << \"Sum of range [1, 3]: \" << st.query(1, 3) << endl; // Expected: 3 + 5 + 7 = 15\n\n    st.update(1, 10); // Update arr[1] to 10\n\n    cout << \"Sum of range [1, 3] after update: \" << st.query(1, 3) << endl; // Expected: 10 + 5 + 7 = 22\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=ZBHKZF5w4YU"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/segment-tree/"
      ]
    ]
  },
  "fenwick-tree": {
    "title": "Fenwick Tree (Binary Indexed Tree)",
    "short": "A Fenwick Tree (also known as a Binary Indexed Tree or BIT) is a data structure that efficiently calculates prefix sums in an array. It supports both point updates (modifying an element in the array) and range queries (calculating the sum of elements from index 1 to a given index) in logarithmic time. It uses the binary representation of indices to store and retrieve partial sums, making it a compact and performant alternative to prefix sum arrays, especially when frequent updates are needed.",
    "time": "Access: N/A, Search: N/A, Insertion: O(log N), Deletion: N/A, Query (prefix sum): O(log N), Update (single element): O(log N)",
    "space": "O(N)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass FenwickTree {\nprivate:\n  vector<int> bit; // The Binary Indexed Tree array\n  int n;           // The size of the input array\n\npublic:\n  // Constructor: Initializes the Fenwick Tree with the given array size\n  FenwickTree(int n) : n(n), bit(n + 1, 0) {}\n\n  // Constructor: Builds the Fenwick Tree from the given input array\n  FenwickTree(const vector<int>& arr) : n(arr.size()), bit(n + 1, 0) {\n    for (int i = 0; i < n; ++i) {\n      update(i, arr[i]); // Build the tree by adding each element\n    }\n  }\n\n  // Function to update the value at a given index by adding 'val'\n  void update(int idx, int val) {\n    idx++; // Fenwick Tree indices are 1-based\n    while (idx <= n) {\n      bit[idx] += val;  // Add 'val' to the current node\n      idx += idx & -idx; // Move to the parent node (next index to update)\n    }\n  }\n\n  // Function to calculate the prefix sum up to the given index\n  int query(int idx) {\n    idx++; // Fenwick Tree indices are 1-based\n    int sum = 0;\n    while (idx > 0) {\n      sum += bit[idx];  // Add the value of the current node\n      idx -= idx & -idx; // Move to the child node (next index to query)\n    }\n    return sum;\n  }\n\n  // Function to calculate the sum of elements in the range [left, right]\n  int rangeSum(int left, int right) {\n      return query(right) - (left > 0 ? query(left - 1) : 0);\n  }\n};\n\nint main() {\n  vector<int> arr = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};\n  FenwickTree ft(arr); // Create a Fenwick Tree from the array\n\n  cout << \"Sum of elements from index 0 to 5: \" << ft.query(5) << endl; // Output: 12 (2+1+1+3+2+3)\n  cout << \"Sum of elements from index 2 to 7: \" << ft.rangeSum(2,7) << endl; // Output: 18\n  ft.update(3, 6); // Update the value at index 3 by adding 6 (arr[3] becomes 9)\n  cout << \"Sum of elements from index 0 to 5 after update: \" << ft.query(5) << endl; // Output: 18 (2+1+1+9+2+3)\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=WbafSgetDDk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-indexed-tree/"
      ]
    ]
  },
  "disjoint-set-union": {
    "title": "Disjoint Set Union (DSU)",
    "short": "Disjoint Set Union (DSU), also known as Union-Find, is a data structure that efficiently tracks a collection of disjoint (non-overlapping) sets. It supports two primary operations: finding which set a given element belongs to and merging two sets into a single set. DSU is commonly used in problems involving connectivity, graph algorithms like Kruskal's Minimum Spanning Tree, and cycle detection.",
    "time": "Average: O(α(n)) for both Find and Union (where α(n) is the inverse Ackermann function, which grows extremely slowly and is practically constant). Worst: O(log n) without path compression or union by rank, O(n) in pathological cases if only one of path compression or union by rank is used incorrectly.",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nclass DisjointSetUnion {\nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank; // Used for union by rank optimization\n    int num_sets;\n\npublic:\n    // Constructor: Initializes the DSU with n elements, each in its own set.\n    DisjointSetUnion(int n) : parent(n), rank(n, 0), num_sets(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i; // Each element is initially its own parent\n        }\n    }\n\n    // Find: Finds the representative (root) of the set that element x belongs to.\n    // Implements path compression for optimization.\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression: directly connect x to the root\n        }\n        return parent[x];\n    }\n\n    // Union: Merges the sets containing elements x and y.\n    // Implements union by rank for optimization.\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY; // Attach shorter tree to the taller tree\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX; // If ranks are equal, choose one as the parent\n                rank[rootX]++;         // Increment the rank of the new parent\n            }\n          num_sets--;\n        }\n    }\n\n    // Function to determine how many disjoint sets exist\n    int get_num_sets() { return num_sets; }\n};\n\nint main() {\n    // Example usage:\n    int n = 5; // Create a DSU with 5 elements\n    DisjointSetUnion dsu(n);\n\n    std::cout << \"Initial number of sets: \" << dsu.get_num_sets() << std::endl;\n\n    dsu.unite(0, 1); // Merge sets containing 0 and 1\n    std::cout << \"Number of sets after uniting 0 and 1: \" << dsu.get_num_sets() << std::endl;\n    dsu.unite(2, 3); // Merge sets containing 2 and 3\n    std::cout << \"Number of sets after uniting 2 and 3: \" << dsu.get_num_sets() << std::endl;\n    dsu.unite(1, 2); // Merge sets containing 1 and 2\n    std::cout << \"Number of sets after uniting 1 and 2: \" << dsu.get_num_sets() << std::endl;\n\n    // Check if 0 and 3 are in the same set\n    if (dsu.find(0) == dsu.find(3)) {\n        std::cout << \"0 and 3 are in the same set.\\n\";\n    } else {\n        std::cout << \"0 and 3 are in different sets.\\n\";\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/disjoint-set-data-structures/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=VHRhEuftcX4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/union-find/"
      ]
    ]
  },
  "self-balancing-bsts": {
    "title": "Self-Balancing Binary Search Trees (BSTs)",
    "short": "Self-balancing BSTs are a family of tree data structures that automatically adjust their structure after insertion or deletion operations to maintain a balanced state, preventing worst-case scenarios where the tree degenerates into a linked list. This balance ensures that search, insertion, and deletion operations have logarithmic time complexity. Common examples include AVL trees, Red-Black trees, and B-trees, each employing different balancing strategies.",
    "time": "Average: Access O(log n), Search O(log n), Insertion O(log n), Deletion O(log n); Best: Access O(1), Search O(1), Insertion O(1), Deletion O(1) (for specific cases); Worst: Theoretically still O(n) in extremely rare edge cases, but balancing minimizes this.",
    "space": "O(n)",
    "code": " #include <iostream>\n\n// A node in the AVL tree\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    int height; // Height of the node\n};\n\n// Function to get the height of a node\nint height(Node* N) {\n    if (N == NULL)\n        return 0;\n    return N->height;\n}\n\n// Function to get maximum of two integers\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\n// Function to create a new node with given key\nNode* newNode(int key) {\n    Node* node = new Node();\n    node->key = key;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 1; // New node is initially added at leaf\n    return node;\n}\n\n// Function to right rotate subtree rooted with y\nNode* rightRotate(Node* y) {\n    Node* x = y->left;\n    Node* T2 = x->right;\n\n    // Perform rotation\n    x->right = y;\n    y->left = T2;\n\n    // Update heights\n    y->height = max(height(y->left), height(y->right)) + 1;\n    x->height = max(height(x->left), height(x->right)) + 1;\n\n    // Return new root\n    return x;\n}\n\n// Function to left rotate subtree rooted with x\nNode* leftRotate(Node* x) {\n    Node* y = x->right;\n    Node* T2 = y->left;\n\n    // Perform rotation\n    y->left = x;\n    x->right = T2;\n\n    //  Update heights\n    x->height = max(height(x->left), height(x->right)) + 1;\n    y->height = max(height(y->left), height(y->right)) + 1;\n\n    // Return new root\n    return y;\n}\n\n// Get Balance factor of node N\nint getBalance(Node* N) {\n    if (N == NULL)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\n// Recursive function to insert a key in subtree rooted\n// with node and returns the new root of the subtree.\nNode* insert(Node* node, int key) {\n    /* 1.  Perform the normal BST insertion */\n    if (node == NULL)\n        return (newNode(key));\n\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else // Equal keys are not allowed in BST\n        return node;\n\n    /* 2. Update height of the ancestor node */\n    node->height = 1 + max(height(node->left), height(node->right));\n\n    /* 3. Get the balance factor of this ancestor\n          node to check whether this node became\n          unbalanced */\n    int balance = getBalance(node);\n\n    // If this node becomes unbalanced, then\n    // there are 4 cases\n\n    // Left Left Case\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    // Right Right Case\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    // Left Right Case\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    // Right Left Case\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    /* return the (unchanged) node pointer */\n    return node;\n}\n\n// Function to find the node with minimum key value\n// in a subtree rooted with node\nNode* minValueNode(Node* node) {\n    Node* current = node;\n\n    /* loop down to find the leftmost leaf */\n    while (current->left != NULL)\n        current = current->left;\n\n    return current;\n}\n\n// Recursive function to delete a node from subtree\n// with given key, it returns root of the modified subtree.\nNode* deleteNode(Node* root, int key) {\n    // STEP 1: PERFORM STANDARD BST DELETE\n    if (root == NULL)\n        return root;\n\n    // If the key to be deleted is smaller than the root's key,\n    // then it lies in left subtree\n    if (key < root->key)\n        root->left = deleteNode(root->left, key);\n\n    // If the key to be deleted is greater than the root's key,\n    // then it lies in right subtree\n    else if (key > root->key)\n        root->right = deleteNode(root->right, key);\n\n    // if key is same as root's key, then This is the node\n    // to be deleted\n    else {\n        // node with only one child or no child\n        if ((root->left == NULL) || (root->right == NULL)) {\n            Node* temp = root->left ? root->left : root->right;\n\n            // No child case\n            if (temp == NULL) {\n                temp = root;\n                root = NULL;\n            }\n            else // One child case\n                *root = *temp; // Copy the contents of\n                                   // the non-empty child\n\n            delete temp;\n        }\n        else {\n            // node with two children: Get the inorder\n            // successor (smallest in the right subtree)\n            Node* temp = minValueNode(root->right);\n\n            // Copy the inorder successor's data to this node\n            root->key = temp->key;\n\n            // Delete the inorder successor\n            root->right = deleteNode(root->right, temp->key);\n        }\n    }\n\n    // If the tree had only one node then return\n    if (root == NULL)\n        return root;\n\n    // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE\n    root->height = 1 + max(height(root->left), height(root->right));\n\n    // STEP 3: GET THE BALANCE FACTOR OF THIS NODE (to\n    // check whether this node became unbalanced)\n    int balance = getBalance(root);\n\n    // If this node becomes unbalanced, then there are 4 cases\n\n    // Left Left Case\n    if (balance > 1 && getBalance(root->left) >= 0)\n        return rightRotate(root);\n\n    // Left Right Case\n    if (balance > 1 && getBalance(root->left) < 0) {\n        root->left = leftRotate(root->left);\n        return rightRotate(root);\n    }\n\n    // Right Right Case\n    if (balance < -1 && getBalance(root->right) <= 0)\n        return leftRotate(root);\n\n    // Right Left Case\n    if (balance < -1 && getBalance(root->right) > 0) {\n        root->right = rightRotate(root->right);\n        return leftRotate(root);\n    }\n\n    return root;\n}\n\n// A utility function to print preorder traversal\n// of the tree.\nvoid preOrder(Node* root) {\n    if (root != NULL) {\n        std::cout << root->key << \" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n\n\nint main() {\n    Node* root = NULL;\n\n    /* Constructing tree given in the above figure */\n    root = insert(root, 10);\n    root = insert(root, 20);\n    root = insert(root, 30);\n    root = insert(root, 40);\n    root = insert(root, 50);\n    root = insert(root, 25);\n\n    /* The constructed AVL Tree would be\n              30\n             /  \\\n            20   40\n           /  \\     \\\n          10  25    50\n    */\n\n    std::cout << \"Preorder traversal of the constructed AVL tree is \\n\";\n    preOrder(root);\n    std::cout << std::endl;\n\n    root = deleteNode(root, 20);\n\n    std::cout << \"Preorder traversal after deleting node 20 \\n\";\n    preOrder(root);\n    std::cout << std::endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/self-balancing-binary-search-tree/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=RBg7G-G9tRQ"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search-tree/"
      ]
    ]
  },
  "heap-and-priority-queue": {
    "title": "Heap and Priority Queue",
    "short": "A heap is a specialized tree-based data structure that satisfies the heap property: in a min-heap, the value of each node is less than or equal to the value of its children; in a max-heap, it's greater than or equal.  A priority queue is an abstract data type that provides access to the highest (or lowest) priority element. Heaps are commonly used to implement priority queues due to their efficient time complexities for insertion and extraction.",
    "time": {
      "Access": "O(1) (Min/Max element), O(N) (Arbitrary element)",
      "Search": "O(N)",
      "Insertion": "O(log N)",
      "Deletion": "O(log N)",
      "Get Min/Max (depending on heap type)": "O(1)"
    },
    "space": "O(N)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Max Heap implementation\nclass MaxHeap {\nprivate:\n    std::vector<int> heap;\n\n    // Heapify a subtree rooted with node i which is\n    // an index in heap[]. n is size of heap\n    void heapify(int i) {\n        int n = heap.size();\n        int largest = i; // Initialize largest as root\n        int l = 2 * i + 1; // left = 2*i + 1\n        int r = 2 * i + 2; // right = 2*i + 2\n\n        // If left child is larger than root\n        if (l < n && heap[l] > heap[largest])\n            largest = l;\n\n        // If right child is larger than largest so far\n        if (r < n && heap[r] > heap[largest])\n            largest = r;\n\n        // If largest is not root\n        if (largest != i) {\n            std::swap(heap[i], heap[largest]);\n\n            // Recursively heapify the affected sub-tree\n            heapify(largest);\n        }\n    }\n\npublic:\n    // Insert a new key\n    void insert(int key) {\n        heap.push_back(key);\n        int i = heap.size() - 1;\n\n        // Fix the max heap property if it is violated\n        while (i != 0 && heap[(i - 1) / 2] < heap[i]) {\n            std::swap(heap[i], heap[(i - 1) / 2]);\n            i = (i - 1) / 2;\n        }\n    }\n\n    // Extracts the maximum value\n    int extractMax() {\n        if (heap.empty()) {\n            return -1; // Or throw an exception\n        }\n        if (heap.size() == 1) {\n            int root = heap[0];\n            heap.pop_back();\n            return root;\n        }\n\n        // Store the maximum value, and remove it from heap\n        int root = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n        heapify(0);\n\n        return root;\n    }\n\n    // Returns the maximum value without removing it\n    int getMax() const {\n        if (!heap.empty()) {\n            return heap[0];\n        } else {\n            return -1; // Or throw an exception\n        }\n    }\n\n    // Checks if the heap is empty\n    bool isEmpty() const {\n        return heap.empty();\n    }\n\n    // Prints the heap\n    void printHeap() const {\n        for (int value : heap) {\n            std::cout << value << \" \";\n        }\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    MaxHeap maxHeap;\n    maxHeap.insert(5);\n    maxHeap.insert(3);\n    maxHeap.insert(17);\n    maxHeap.insert(10);\n    maxHeap.insert(84);\n    maxHeap.insert(19);\n    maxHeap.insert(6);\n    maxHeap.insert(22);\n    maxHeap.insert(9);\n\n    std::cout << \"Max Heap elements: \";\n    maxHeap.printHeap();\n\n    std::cout << \"Max element: \" << maxHeap.getMax() << std::endl;\n\n    std::cout << \"Extract Max: \" << maxHeap.extractMax() << std::endl;\n    std::cout << \"Heap after extraction: \";\n    maxHeap.printHeap();\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/heap-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=t0cQ6tVNRBA"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/heap-priority-queue/"
      ]
    ]
  },
  "suffix-array-and-suffix-tree": {
    "title": "Suffix Array and Suffix Tree",
    "short": "Suffix arrays and suffix trees are data structures used to efficiently represent and query all suffixes of a string. A suffix array is a sorted array of all suffixes of a string, while a suffix tree is a tree-like data structure where each path from the root to a leaf represents a suffix. They are commonly used in string matching, pattern searching, and various other text processing applications.",
    "time": {
      "Suffix Array Construction (using O(n log n) algorithm)": "O(n log n)",
      "Suffix Array Search (using binary search)": "O(m log n), where m is the length of the pattern and n is the length of the text.",
      "Suffix Tree Construction": "O(n)",
      "Suffix Tree Search": "O(m), where m is the length of the pattern"
    },
    "space": {
      "Suffix Array": "O(n)",
      "Suffix Tree": "O(n)"
    },
    "code": " #include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent a suffix and its starting index\nstruct Suffix {\n    int index;\n    string suffix;\n};\n\n// Custom comparison function to sort suffixes lexicographically\nbool compareSuffixes(const Suffix& a, const Suffix& b) {\n    return a.suffix < b.suffix;\n}\n\n// Function to build the suffix array\nvector<int> buildSuffixArray(const string& text) {\n    int n = text.length();\n    vector<Suffix> suffixes(n);\n\n    // Populate the suffixes vector\n    for (int i = 0; i < n; ++i) {\n        suffixes[i].index = i;\n        suffixes[i].suffix = text.substr(i);\n    }\n\n    // Sort the suffixes using the custom comparison function\n    sort(suffixes.begin(), suffixes.end(), compareSuffixes);\n\n    // Create the suffix array by extracting the indices\n    vector<int> suffixArray(n);\n    for (int i = 0; i < n; ++i) {\n        suffixArray[i] = suffixes[i].index;\n    }\n\n    return suffixArray;\n}\n\n// Function to search for a pattern in the text using the suffix array\nint searchPattern(const string& text, const vector<int>& suffixArray, const string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    int low = 0, high = n - 1;\n\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int suffixIndex = suffixArray[mid];\n        string suffix = text.substr(suffixIndex);\n\n        // Compare the pattern with the current suffix\n        int result = suffix.compare(0, m, pattern);\n\n        if (result == 0) {\n            // Pattern found at the current suffix index\n            return suffixIndex;\n        } else if (result < 0) {\n            // Pattern is lexicographically greater, search in the right half\n            low = mid + 1;\n        } else {\n            // Pattern is lexicographically smaller, search in the left half\n            high = mid - 1;\n        }\n    }\n\n    // Pattern not found\n    return -1;\n}\n\nint main() {\n    string text = \"banana\";\n    string pattern = \"ana\";\n\n    // Build the suffix array\n    vector<int> suffixArray = buildSuffixArray(text);\n\n    cout << \"Suffix Array: \";\n    for (int index : suffixArray) {\n        cout << index << \" \";\n    }\n    cout << endl;\n\n    // Search for the pattern in the text\n    int index = searchPattern(text, suffixArray, pattern);\n\n    if (index != -1) {\n        cout << \"Pattern found at index: \" << index << endl;\n    } else {\n        cout << \"Pattern not found.\" << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/suffix-array-set-1introduction/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=HKPrVmEwiAk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/suffix-array/"
      ]
    ]
  },
  "b-trees": {
    "title": "B-Trees",
    "short": "A B-Tree is a self-balancing tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time. It's particularly well-suited for disk-oriented database systems or file systems because it minimizes the number of disk accesses. Unlike binary search trees, B-Trees have nodes with multiple children, enabling them to reduce the height of the tree and thus the number of I/O operations needed to locate elements.",
    "time": {
      "Access": "O(log n)",
      "Search": "O(log n)",
      "Insertion": "O(log n)",
      "Deletion": "O(log n)"
    },
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// A B-Tree node\nclass BTreeNode {\npublic:\n    std::vector<int> keys;   // Vector to store keys\n    std::vector<BTreeNode*> children; // Vector to store child pointers\n    int t;                 // Minimum degree (defines the range for number of keys)\n    bool leaf;              // True when node is leaf. Otherwise false\n\n    BTreeNode(int t, bool leaf);\n\n    // Function to find the first key greater than or equal to k\n    int findKey(int k);\n\n    // Function to remove key k from the sub-tree rooted with this node\n    void remove(int k);\n\n    // A function to remove the key present in this node\n    void removeFromLeaf(int idx);\n\n    // A function to remove the key present in this node\n    // that is NOT a leaf node\n    void removeFromNonLeaf(int idx);\n\n    // Function to get predecessor of keys[idx]\n    int getPred(int idx);\n\n    // Function to get successor of keys[idx]\n    int getSucc(int idx);\n\n    // Function to fill child c[idx] if it has less than t keys\n    void fill(int idx);\n\n    // Function to borrow a key from c[idx-1] and place it in c[idx]\n    void borrowFromPrev(int idx);\n\n    // Function to borrow a key from c[idx+1] and place it in c[idx]\n    void borrowFromNext(int idx);\n\n    // Function to merge c[idx] with c[idx+1]\n    void merge(int idx);\n\n    // Function to insert a new key in this node\n    void insertNonFull(int k);\n\n    // Function to split the child of this node\n    void splitChild(int i, BTreeNode *y);\n\n    void traverse();\n\n    ~BTreeNode();\n};\n\n// A B-Tree\nclass BTree {\npublic:\n    BTreeNode *root; // Pointer to root node\n    int t;      // Minimum degree\n\n    BTree(int t);\n\n    // function to traverse the tree\n    void traverse() { if (root != nullptr) root->traverse(); }\n\n    // Function to search key k in tree\n    BTreeNode* search(int k);\n\n    // Function to insert key k in tree\n    void insert(int k);\n\n    void remove(int k);\n\n    ~BTree();\n};\n\n// Constructor for BTreeNode class\nBTreeNode::BTreeNode(int t1, bool leaf1) {\n    t = t1;\n    leaf = leaf1;\n}\n\n// Function to find the first key greater than or equal to k\nint BTreeNode::findKey(int k) {\n    int idx = 0;\n    while (idx < keys.size() && keys[idx] < k)\n        ++idx;\n    return idx;\n}\n\n// Function to remove key k from the sub-tree rooted with this node\nvoid BTreeNode::remove(int k) {\n    int idx = findKey(k);\n\n    // The key to be removed is present in this node\n    if (idx < keys.size() && keys[idx] == k {\n        if (leaf)\n            removeFromLeaf(idx);\n        else\n            removeFromNonLeaf(idx);\n    } else {\n        // If this node is a leaf node, then the key is not present in the tree\n        if (leaf) {\n            std::cout << \"The key \" << k << \" is does not exist in the tree\\n\";\n            return;\n        }\n\n        // The key to be removed is present in the sub-tree rooted with this node\n        bool flag = (idx == keys.size());\n\n        // If the child c[idx] has less than t keys, we fill it before\n        // recursively calling remove() on c[idx]\n        if (children[idx]->keys.size() < t)\n            fill(idx);\n\n        // If the key lies in c[idx] after filling, then recursive remove\n        // Function is called on it\n        if (flag && idx > keys.size())\n            children[idx - 1]->remove(k);\n        else\n            children[idx]->remove(k);\n    }\n}\n\n// Function to remove the key present in this node\n// that is a leaf node\nvoid BTreeNode::removeFromLeaf(int idx) {\n    // Move all the keys after the idx-th key one step back\n    for (int i = idx + 1; i < keys.size(); ++i)\n        keys[i - 1] = keys[i];\n\n    // Reduce the number of keys\n    keys.pop_back();\n}\n\n// Function to remove the key present in this node\n// that is NOT a leaf node\nvoid BTreeNode::removeFromNonLeaf(int idx) {\n    int k = keys[idx];\n\n    // If the child c[idx] has more than t-1 keys, find the predecessor\n    // 'pred' of k in the subtree rooted at c[idx]. Replace k by pred.\n    // Recursively delete pred in c[idx]\n    if (children[idx]->keys.size() >= t) {\n        int pred = getPred(idx);\n        keys[idx] = pred;\n        children[idx]->remove(pred);\n    }\n\n    // If the child c[idx+1] has more than t-1 keys, find the successor\n    // 'succ' of k in the subtree rooted at c[idx+1]\n    // Replace k by succ\n    // Recursively delete succ in c[idx+1]\n    else if (children[idx + 1]->keys.size() >= t) {\n        int succ = getSucc(idx);\n        keys[idx] = succ;\n        children[idx + 1]->remove(succ);\n    }\n\n    // If both c[idx] and c[idx+1] has less than t-1 keys,merge k and all of c[idx+1]\n    // into c[idx]\n    // Now c[idx] contains 2t-1 keys\n    // Free c[idx+1] and recursively delete k from c[idx]\n    else {\n        merge(idx);\n        children[idx]->remove(k);\n    }\n}\n\n// Function to get predecessor of keys[idx]\nint BTreeNode::getPred(int idx) {\n    // Keep moving to the right most node until we reach a leaf\n    BTreeNode *cur = children[idx];\n    while (!cur->leaf)\n        cur = cur->children[cur->keys.size()];\n\n    // Return the last key of the leaf\n    return cur->keys[cur->keys.size() - 1];\n}\n\nint BTreeNode::getSucc(int idx) {\n    // Keep moving the left most node starting from c[idx+1] until we reach a leaf\n    BTreeNode *cur = children[idx + 1];\n    while (!cur->leaf)\n        cur = cur->children[0];\n\n    // Return the first key of the leaf\n    return cur->keys[0];\n}\n\n// Function to fill child c[idx] if it has less than t keys\nvoid BTreeNode::fill(int idx) {\n    // If the previous child(c[idx-1]) has more than t-1 keys, borrow a key\n    // from that child\n    if (idx != 0 && children[idx - 1]->keys.size() >= t)\n        borrowFromPrev(idx);\n\n    // If the next child(c[idx+1]) has more than t-1 keys, borrow a key\n    // from that child\n    else if (idx != keys.size() && children[idx + 1]->keys.size() >= t)\n        borrowFromNext(idx);\n\n    // Merge c[idx] with its sibling\n    // If c[idx] is the last child, merge it with with its previous sibling\n    // Otherwise merge it with its next sibling\n    else {\n        if (idx != keys.size())\n            merge(idx);\n        else\n            merge(idx - 1);\n    }\n}\n\n// Function to borrow a key from c[idx-1] and place it in c[idx]\nvoid BTreeNode::borrowFromPrev(int idx) {\n    BTreeNode *child = children[idx];\n    BTreeNode *sibling = children[idx - 1];\n\n    // The last key from C[idx-1] goes to the parent and key[idx-1]\n    // from parent is inserted as the first key in C[idx]. Thus, the sibling loses\n    // one key and child gains one key\n\n    // Moving all key in c[idx] one step ahead\n    child->keys.insert(child->keys.begin(), keys[idx - 1]);\n\n    // If c[idx-1] is not a leaf, move last child from C[idx-1] to C[idx]\n    if (!child->leaf)\n        child->children.insert(child->children.begin(), sibling->children[sibling->keys.size()]);\n\n    // Moving the key from the sibling to the parent\n    // This reduces the number of keys in the sibling\n    keys[idx - 1] = sibling->keys[sibling->keys.size() - 1];\n\n    // Increase c[idx]'s key count\n    // Reduce sibling's key count\n    sibling->keys.pop_back();\n    if(!sibling->leaf) sibling->children.pop_back();\n}\n\n// Function to borrow a key from c[idx+1] and place it in c[idx]\nvoid BTreeNode::borrowFromNext(int idx) {\n    BTreeNode *child = children[idx];\n    BTreeNode *sibling = children[idx + 1];\n\n    // keys[idx] is inserted as the last key in C[idx]\n    child->keys.push_back(keys[idx]);\n\n    // If C[idx+1] is not a leaf, move the first child from C[idx+1] to C[idx]\n    if (!child->leaf)\n        child->children.push_back(sibling->children[0]);\n\n    // Moving the key from sibling to parent\n    // This reduces the number of keys in the sibling\n    keys[idx] = sibling->keys[0];\n\n    // Increase c[idx]'s key count\n    // Reduce sibling's key count\n    sibling->keys.erase(sibling->keys.begin());\n    if(!sibling->leaf) sibling->children.erase(sibling->children.begin());\n}\n\n// Function to merge c[idx] with c[idx+1]\nvoid BTreeNode::merge(int idx) {\n    BTreeNode *child = children[idx];\n    BTreeNode *sibling = children[idx + 1];\n\n    // Pulling a key from the current node and inserting it into (t-1) position of c[idx]\n    child->keys.push_back(keys[idx]);\n\n    // Copying all keys from c[idx+1] to c[idx]\n    for (int i = 0; i < sibling->keys.size(); ++i)\n        child->keys.push_back(sibling->keys[i]);\n\n    // Copying the child pointers from c[idx+1] to c[idx]\n    if (!child->leaf) {\n        for (int i = 0; i < sibling->children.size(); ++i)\n            child->children.push_back(sibling->children[i]);\n    }\n\n    // Moving all keys after idx in the current node one step before - done using erase\n    keys.erase(keys.begin() + idx);\n    children.erase(children.begin() + idx + 1);\n\n    // Freeing the memory occupied by sibling\n    delete sibling;\n}\n\n// Function to insert a new key in this node\nvoid BTreeNode::insertNonFull(int k) {\n    // Initialize index as index of rightmost element\n    int i = keys.size() - 1;\n\n    // If this is a leaf node\n    if (leaf) {\n        // The following loop does two things\n        // a) Finds the location of new key to be inserted\n        // b) Moves all greater keys to one place ahead\n        while (i >= 0 && keys[i] > k) {\n            i--;\n        }\n\n        keys.insert(keys.begin() + i + 1, k);\n    } else {\n        // Find the child which is going to have the new key\n        while (i >= 0 && keys[i] > k)\n            i--;\n\n        // See if the found child is full\n        if (children[i + 1]->keys.size() == 2 * t - 1) {\n            // If the child is full, then split it\n            splitChild(i + 1, children[i + 1]);\n\n            // After split, the middle key of C[i] goes up and C[i] is splitted into two.\n            // See which of the two is going to have the new key\n            if (keys[i + 1] < k)\n                i++;\n        }\n        children[i + 1]->insertNonFull(k);\n    }\n}\n\n// Function to split the child of this node\nvoid BTreeNode::splitChild(int i, BTreeNode *y) {\n    // Create a new node which is going to store half of the keys of y\n    BTreeNode *z = new BTreeNode(y->t, y->leaf);\n    z->keys.resize(t - 1);\n\n    // Copy the last t-1 keys of y to z\n    for (int j = 0; j < t - 1; j++)\n        z->keys[j] = y->keys[j + t];\n\n    // Copy the last t children of y to z\n    if (!y->leaf) {\n        z->children.resize(t);\n        for (int j = 0; j < t; j++)\n            z->children[j] = y->children[j + t];\n            y->children.resize(t); //remove the other half of children to ensure integrity.\n    }\n\n    // Reduce the number of keys in y\n    y->keys.resize(t - 1);\n\n\n    // Since this node is going to have a new child, create space of new child\n    children.resize(keys.size() + 1);\n    for(int j = keys.size(); j > i + 1; --j) children[j] = children[j-1];\n\n    children[i + 1] = z;\n\n    // A key of y will move to this node. Find the location of\n    // new key and move all greater keys one space ahead\n    keys.resize(keys.size() + 1);\n    for(int j = keys.size() - 1; j > i; --j) keys[j] = keys[j-1];\n\n    // Copy the middle key of y to this node\n    keys[i] = y->keys[t - 1];\n\n    // Finally, insert the new key into this node\n    y->keys.pop_back(); // remove the last key after moving to parent\n}\n\n// Function to traverse all nodes in a subtree rooted with this node\nvoid BTreeNode::traverse() {\n    // There are keys.size() keys and keys.size() + 1 children, traverse through keys.size() keys\n    // and first keys.size() children\n    int i;\n    for (i = 0; i < keys.size(); i++) {\n        // If this is not leaf, then before printing key[i]\n        // traverse the subtree rooted with child children[i].\n        if (!leaf)\n            children[i]->traverse();\n        std::cout << \" \" << keys[i];\n    }\n\n    // Print the subtree rooted with last child\n    if (!leaf)\n        children[i]->traverse();\n}\n\nBTreeNode::~BTreeNode() {\n    if (!leaf) {\n        for (BTreeNode* child : children) {\n            delete child;\n        }\n    }\n}\n\n// Constructor for BTree class\nBTree::BTree(int t1) {\n    root = nullptr;\n    t = t1;\n}\n\n// Function to search key k in tree\nBTreeNode* BTree::search(int k) {\n    // Call the search function for root\n    if(root) return search(root, k);\n    else return nullptr;\n}\n\nBTreeNode* BTree::search(BTreeNode* node, int k) {\n    int i = 0;\n    while (i < node->keys.size() && k > node->keys[i])\n        i++;\n\n    if (i < node->keys.size() && node->keys[i] == k)\n        return node;\n\n    if (node->leaf)\n        return nullptr;\n\n    return search(node->children[i], k);\n}\n\n// Function to insert key k in tree\nvoid BTree::insert(int k) {\n    // If tree is empty\n    if (root == nullptr) {\n        // Allocate memory for root\n        root = new BTreeNode(t, true);\n        root->keys.push_back(k);  // Insert key\n    } else {\n        // If root is full, then tree grows in height\n        if (root->keys.size() == 2 * t - 1) {\n            // Allocate memory for new root\n            BTreeNode *s = new BTreeNode(t, false);\n\n            // Make old root as child of new root\n            s->children.push_back(root);\n\n            // Split the old root and move 1 key to the new root\n            s->splitChild(0, root);\n\n            // New root has two children now.  Decide which of the\n            // two children is going to have new key\n            int i = 0;\n            if (s->keys[0] < k)\n                i++;\n            s->children[i]->insertNonFull(k);\n\n            // Change root\n            root = s;\n        } else {\n            // If root is not full, call insertNonFull for root\n            root->insertNonFull(k);\n        }\n    }\n}\n\nvoid BTree::remove(int k) {\n    if (!root) {\n        std::cout << \"The tree is empty\\n\";\n        return;\n    }\n\n    root->remove(k);\n\n    if (root->keys.empty()) {\n        BTreeNode *tmp = root;\n        if (!root->leaf)\n            root = root->children[0];\n        else\n            root = nullptr;\n\n        delete tmp;\n    }\n}\n\nBTree::~BTree() {\n    delete root;\n}\n\n// Driver program to test above functions\nint main() {\n    BTree t(3); // A B-Tree with minium degree 3 (2 < = t < = 3)\n    t.insert(10);\n    t.insert(20);\n    t.insert(5);\n    t.insert(6);\n    t.insert(12);\n    t.insert(30);\n    t.insert(7);\n    t.insert(17);\n\n    std::cout << \"Traversal of the constucted tree is \";\n    t.traverse();\n    std::cout << std::endl;\n\n    int k = 6;\n    (t.search(k) != nullptr) ? std::cout << std::endl << k << \" is present\"\n                            : std::cout << std::endl << k << \" is not present\";\n\n    k = 15;\n    (t.search(k) != nullptr) ? std::cout << std::endl << k << \" is present\"\n                            : std::cout << std::endl << k << \" is not present\";\n\n    t.remove(6);\n    std::cout << \"Traversal of the tree after removing\" << k << std::endl;\n    t.traverse();\n    std::cout << std::endl;\n\n    t.remove(12);\n    std::cout << \"Traversal of the tree after removing\" << k << std::endl;\n    t.traverse();\n    std::cout << std::endl;\n    t.remove(20);\n    std::cout << \"Traversal of the tree after removing\" << k << std::endl;\n    t.traverse();\n    std::cout << std::endl;\n\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/b-tree/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=mK6iJvB8vHE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/btree/"
      ]
    ]
  },
  "bloom-filter": {
    "title": "Bloom Filter",
    "short": "A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. It allows for false positives (an element might be identified as belonging to the set even if it doesn't), but false negatives are impossible. Bloom filters are commonly used in applications where the cost of a false positive is acceptable compared to the benefit of space savings.",
    "time": "Insertion: O(k), Search: O(k), Deletion: Not Supported (probabilistic deletion can be implemented, but it's complex and not generally recommended)",
    "space": "O(m) where m is the size of the bit array",
    "code": " #include <iostream>\n #include <vector>\n #include <string>\n #include <functional>\n #include <random>\n \n class BloomFilter {\n private:\n  std::vector<bool> bitArray; // The bit array\n  size_t arraySize;        // Size of the bit array\n  size_t numHashFunctions; // Number of hash functions\n  std::vector<std::function<size_t(const std::string&)>> hashFunctions; // Vector to store hash functions\n\n public:\n  // Constructor\n  BloomFilter(size_t size, size_t numHashes) : arraySize(size), numHashFunctions(numHashes), bitArray(size, false) {\n  // Initialize hash functions (using different seeds for variety)\n  std::random_device rd;\n  std::mt19937 gen(rd());\n  std::uniform_int_distribution<> distrib(1, size -1); // Ensure seed is within reasonable bounds\n \n  for (size_t i = 0; i < numHashes; ++i) {\n  size_t seed = distrib(gen); // Generate a different seed for each hash function.\n  hashFunctions.push_back([seed, size](const std::string& str) {\n  size_t hash = std::hash<std::string>{}(str + std::to_string(seed));\n  return hash % size; // Ensure hash is within array bounds\n  });\n  }\n  }\n \n  // Insert an element into the Bloom Filter\n  void insert(const std::string& element) {\n  for (const auto& hashFunc : hashFunctions) {\n  size_t index = hashFunc(element);\n  bitArray[index] = true;\n  }\n  }\n \n  // Check if an element is present in the Bloom Filter\n  bool contains(const std::string& element) {\n  for (const auto& hashFunc : hashFunctions) {\n  size_t index = hashFunc(element);\n  if (!bitArray[index]) {\n  return false; // Definitely not present\n  }\n  }\n  return true; // Might be present (false positive possible)\n  }\n\n  //Optional: Getters for array size and number of hash functions for testing/debugging\n  size_t getArraySize() const { return arraySize; }\n  size_t getNumHashFunctions() const { return numHashFunctions; }\n };\n \n int main() {\n  // Example usage\n  BloomFilter bf(1000, 3); // Create a Bloom Filter with size 1000 and 3 hash functions\n \n  // Insert some elements\n  bf.insert(\"apple\");\n  bf.insert(\"banana\");\n  bf.insert(\"cherry\");\n \n  // Check for elements\n  std::cout << \"'apple' is present: \" << std::boolalpha << bf.contains(\"apple\") << std::endl;   // Output: true (likely)\n  std::cout << \"'grape' is present: \" << std::boolalpha << bf.contains(\"grape\") << std::endl;   // Output: true or false (false positive possible)\n  std::cout << \"'banana' is present: \" << std::boolalpha << bf.contains(\"banana\") << std::endl;  // Output: true (likely)\n  std::cout << \"'cherry' is present: \" << std::boolalpha << bf.contains(\"cherry\") << std::endl;  // Output: true (likely)\n  std::cout << \"'date' is present: \" << std::boolalpha << bf.contains(\"date\") << std::endl;     // Output: true or false (false positive possible)\n \n  return 0;\n }\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=qV_B5h3lGjE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/discuss/interview-question/436472/Facebook-or-Bloomberg-or-Bloom-Filter-Implementation"
      ]
    ]
  },
  "greedy-algorithms": {
    "title": "Greedy Algorithms",
    "short": "Greedy algorithms are a simple, intuitive approach to optimization problems. They make the locally optimal choice at each step, hoping that these choices will lead to a globally optimal solution. Greedy algorithms are often used when an optimal solution is not required or when finding an optimal solution is computationally expensive. They are particularly useful for problems with optimal substructure, where an optimal solution can be constructed from optimal solutions to subproblems, but are not guaranteed to always provide the best result.",
    "time": "Varies greatly depending on the specific problem and sorting requirements. Common scenarios: O(n log n) if sorting is involved; O(n) if iterating through a pre-sorted data set.",
    "space": "Varies, but often O(1) or O(n) depending on auxillary data structures needed.",
    "code": "// A C++ implementation of a greedy algorithm for the Fractional Knapsack problem\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an item in the knapsack\nstruct Item {\n    int value;\n    int weight;\n    double ratio; // value/weight\n};\n\n// Function to calculate the fractional knapsack value using a greedy approach\ndouble fractionalKnapsack(int capacity, vector<Item>& items) {\n    // Sort items based on value/weight ratio in descending order\n    sort(items.begin(), items.end(), [](const Item& a, const Item& b) {\n        return a.ratio > b.ratio;\n    });\n\n    double totalValue = 0.0;\n    int currentWeight = 0;\n\n    // Iterate through the sorted items\n    for (const auto& item : items) {\n        // If the entire item can be taken\n        if (currentWeight + item.weight <= capacity) {\n            currentWeight += item.weight;\n            totalValue += item.value;\n        } else {\n            // Take a fraction of the item to fill the remaining capacity\n            int remainingCapacity = capacity - currentWeight;\n            totalValue += item.ratio * remainingCapacity;\n            break; // Knapsack is full\n        }\n    }\n\n    return totalValue;\n}\n\nint main() {\n    int capacity = 50; // Knapsack capacity\n    vector<Item> items = {\n        {60, 10, 6.0}, // value, weight, ratio\n        {100, 20, 5.0},\n        {120, 30, 4.0}\n    };\n\n    double maxValue = fractionalKnapsack(capacity, items);\n\n    cout << \"Maximum value in knapsack = \" << maxValue << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/greedy-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=ARvKFCfj-nI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/greedy/"
      ]
    ]
  },
  "activity": {
    "title": "Activity Selection Problem",
    "short": "The Activity Selection Problem is a classic greedy algorithm problem that aims to find the maximum number of non-overlapping activities that can be performed by a single person or resource in a given time period. Each activity has a start time and finish time. The activities are selected such that no two activities overlap, and the objective is to maximize the number of chosen activities. The greedy approach involves sorting the activities by their finish times and then selecting activities that finish earliest first, ensuring no overlap with previously selected activities.",
    "time": "Sorting: O(n log n), Selection: O(n)",
    "space": "O(1)",
    "code": "// C++ implementation of Activity Selection Problem\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an activity\nstruct Activity {\n    int start, finish;\n};\n\n// Function to sort activities based on finish time\nbool compareActivities(Activity a, Activity b) {\n    return (a.finish < b.finish);\n}\n\n// Function to find the maximum set of non-overlapping activities\nvector<Activity> activitySelection(vector<Activity>& activities) {\n    int n = activities.size();\n\n    // Sort activities by finish time\n    sort(activities.begin(), activities.end(), compareActivities);\n\n    vector<Activity> selectedActivities;\n\n    // The first activity is always selected\n    selectedActivities.push_back(activities[0]);\n\n    // Consider rest of the activities\n    int lastFinishTime = activities[0].finish;\n\n    for (int i = 1; i < n; i++) {\n        // If this activity has start time greater than or equal to the finish time of previously\n        // selected activity, then select it\n        if (activities[i].start >= lastFinishTime) {\n            selectedActivities.push_back(activities[i]);\n            lastFinishTime = activities[i].finish;\n        }\n    }\n\n    return selectedActivities;\n}\n\nint main() {\n    vector<Activity> activities = {{\n        {1, 2},\n        {3, 4},\n        {0, 6},\n        {5, 7},\n        {8, 9},\n        {5, 9}\n    }};\n\n    vector<Activity> selected = activitySelection(activities);\n\n    cout << \"Selected activities are:\\n\";\n    for (const auto& activity : selected) {\n        cout << \"(\" << activity.start << \", \" << activity.finish << \") \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=II6ziATlMGM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/5502rv0/"
      ]
    ]
  },
  "huffman-coding": {
    "title": "Huffman Coding",
    "short": "Huffman coding is a lossless data compression algorithm that assigns variable-length codes to input characters based on their frequencies. More frequent characters receive shorter codes, while less frequent characters get longer codes, leading to an overall reduction in file size. It constructs a binary tree based on character frequencies and uses the tree to generate the codes.",
    "time": "Average: O(n log n), Best: O(n log n), Worst: O(n log n) where n is the number of unique characters. (Typically uses a priority queue implemented as a heap for efficient frequency management).",
    "space": "O(n) where n is the number of unique characters (to store the Huffman tree and character frequencies).",
    "code": "cpp\n#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n// Structure for a node in the Huffman tree\nstruct Node {\n    char data;\n    int frequency;\n    Node* left;\n    Node* right;\n\n    Node(char data, int frequency) : data(data), frequency(frequency), left(nullptr), right(nullptr) {}\n};\n\n// Custom comparator for the priority queue to create a min-priority queue\nstruct CompareNodes {\n    bool operator()(Node* a, Node* b) {\n        return a->frequency > b->frequency;\n    }\n};\n\n// Function to generate Huffman codes from the Huffman tree\nvoid generateCodes(Node* root, string code, map<char, string>& huffmanCodes) {\n    if (root == nullptr) {\n        return;\n    }\n\n    if (root->data != '\\0') { // If it's a leaf node (character node)\n        huffmanCodes[root->data] = code;\n    }\n\n    generateCodes(root->left, code + \"0\", huffmanCodes);\n    generateCodes(root->right, code + \"1\", huffmanCodes);\n}\n\nint main() {\n    // Example input: Character frequencies\n    map<char, int> frequencies = {\n        {'a', 5},\n        {'b', 9},\n        {'c', 12},\n        {'d', 13},\n        {'e', 16},\n        {'f', 45}\n    };\n\n    // Create a priority queue of nodes (min-priority queue)\n    priority_queue<Node*, vector<Node*>, CompareNodes> pq;\n\n    // Create a node for each character and push it into the priority queue\n    for (auto const& [character, frequency] : frequencies) {\n        pq.push(new Node(character, frequency));\n    }\n\n    // Build the Huffman tree\n    while (pq.size() > 1) {\n        // Extract the two nodes with the lowest frequencies\n        Node* left = pq.top();\n        pq.pop();\n        Node* right = pq.top();\n        pq.pop();\n\n        // Create a new internal node with a frequency equal to the sum of the two nodes\n        // The data is set to '\\0' to indicate it's an internal node\n        Node* internalNode = new Node('\\0', left->frequency + right->frequency);\n        internalNode->left = left;\n        internalNode->right = right;\n\n        // Push the internal node back into the priority queue\n        pq.push(internalNode);\n    }\n\n    // The remaining node in the priority queue is the root of the Huffman tree\n    Node* root = pq.top();\n    pq.pop();\n\n    // Generate Huffman codes from the Huffman tree\n    map<char, string> huffmanCodes;\n    generateCodes(root, \"\", huffmanCodes);\n\n    // Print the Huffman codes\n    cout << \"Huffman Codes:\" << endl;\n    for (auto const& [character, code] : huffmanCodes) {\n        cout << character << \": \" << code << endl;\n    }\n\n\n    //Clean up allocated memory (Important to prevent memory leaks)\n     function<void(Node*)> deleteTree = [&](Node* node) {\n        if (node == nullptr) return;\n        deleteTree(node->left);\n        deleteTree(node->right);\n        delete node;\n    };\n\n    deleteTree(root); //Delete entire tree starting from the root.\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/huffman-coding/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=ZdooBTgKl-U"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/huffman-tree/"
      ]
    ]
  },
  "fractional-knapsack": {
    "title": "Fractional Knapsack Problem",
    "short": "The Fractional Knapsack problem is a classic optimization problem where you are given a set of items, each with a weight and a value, and a knapsack with a maximum weight capacity.  Unlike the 0/1 knapsack, you can take fractions of items. The goal is to maximize the total value of items you put in the knapsack without exceeding its capacity. This is typically solved using a greedy approach by selecting items with the highest value-to-weight ratio first.",
    "time": "O(n log n) (due to sorting), O(n) for the greedy selection process after sorting.",
    "space": "O(1) (excluding input data, if sorting is done in-place) or O(n) (if sorting requires extra space).",
    "code": " #include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an item with weight and value\nstruct Item {\n    int value;\n    int weight;\n};\n\n// Function to calculate the value-to-weight ratio\ndouble valuePerWeight(Item item) {\n    return (double)item.value / item.weight;\n}\n\n// Comparator function to sort items based on value-to-weight ratio in descending order\nbool compareItems(Item a, Item b) {\n    return valuePerWeight(a) > valuePerWeight(b);\n}\n\n// Function to solve the fractional knapsack problem\ndouble fractionalKnapsack(int capacity, vector<Item>& items) {\n    // Sort the items based on value-to-weight ratio\n    sort(items.begin(), items.end(), compareItems);\n\n    double totalValue = 0.0;  // Initialize the total value\n    int currentWeight = 0;    // Initialize the current weight in the knapsack\n\n    // Iterate through the sorted items\n    for (Item item : items) {\n        // If the item can be taken completely\n        if (currentWeight + item.weight <= capacity) {\n            currentWeight += item.weight;      // Add the item's weight to the knapsack\n            totalValue += item.value;          // Add the item's value to the total value\n        } else {\n            // If the item can be taken partially\n            int remainingCapacity = capacity - currentWeight; // Calculate remaining capacity\n            totalValue += valuePerWeight(item) * remainingCapacity; // Add the fractional value\n            break; // Knapsack is full\n        }\n    }\n\n    return totalValue; // Return the maximum value\n}\n\nint main() {\n    int capacity = 50; // Knapsack capacity\n    vector<Item> items = {{\n                                   60, 10\n                               }, {\n                                   100, 20\n                               }, {\n                                   120, 30\n                               }};\n\n    // Calculate the maximum value that can be put in the knapsack\n    double maxValue = fractionalKnapsack(capacity, items);\n\n    cout << \"Maximum value: \" << maxValue << endl; // Output the result\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/fractional-knapsack-problem/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=F_DDzYnxDQY"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=Knapsack"
      ]
    ]
  },
  "job-sequencing-with-deadlines": {
    "title": "Job Sequencing with Deadlines",
    "short": "Job Sequencing with Deadlines is a greedy algorithm used to maximize profit when completing a set of jobs, each having a deadline and associated profit. The algorithm sorts jobs in decreasing order of their profit. It then iterates through the sorted jobs and attempts to schedule each job as late as possible before its deadline. The goal is to select jobs such that the total profit is maximized without violating any deadlines.",
    "time": "O(n log n) (Sorting) + O(n*m) (Scheduling, where m is the maximum deadline)",
    "space": "O(m) (for the schedule array, where m is the maximum deadline)",
    "code": "cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n// Structure to represent a job\nstruct Job {\n    char id;      // Job ID\n    int deadline; // Deadline of the job\n    int profit;   // Profit associated with the job\n};\n\n// Comparison function to sort jobs based on profit in decreasing order\nbool compareJobs(Job a, Job b) {\n    return (a.profit > b.profit);\n}\n\n// Function to perform job sequencing with deadlines\nvoid jobSequencing(vector<Job>& jobs, int n) {\n    // Sort jobs based on profit in decreasing order\n    sort(jobs.begin(), jobs.end(), compareJobs);\n\n    // Find the maximum deadline to determine the size of the schedule array\n    int maxDeadline = 0;\n    for (int i = 0; i < n; i++) {\n        maxDeadline = max(maxDeadline, jobs[i].deadline);\n    }\n\n    // Initialize the schedule array with -1, indicating no job is scheduled\n    vector<char> schedule(maxDeadline, ' ');\n\n    // Iterate through the sorted jobs and schedule them\n    int totalProfit = 0;\n    for (int i = 0; i < n; i++) {\n        // Find a free slot for the current job as late as possible before its deadline\n        for (int j = min(maxDeadline - 1, jobs[i].deadline - 1); j >= 0; j--) {\n            if (schedule[j] == ' ') {  // Check if the slot is free\n                schedule[j] = jobs[i].id; // Schedule the job\n                totalProfit += jobs[i].profit;\n                break; // Job scheduled, move to the next job\n            }\n        }\n    }\n\n    // Print the scheduled jobs and total profit\n    cout << \"Scheduled Jobs: \";\n    for (int i = 0; i < maxDeadline; i++) {\n        if(schedule[i] != ' ')\n          cout << schedule[i] << \" \";\n    }\n    cout << endl;\n\n    cout << \"Total Profit: \" << totalProfit << endl;\n}\n\nint main() {\n    // Example usage\n    vector<Job> jobs = {\n        {'a', 2, 100},\n        {'b', 1, 19},\n        {'c', 2, 27},\n        {'d', 1, 25},\n        {'e', 3, 15}\n    };\n\n    int n = jobs.size();\n\n    jobSequencing(jobs, n);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/job-sequencing-problem/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=LjPxM_U4hbc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/discuss/interview-question/439660/google-online-assessment-job-sequencing"
      ]
    ]
  },
  "dijkstra": {
    "title": "Dijkstra's Algorithm",
    "short": "Dijkstra's algorithm is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge weights. It works by iteratively expanding the set of visited nodes, always selecting the node with the smallest tentative distance from the source. The algorithm maintains a set of unvisited nodes and updates their distances until the shortest path to all reachable nodes is found. It is commonly used in network routing protocols and GPS navigation systems.",
    "time": "Average: O((V + E) log V), Best: O((V + E) log V), Worst: O((V + E) log V) (using a priority queue)",
    "space": "O(V)",
    "code": "// C++ implementation of Dijkstra's algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\n// Structure to represent an edge in the graph\nstruct Edge {\n    int to;\n    int weight;\n};\n\n// Structure to represent a node in the graph\nstruct Node {\n    int vertex;\n    int distance;\n\n    // Overload the less than operator for the priority queue\n    bool operator>(const Node& other) const {\n        return distance > other.distance;\n    }\n};\n\n// Function to implement Dijkstra's algorithm\nvector<int> dijkstra(const vector<vector<Edge>>& graph, int start) {\n    int num_vertices = graph.size();\n    vector<int> distances(num_vertices, numeric_limits<int>::max()); // Initialize distances to infinity\n    distances[start] = 0; // Distance from start node to itself is 0\n\n    priority_queue<Node, vector<Node>, greater<Node>> pq; // Min-priority queue\n    pq.push({start, 0});\n\n    while (!pq.empty()) {\n        Node current = pq.top();\n        pq.pop();\n\n        int u = current.vertex;\n        int dist_u = current.distance;\n\n        // If we've already found a shorter path to u, skip\n        if (dist_u > distances[u]) {\n            continue;\n        }\n\n        // Iterate through the neighbors of u\n        for (const Edge& edge : graph[u]) {\n            int v = edge.to;\n            int weight_uv = edge.weight;\n\n            // If we find a shorter path to v through u\n            if (distances[u] != numeric_limits<int>::max() && distances[u] + weight_uv < distances[v]) {\n                distances[v] = distances[u] + weight_uv; // Update the distance to v\n                pq.push({v, distances[v]}); // Add v to the priority queue\n            }\n        }\n    }\n\n    return distances;\n}\n\nint main() {\n    // Example graph represented as an adjacency list\n    // graph[i] is a vector of Edges representing the neighbors of vertex i\n    vector<vector<Edge>> graph = {\n        {{1, 4}, {2, 2}},\n        {{0, 4}, {2, 5}, {3, 10}},\n        {{0, 2}, {1, 5}, {3, 3}},\n        {{1, 10}, {2, 3}}\n    };\n\n    int start_node = 0;\n\n    vector<int> shortest_distances = dijkstra(graph, start_node);\n\n    cout << \"Shortest distances from node \" << start_node << \":\" << endl;\n    for (int i = 0; i < shortest_distances.size(); ++i) {\n        cout << \"To node \" << i << \": \" << shortest_distances[i] << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=pVfj6mxhdfw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dijkstra/"
      ]
    ]
  },
  "dynamic-programming": {
    "title": "Dynamic Programming",
    "short": "Dynamic Programming (DP) is an algorithmic technique for solving optimization problems by breaking them down into overlapping subproblems. It solves each subproblem only once and stores the result in a table (memoization) to avoid recomputation. DP is applicable when the optimal solution to a problem can be constructed from the optimal solutions to its subproblems (optimal substructure) and when subproblems are overlapping.",
    "time": "Varies depending on the problem. Commonly O(n), O(n^2), O(n*m), etc., where n and m are input sizes.",
    "space": "Varies depending on the problem. Commonly O(n), O(n^2), O(n*m), etc., where n and m are input sizes. Can sometimes be optimized to O(1) or O(log n) with techniques like tabulation and space optimization.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Example: Fibonacci sequence using dynamic programming (memoization)\nint fibonacci(int n, vector<int>& memo) {\n    // Base cases\n    if (n <= 1) {\n        return n;\n    }\n\n    // Check if the result is already memoized\n    if (memo[n] != -1) {\n        return memo[n];\n    }\n\n    // Recursive call with memoization\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}\n\n// Example: Fibonacci sequence using dynamic programming (tabulation)\nint fibonacciTabulation(int n) {\n    if (n <= 1) return n;\n\n    vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[n];\n}\n\nint main() {\n    int n = 10;\n\n    // Memoization example\n    vector<int> memo(n + 1, -1); // Initialize memoization table with -1\n    cout << \"Fibonacci(\" << n << \") using memoization: \" << fibonacci(n, memo) << endl;\n\n    // Tabulation example\n    cout << \"Fibonacci(\" << n << \") using tabulation: \" << fibonacciTabulation(n) << endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/dynamic-programming/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=OQ5uWjEuc3E"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dynamic-programming/"
      ]
    ]
  },
  "fibonacci-sequence": {
    "title": "Fibonacci Sequence",
    "short": "The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. It exhibits recursive properties and appears in various mathematical and natural contexts. It's primarily used as a fundamental example in computer science to illustrate recursion, dynamic programming, and algorithmic analysis concepts. The sequence helps demonstrate how to efficiently solve problems with overlapping subproblems.",
    "time": {
      "recursive": "O(2^n)",
      "iterative": "O(n)",
      "matrix_exponentiation": "O(log n)"
    },
    "space": {
      "recursive": "O(n) (due to call stack)",
      "iterative": "O(1)",
      "matrix_exponentiation": "O(1)"
    },
    "code": "// C++ implementation of the Fibonacci sequence using iterative and matrix exponentiation approaches\n#include <iostream>\n#include <vector>\n\n// Iterative approach - Efficient for larger n\nunsigned long long fibonacciIterative(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    unsigned long long a = 0, b = 1, temp;\n    for (int i = 2; i <= n; ++i) {\n        temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Matrix multiplication helper function\nstd::vector<std::vector<unsigned long long>> matrixMultiply(const std::vector<std::vector<unsigned long long>>& A, const std::vector<std::vector<unsigned long long>>& B) {\n    std::vector<std::vector<unsigned long long>> C(2, std::vector<unsigned long long>(2, 0));\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            for (int k = 0; k < 2; ++k) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n    return C;\n}\n\n// Matrix exponentiation for Fibonacci - O(log n) time complexity\nunsigned long long fibonacciMatrix(int n) {\n    if (n <= 1) {\n        return n;\n    }\n\n    std::vector<std::vector<unsigned long long>> result = {{1, 0}, {0, 1}}; // Identity matrix\n    std::vector<std::vector<unsigned long long>> base = {{1, 1}, {1, 0}}; // Fibonacci matrix\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = matrixMultiply(result, base);\n        }\n        base = matrixMultiply(base, base);\n        n /= 2;\n    }\n\n    return result[0][1]; // F(n)\n}\n\nint main() {\n    int n = 10; // Example: Calculate the 10th Fibonacci number\n\n    std::cout << \"Fibonacci(\" << n << \") using iterative approach: \" << fibonacciIterative(n) << std::endl;\n    std::cout << \"Fibonacci(\" << n << \") using matrix exponentiation approach: \" << fibonacciMatrix(n) << std::endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=oBTpM00iM5Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/fibonacci/"
      ]
    ]
  },
  "coin-change": {
    "title": "Coin Change",
    "short": "The Coin Change problem aims to find the minimum number of coins required to make up a given amount, given a set of coin denominations. It can be solved using dynamic programming, building a table of optimal solutions for subproblems. The algorithm efficiently explores possible combinations of coins to achieve the target amount, avoiding redundant calculations and ensuring an optimal result.",
    "time": "O(amount * number of coins)",
    "space": "O(amount)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\n// Function to find the minimum number of coins to make up the amount\nint coinChange(vector<int>& coins, int amount) {\n    // dp[i] will store the minimum number of coins needed to make up amount i\n    vector<int> dp(amount + 1, amount + 1); // Initialize with a value greater than the maximum possible answer\n\n    // Base case: 0 coins are needed to make up an amount of 0\n    dp[0] = 0;\n\n    // Iterate through all amounts from 1 to the target amount\n    for (int i = 1; i <= amount; ++i) {\n        // Iterate through all available coins\n        for (int coin : coins) {\n            // If the current coin is less than or equal to the current amount\n            if (coin <= i) {\n                // Update dp[i] with the minimum of its current value and\n                // the number of coins needed to make up (i - coin) plus 1 (for the current coin)\n                dp[i] = min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n\n    // If dp[amount] is still greater than the amount, it means no solution was found\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n\nint main() {\n    vector<int> coins = {1, 2, 5}; // Example coin denominations\n    int amount = 11;               // Example target amount\n\n    int minCoins = coinChange(coins, amount);\n\n    if (minCoins == -1) {\n        cout << \"Cannot make the amount with the given coins.\" << endl;\n    } else {\n        cout << \"Minimum number of coins needed: \" << minCoins << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/coin-change-dp-7/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=H9bfqozjoqs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dynamic-programming/"
      ]
    ]
  },
  "longest-increasing-subsequence": {
    "title": "Longest Increasing Subsequence (LIS)",
    "short": "The Longest Increasing Subsequence (LIS) problem involves finding the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order.  Subsequences are not necessarily contiguous. Dynamic programming or binary search techniques are commonly used to efficiently solve this problem, finding applications in various sequence analysis tasks.",
    "time": "O(n log n)",
    "space": "O(n)",
    "code": "// C++ implementation of finding the Longest Increasing Subsequence (LIS)\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the length of the LIS\nint longestIncreasingSubsequence(const vector<int>& nums) {\n    // tails[i] is the smallest tail of all increasing subsequences with length i+1.\n    vector<int> tails;\n\n    // Iterate through each number in the input sequence\n    for (int num : nums) {\n        // If we find a number in tails that is greater than or equal to the current number,\n        // it means we can potentially improve an existing subsequence.\n        auto it = lower_bound(tails.begin(), tails.end(), num);\n\n        // If the lower_bound is at the end, it means the current number is greater than all elements in 'tails',\n        // thus extending the longest increasing subsequence found so far.\n        if (it == tails.end()) {\n            tails.push_back(num);\n        } else {\n            // Otherwise, replace the smallest number >= current number with the current number.\n            // This ensures we keep the smallest tail for each subsequence length.\n            *it = num;\n        }\n    }\n\n    // The size of the 'tails' vector is the length of the LIS.\n    return tails.size();\n}\n\nint main() {\n    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18}; // Example input\n    int lisLength = longestIncreasingSubsequence(nums);\n\n    cout << \"Length of the Longest Increasing Subsequence: \" << lisLength << endl; // Output the result\n\n    vector<int> nums2 = {0,1,0,3,2,3}; // Another Example Input\n    lisLength = longestIncreasingSubsequence(nums2);\n    cout << \"Length of the Longest Increasing Subsequence: \" << lisLength << endl;\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=cjWnW0hdF1Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/longest-increasing-subsequence/"
      ]
    ]
  },
  "longest-common-subsequence": {
    "title": "Longest Common Subsequence (LCS)",
    "short": "The Longest Common Subsequence (LCS) problem aims to find the longest sequence that is a subsequence of two or more given sequences. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The most common approach to solve LCS is using dynamic programming, building a table to store lengths of LCS for prefixes of the input sequences.",
    "time": "O(m*n) where m and n are the lengths of the input sequences.",
    "space": "O(m*n)",
    "code": "cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the length of the Longest Common Subsequence (LCS)\nstring longestCommonSubsequence(string s1, string s2) {\n    int m = s1.length();\n    int n = s2.length();\n\n    // Create a 2D vector to store lengths of LCS for subproblems\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n    // Fill the dp table in bottom-up manner\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (s1[i - 1] == s2[j - 1]) {\n                // If characters match, increment LCS length by 1\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                // If characters don't match, take the maximum of LCS lengths from adjacent cells\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    // Construct the LCS string by backtracking through the dp table\n    int i = m, j = n;\n    string lcs = \"\";\n    while (i > 0 && j > 0) {\n        if (s1[i - 1] == s2[j - 1]) {\n            // If characters match, include the character in the LCS and move diagonally\n            lcs = s1[i - 1] + lcs;\n            i--;\n            j--;\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n            // If LCS length is greater by moving up, move up\n            i--;\n        } else {\n            // If LCS length is greater by moving left, move left\n            j--;\n        }\n    }\n\n    return lcs;\n}\n\nint main() {\n    string s1 = \"AGGTAB\";\n    string s2 = \"GXTXAYB\";\n\n    string lcs = longestCommonSubsequence(s1, s2);\n\n    cout << \"Longest Common Subsequence is: \" << lcs << endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=NnD96BjUjIo"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/longest-common-subsequence/"
      ]
    ]
  },
  "edit-distance": {
    "title": "Edit Distance (Levenshtein Distance)",
    "short": "Edit distance, also known as Levenshtein distance, quantifies the similarity between two strings by counting the minimum number of single-character edits required to change one string into the other. These edits include insertions, deletions, and substitutions. It's commonly used in spell checking, DNA sequencing, and information retrieval to find approximate string matches and measure string similarity.",
    "time": "Average, Best, Worst: O(m*n), where m and n are the lengths of the input strings.",
    "space": "O(m*n)",
    "code": "// C++ implementation of Edit Distance\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the edit distance between two strings\nint editDistance(const string& str1, const string& str2) {\n  int m = str1.length();\n  int n = str2.length();\n\n  // Create a DP table to store the edit distances\n  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n  // Initialize the first row and column of the DP table\n  for (int i = 0; i <= m; ++i) {\n    dp[i][0] = i; // Cost of deleting i characters from str1 to get an empty string\n  }\n  for (int j = 0; j <= n; ++j) {\n    dp[0][j] = j; // Cost of inserting j characters into str1 to get str2\n  }\n\n  // Populate the DP table using dynamic programming\n  for (int i = 1; i <= m; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      if (str1[i - 1] == str2[j - 1]) {\n        // If the characters match, no cost\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        // If the characters don't match, consider insertion, deletion, and substitution\n        dp[i][j] = 1 + min({dp[i - 1][j],   // Deletion\n                             dp[i][j - 1],   // Insertion\n                             dp[i - 1][j - 1]}); // Substitution\n      }\n    }\n  }\n\n  // The edit distance is stored in dp[m][n]\n  return dp[m][n];\n}\n\nint main() {\n  string str1 = \"kitten\";\n  string str2 = \"sitting\";\n\n  int distance = editDistance(str1, str2);\n\n  cout << \"Edit distance between \\\"\" << str1 << \"\\\" and \\\"\" << str2 << \"\\\" is: \" << distance << endl; // Expected output: 3\n\n  string str3 = \"intention\";\n  string str4 = \"execution\";\n  distance = editDistance(str3,str4);\n  cout << \"Edit distance between \\\"\" << str3 << \"\\\" and \\\"\" << str4 << \"\\\" is: \" << distance << endl; //Expected output: 5\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/edit-distance-dp-5/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=We3YDTzNXEk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/edit-distance/"
      ]
    ]
  },
  "matrix-chain-multiplication": {
    "title": "Matrix Chain Multiplication",
    "short": "Matrix Chain Multiplication is an optimization problem that aims to find the most efficient way to multiply a sequence of matrices. It involves determining the optimal parenthesization of the matrix product to minimize the total number of scalar multiplications. Dynamic programming is commonly used to solve this problem by building a table of minimum costs for multiplying sub-chains of matrices.",
    "time": "O(n^3)",
    "space": "O(n^2)",
    "code": "// Matrix Chain Multiplication using Dynamic Programming\n#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\n// Function to calculate the minimum number of scalar multiplications\nint matrixChainOrder(vector<int>& dimensions, int n) {\n    // cost[i][j] = Minimum number of scalar multiplications needed\n    // to compute the matrix A[i]A[i+1]...A[j] = A[i..j]\n    vector<vector<int>> cost(n, vector<int>(n, 0));\n\n    // For chain length l = 2 to n\n    for (int len = 2; len < n; len++) {\n        for (int i = 1; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            cost[i][j] = numeric_limits<int>::max();\n\n            // Try all possible places to split the matrix chain\n            for (int k = i; k < j; k++) {\n                // cost[i][k] + cost[k+1][j] + dimensions[i-1]*dimensions[k]*dimensions[j]\n                int q = cost[i][k] + cost[k + 1][j] + dimensions[i - 1] * dimensions[k] * dimensions[j];\n                if (q < cost[i][j]) {\n                    cost[i][j] = q;\n                }\n            }\n        }\n    }\n\n    // Return the minimum cost to multiply the entire matrix chain\n    return cost[1][n - 1];\n}\n\nint main() {\n    // Example usage:\n    // Consider matrices A, B, C, D of dimensions 40x20, 20x30, 30x10, and 10x30 respectively\n    vector<int> dimensions = {40, 20, 30, 10, 30}; // Dimensions of matrices: A(40x20), B(20x30), C(30x10), D(10x30)\n    int n = dimensions.size(); // n = number of matrices + 1\n\n    cout << \"Minimum number of scalar multiplications needed: \" << matrixChainOrder(dimensions, n) << endl; // Output: 30000\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=k3i1j0H_i3o"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dynamic-programming/"
      ]
    ]
  },
  "subset-sum": {
    "title": "Subset Sum Problem",
    "short": "The Subset Sum problem determines if there exists a subset of a given set of non-negative integers whose sum is equal to a target sum 'S'. It's a classic NP-complete problem often solved using dynamic programming or recursion with memoization. The problem finds applications in various fields, including cryptography and knapsack problems.",
    "time": "O(n*S) where n is the number of elements in the set and S is the target sum.",
    "space": "O(n*S)",
    "code": " #include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to solve the subset sum problem using dynamic programming\nbool isSubsetSum(const vector<int>& set, int n, int sum) {\n    // Create a boolean table to store results of subproblems\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n    // If sum is 0, then answer is true\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    // If sum is not 0 and set is empty, then answer is false\n    for (int i = 1; i <= sum; i++)\n        dp[0][i] = false;\n\n    // Fill the dp table in bottom up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (set[i - 1] <= j) {\n                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - set[i - 1]];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[n][sum];\n}\n\nint main() {\n    vector<int> set = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    int n = set.size();\n\n    if (isSubsetSum(set, n, sum) == true)\n        cout << \"Found a subset with given sum\";\n    else\n        cout << \"No subset with given sum\";\n    cout << endl;\n    \n    //Example with empty set and target sum 0\n    vector<int> empty_set = {};\n    int sum2 = 0;\n    int n2 = empty_set.size();\n\n    if (isSubsetSum(empty_set, n2, sum2) == true)\n        cout << \"Found a subset with given sum (empty set, sum 0)\";\n    else\n        cout << \"No subset with given sum (empty set, sum 0)\";\n    cout << endl;\n    \n    // Example with target sum that is not possible\n    vector<int> set3 = {1,2,3,4,5};\n    int sum3 = 20; // No subset will sum to 20 in this set\n    int n3 = set3.size();\n    if (isSubsetSum(set3, n3, sum3) == true)\n        cout << \"Found a subset with given sum (target sum impossible)\";\n    else\n        cout << \"No subset with given sum (target sum impossible)\";\n    cout << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=s6FhG--P7z0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dynamic-programming/"
      ]
    ]
  },
  "dp-on-trees": {
    "title": "Dynamic Programming on Trees",
    "short": "Dynamic Programming on Trees (DP on Trees) is a powerful algorithmic technique used to solve optimization problems on tree data structures. It involves computing optimal solutions for subtrees and combining them to find the optimal solution for the entire tree. The key idea is to define a state (e.g., `dp[node][state]`) representing the optimal solution for the subtree rooted at a given node, considering a specific condition. This approach avoids redundant calculations by storing and reusing the results of subproblems.",
    "time": "O(N) where N is the number of nodes in the tree.",
    "space": "O(N) for storing the DP table.",
    "code": "// Dynamic Programming on Trees - Maximum Independent Set Problem\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to solve the Maximum Independent Set problem on a tree using DP\npair<int, int> maxIndependentSet(int node, int parent, const vector<vector<int>>& adj, vector<pair<int, int>>& dp) {\n    // dp[node].first stores the size of the maximum independent set including the node\n    // dp[node].second stores the size of the maximum independent set excluding the node\n\n    // Base case: If DP values are already computed, return them\n    if (dp[node].first != -1) {\n        return dp[node];\n    }\n\n    // Initialize the DP values\n    int includeNode = 1; // Initially, include the current node\n    int excludeNode = 0; // Initially, exclude the current node\n\n    // Iterate over all children of the current node\n    for (int child : adj[node]) {\n        if (child != parent) {\n            // Recursively calculate the maximum independent set for the child\n            pair<int, int> childResult = maxIndependentSet(child, node, adj, dp);\n\n            // If we include the current node, we cannot include any of its children\n            includeNode += childResult.second;\n\n            // If we exclude the current node, we can either include or exclude its children\n            excludeNode += max(childResult.first, childResult.second);\n        }\n    }\n\n    // Store the computed DP values\n    dp[node] = {includeNode, excludeNode};\n    return dp[node];\n}\n\nint main() {\n    int n; // Number of nodes in the tree\n    cout << \"Enter the number of nodes: \";\n    cin >> n;\n\n    vector<vector<int>> adj(n + 1); // Adjacency list to represent the tree\n    vector<pair<int, int>> dp(n + 1, {-1, -1}); // DP table to store the maximum independent set size\n\n    // Input the edges of the tree\n    cout << \"Enter the edges (u v), one edge per line (e.g., 1 2):\\n\";\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Calculate the maximum independent set starting from node 1 (arbitrary root)\n    pair<int, int> result = maxIndependentSet(1, 0, adj, dp);\n\n    // The size of the maximum independent set is the maximum of including or excluding the root\n    cout << \"Size of the Maximum Independent Set: \" << max(result.first, result.second) << endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/maximum-independent-set-problem/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=n0e7V-u8u9E"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/tree/"
      ]
    ]
  },
  "backtracking-algorithms": {
    "title": "Backtracking Algorithms",
    "short": "Backtracking is a general algorithmic technique for finding all (or some) solutions to computational problems that incrementally builds candidates to the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be completed to a valid solution. It's a refinement of brute-force search, systematically exploring the solution space, pruning branches that don't lead to solutions. Backtracking is frequently used for solving constraint satisfaction problems, such as puzzles and optimization problems where finding a solution involves trying different possibilities.",
    "time": "O(b^d) where b is the branching factor and d is the depth of the search tree in the worst case. However, this heavily depends on the problem and constraints.",
    "space": "O(d) where d is the depth of the search tree (due to recursive calls). This can vary depending on problem-specific data structures used.",
    "code": "// C++ implementation of a simple backtracking algorithm: Sudoku Solver\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to print the Sudoku grid\nvoid printGrid(const vector<vector<int>>& grid) {\n    for (int i = 0; i < 9; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            cout << grid[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// Function to check if it's safe to place a number in a given cell\nbool isSafe(const vector<vector<int>>& grid, int row, int col, int num) {\n    // Check row\n    for (int x = 0; x < 9; ++x)\n        if (grid[row][x] == num)\n            return false;\n\n    // Check column\n    for (int x = 0; x < 9; ++x)\n        if (grid[x][col] == num)\n            return false;\n\n    // Check 3x3 box\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n\n    for (int i = 0; i < 3; ++i)\n        for (int j = 0; j < 3; ++j)\n            if (grid[i + startRow][j + startCol] == num)\n                return false;\n\n    return true;\n}\n\n// Recursive function to solve the Sudoku\nbool solveSudoku(vector<vector<int>>& grid) {\n    int row, col;\n\n    // Find an unassigned cell. If no unassigned cell is found, Sudoku is solved.\n    bool isEmpty = false;\n    for (row = 0; row < 9; ++row) {\n        for (col = 0; col < 9; ++col) {\n            if (grid[row][col] == 0) {\n                isEmpty = true;\n                break;\n            }\n        }\n        if (isEmpty)\n            break;\n    }\n\n    if (!isEmpty) // No unassigned cell means solved\n        return true;\n\n    // Try digits 1 to 9\n    for (int num = 1; num <= 9; ++num) {\n        if (isSafe(grid, row, col, num)) {\n            grid[row][col] = num;\n\n            // Recursively try to solve the rest of the Sudoku\n            if (solveSudoku(grid))\n                return true;\n\n            // If the current assignment leads to a dead end, backtrack\n            grid[row][col] = 0; // Reset to 0 (unassigned)\n        }\n    }\n\n    // If no digit leads to a solution, backtrack\n    return false;\n}\n\nint main() {\n    // Example Sudoku grid (0 represents unassigned cells)\n    vector<vector<int>> grid = {\n        {5, 3, 0, 0, 7, 0, 0, 0, 0},\n        {6, 0, 0, 1, 9, 5, 0, 0, 0},\n        {0, 9, 8, 0, 0, 0, 0, 6, 0},\n        {8, 0, 0, 0, 6, 0, 0, 0, 3},\n        {4, 0, 0, 8, 0, 3, 0, 0, 1},\n        {7, 0, 0, 0, 2, 0, 0, 0, 6},\n        {0, 6, 0, 0, 0, 0, 2, 8, 0},\n        {0, 0, 0, 4, 1, 9, 0, 0, 5},\n        {0, 0, 0, 0, 8, 0, 0, 7, 9}\n    };\n\n    cout << \"Sudoku Puzzle:\\n\";\n    printGrid(grid);\n\n    if (solveSudoku(grid)) {\n        cout << \"\\nSudoku Solution:\\n\";\n        printGrid(grid);\n    } else {\n        cout << \"\\nNo solution exists.\\n\";\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/backtracking-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=DKCbsiDBrug"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/backtracking/"
      ]
    ]
  },
  "permutations": {
    "title": "Permutations",
    "short": "A permutation is an arrangement of objects in a specific order. Generating permutations involves systematically exploring all possible arrangements of a set of elements. Common algorithms recursively swap elements to produce each unique ordering. Permutations are used in various applications like password generation, testing all possible combinations, and solving combinatorial problems.",
    "time": "O(n!)",
    "space": "O(n)",
    "code": "// C++ program to generate all permutations of a given string/array\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to print a vector of integers (helper function for demonstration)\nvoid printVector(const vector<int>& arr) {\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n// Function to generate permutations of a vector of integers\nvoid generatePermutations(vector<int>& arr, int l, int r, vector<vector<int>>& result) {\n    // Base case: when l == r, we have a complete permutation\n    if (l == r) {\n        result.push_back(arr);\n        //Optional: printVector(arr);  // Print the current permutation\n    } else {\n        // Iterate through the remaining elements in the array\n        for (int i = l; i <= r; i++) {\n            // Swap the current element with the element at index l\n            swap(arr[l], arr[i]);\n\n            // Recursively generate permutations for the subarray arr[l+1...r]\n            generatePermutations(arr, l + 1, r, result);\n\n            // Backtrack: swap the elements back to restore the original order\n            swap(arr[l], arr[i]);\n        }\n    }\n}\n\n\n// Function to generate permutations using the next_permutation STL function.\nvector<vector<int>> generatePermutationsSTL(vector<int> arr) {\n    sort(arr.begin(), arr.end()); //Ensure the input is sorted to generate all permutations.\n    vector<vector<int>> result;\n\n    do {\n        result.push_back(arr);\n    } while (next_permutation(arr.begin(), arr.end()));\n\n    return result;\n}\n\n\nint main() {\n    vector<int> numbers = {1, 2, 3};\n    vector<vector<int>> permutations;\n\n    cout << \"Generating permutations using recursive backtracking:\\n\";\n    generatePermutations(numbers, 0, numbers.size() - 1, permutations);\n\n    cout << \"Total number of permutations: \" << permutations.size() << endl;\n    cout << \"\\nGenerating permutations using STL next_permutation:\\n\";\n\n    vector<vector<int>> permutationsSTL = generatePermutationsSTL(numbers);\n\n     for (const auto& perm : permutationsSTL) {\n            for (int num : perm) {\n                cout << num << \" \";\n            }\n            cout << endl;\n        }\n\n\n    cout << \"Total number of permutations using STL: \" << permutationsSTL.size() << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=sSn-a1nFq9U"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/permutation/"
      ]
    ]
  },
  "power-set": {
    "title": "Power Set",
    "short": "The power set of a set S is the set of all subsets of S, including the empty set and S itself. It's often generated recursively or iteratively by considering each element and either including it or excluding it in the subsets. Power sets are fundamental in combinatorics and set theory, with applications in areas like data mining and algorithm design when exploring all possible combinations.",
    "time": "O(2^n)",
    "space": "O(2^n)",
    "code": "// C++ program to generate power set of a set\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to generate power set of a set\nvector<vector<int>> powerSet(vector<int>& nums) {\n    int n = nums.size();\n    int powerSetSize = pow(2, n);\n    vector<vector<int>> result;\n\n    // Run loop 2^n times (total number of subsets)\n    for (int counter = 0; counter < powerSetSize; counter++) {\n        vector<int> subset;\n        for (int j = 0; j < n; j++) {\n            // Check if jth bit in the counter is set\n            if (counter & (1 << j)) {\n                subset.push_back(nums[j]);\n            }\n        }\n        result.push_back(subset);\n    }\n\n    return result;\n}\n\nint main() {\n    vector<int> nums = {1, 2, 3};\n    vector<vector<int>> subsets = powerSet(nums);\n\n    cout << \"Power Set:\" << endl;\n    for (auto subset : subsets) {\n        cout << \"{\";\n        for (size_t i = 0; i < subset.size(); ++i) {\n            cout << subset[i];\n            if (i < subset.size() - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"} \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/power-set/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=b7AYbpM5YrE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/subset/"
      ]
    ]
  },
  "n-queens": {
    "title": "N-Queens Problem",
    "short": "The N-Queens problem is a classic constraint satisfaction problem where the goal is to place N chess queens on an N×N chessboard so that no two queens threaten each other. This means no two queens can share the same row, column, or diagonal. The problem is typically solved using backtracking, systematically exploring possible placements and pruning branches that violate the constraints.",
    "time": "Average: O(N!), Best: O(N!), Worst: O(N!)",
    "space": "O(N)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a queen can be placed at board[row][col]\nbool isSafe(vector<vector<bool>>& board, int row, int col, int n) {\n    // Check this row on the left side\n    for (int i = 0; i < col; i++) {\n        if (board[row][i]) {\n            return false;\n        }\n    }\n\n    // Check upper diagonal on the left side\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j]) {\n            return false;\n        }\n    }\n\n    // Check lower diagonal on the left side\n    for (int i = row, j = col; i < n && j >= 0; i++, j--) {\n        if (board[i][j]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Recursive function to solve N Queen problem\nbool solveNQueensUtil(vector<vector<bool>>& board, int col, int n) {\n    // Base case: If all queens are placed then return true\n    if (col >= n) {\n        return true;\n    }\n\n    // Consider this column and try placing this queen in all rows one by one\n    for (int i = 0; i < n; i++) {\n        // Check if the queen can be placed on board[i][col]\n        if (isSafe(board, i, col, n)) {\n            // Place this queen in board[i][col]\n            board[i][col] = true;\n\n            // Recur to place rest of the queens\n            if (solveNQueensUtil(board, col + 1, n)) {\n                return true;\n            }\n\n            // If placing queen in board[i][col] doesn't lead to a solution, then remove queen from board[i][col] (Backtrack)\n            board[i][col] = false; // BACKTRACK\n        }\n    }\n\n    // If the queen cannot be placed in any row in this column col, then return false\n    return false;\n}\n\n// This function solves the N Queen problem using Backtracking.  It mainly uses solveNQueensUtil() to solve the problem.\nvector<vector<string>> solveNQueens(int n) {\n    vector<vector<bool>> board(n, vector<bool>(n, false));\n    vector<vector<string>> solutions;\n\n    if (solveNQueensUtil(board, 0, n) == false) {\n        return solutions; // No solution exists\n    }\n\n    // Convert boolean board to string format for solutions\n    vector<string> solution;\n    for (int i = 0; i < n; ++i) {\n        string row_str = \"\";\n        for (int j = 0; j < n; ++j) {\n            if (board[i][j]) {\n                row_str += 'Q';\n            } else {\n                row_str += '.';\n            }\n        }\n        solution.push_back(row_str);\n    }\n    solutions.push_back(solution);\n\n    //Printing only one solution. For all solutions, need to modify solveNQueensUtil to collect all possible board states.\n    return solutions;\n}\n\nint main() {\n    int n = 4; // Example: Solve for a 4x4 board\n    vector<vector<string>> solutions = solveNQueens(n);\n\n    if (solutions.empty()) {\n        cout << \"No solutions exist for N = \" << n << endl;\n    } else {\n        cout << \"Solution for N = \" << n << \":\" << endl;\n        for (const auto& solution : solutions) {\n            for (const string& row : solution) {\n                cout << row << endl;\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=xFv_Hl4mXNc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/n-queens/"
      ]
    ]
  },
  "sudoku-solver": {
    "title": "Sudoku Solver using Backtracking",
    "short": "A Sudoku solver is an algorithm that attempts to complete a partially filled 9x9 Sudoku grid, adhering to the constraints that each row, column, and 3x3 subgrid (box) must contain all digits from 1 to 9 without repetition. The most common approach is backtracking. Backtracking systematically tries possible digits for empty cells, recursively exploring solution paths. If a path leads to a contradiction, it backtracks and tries a different digit.",
    "time": "Worst Case: O(9^(number of empty cells)). Average Case: Difficult to characterize precisely, but significantly better than worst case due to constraints. Best Case: O(1) if the input is already solved.",
    "space": "O(1) (excluding the input grid). The recursion depth is limited to the number of empty cells, which is at most 81.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to print the Sudoku grid\nvoid printGrid(const vector<vector<int>>& grid) {\n    for (int i = 0; i < 9; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            cout << grid[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// Function to check if a number can be placed at a given position\nbool isValid(const vector<vector<int>>& grid, int row, int col, int num) {\n    // Check if the number is already present in the row\n    for (int i = 0; i < 9; ++i) {\n        if (grid[row][i] == num) {\n            return false;\n        }\n    }\n\n    // Check if the number is already present in the column\n    for (int i = 0; i < 9; ++i) {\n        if (grid[i][col] == num) {\n            return false;\n        }\n    }\n\n    // Check if the number is already present in the 3x3 subgrid\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (grid[startRow + i][startCol + j] == num) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n// Function to find an empty cell in the grid\nbool findEmptyCell(const vector<vector<int>>& grid, int& row, int& col) {\n    for (row = 0; row < 9; ++row) {\n        for (col = 0; col < 9; ++col) {\n            if (grid[row][col] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Backtracking function to solve the Sudoku\nbool solveSudoku(vector<vector<int>>& grid) {\n    int row, col;\n\n    // If there are no empty cells, the Sudoku is solved\n    if (!findEmptyCell(grid, row, col)) {\n        return true; // Sudoku solved\n    }\n\n    // Try placing digits from 1 to 9 in the empty cell\n    for (int num = 1; num <= 9; ++num) {\n        if (isValid(grid, row, col, num)) {\n            // Place the number if it's valid\n            grid[row][col] = num;\n\n            // Recursively try to solve the rest of the Sudoku\n            if (solveSudoku(grid)) {\n                return true; // Solution found\n            }\n\n            // If the recursive call fails, backtrack and try a different number\n            grid[row][col] = 0; // Reset the cell\n        }\n    }\n\n    // No number can be placed in this cell, so backtrack\n    return false; // Trigger backtracking\n}\n\nint main() {\n    // Example Sudoku grid (0 represents empty cells)\n    vector<vector<int>> grid = {\n        {5, 3, 0, 0, 7, 0, 0, 0, 0},\n        {6, 0, 0, 1, 9, 5, 0, 0, 0},\n        {0, 9, 8, 0, 0, 0, 0, 6, 0},\n        {8, 0, 0, 0, 6, 0, 0, 0, 3},\n        {4, 0, 0, 8, 0, 3, 0, 0, 1},\n        {7, 0, 0, 0, 2, 0, 0, 0, 6},\n        {0, 6, 0, 0, 0, 0, 2, 8, 0},\n        {0, 0, 0, 4, 1, 9, 0, 0, 5},\n        {0, 0, 0, 0, 8, 0, 0, 7, 9}\n    };\n\n    cout << \"Sudoku grid before solving:\\n\";\n    printGrid(grid);\n\n    if (solveSudoku(grid)) {\n        cout << \"\\nSudoku grid after solving:\\n\";\n        printGrid(grid);\n    } else {\n        cout << \"\\nNo solution exists.\\n\";\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/sudoku-backtracking-7/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=G_UYXzGuqvQ"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sudoku/"
      ]
    ]
  },
  "rat-in-a-maze": {
    "title": "Rat in a Maze",
    "short": "The Rat in a Maze problem involves finding a path for a rat to traverse a maze from a starting point to a destination point. The maze is represented by a 2D grid where '1' indicates a valid path and '0' indicates a blocked cell. The rat can only move in four directions: up, down, left, and right. Backtracking is commonly used to explore different paths until the destination is reached or all possible paths are exhausted.",
    "time": "Average: O(4^(m*n)), Worst: O(4^(m*n)), Best: O(1) (if the starting cell is the destination), where m and n are the dimensions of the maze.",
    "space": "O(m*n) (for the recursion stack in the worst-case scenario, and to store the solution path)",
    "code": "// C++ implementation of Rat in a Maze problem using backtracking\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a cell (x, y) is safe to move to\nbool isSafe(int x, int y, const vector<vector<int>>& maze, const vector<vector<int>>& sol)\n{\n    int n = maze.size();\n    return (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] == 1 && sol[x][y] == 0);\n}\n\n// Recursive function to solve the Rat in a Maze problem\nbool solveMazeUtil(const vector<vector<int>>& maze, int x, int y, vector<vector<int>>& sol)\n{\n    int n = maze.size();\n\n    // If (x, y) is the destination return true\n    if (x == n - 1 && y == n - 1 && maze[x][y] == 1)\n    {\n        sol[x][y] = 1;\n        return true;\n    }\n\n    // Check if maze[x][y] is valid\n    if (isSafe(x, y, maze, sol))\n    {\n        // Mark x, y as part of solution path\n        sol[x][y] = 1;\n\n        // Move forward in x direction\n        if (solveMazeUtil(maze, x + 1, y, sol))\n            return true;\n\n        // If moving in x direction doesn't give solution\n        // then Move forward in y direction\n        if (solveMazeUtil(maze, x, y + 1, sol))\n            return true;\n\n        // If none of the above movements work then BACKTRACK:\n        // Unmark x, y as part of solution path\n        sol[x][y] = 0;\n        return false;\n    }\n\n    return false;\n}\n\n// Function to solve the Rat in a Maze problem\nbool solveMaze(vector<vector<int>>& maze)\n{\n    int n = maze.size();\n    vector<vector<int>> sol(n, vector<int>(n, 0)); // Initialize solution matrix with all 0s\n\n    if (solveMazeUtil(maze, 0, 0, sol) == false)\n    {\n        cout << \"Solution doesn't exist\" << endl;\n        return false;\n    }\n\n    // Print the solution matrix\n    cout << \"Solution:\" << endl;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n            cout << \" \" << sol[i][j] << \" \";\n        cout << endl;\n    }\n    return true;\n}\n\nint main()\n{\n    vector<vector<int>> maze = {{\n        1, 0, 0, 0},\n        {1, 1, 0, 1},\n        {0, 1, 0, 0},\n        {1, 1, 1, 1\n    }};\n\n    solveMaze(maze);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=wGbuDUtRMEs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/2z2c5t1/"
      ]
    ]
  },
  "m-coloring-problem": {
    "title": "M-Coloring Problem",
    "short": "The M-Coloring Problem is a graph coloring problem that asks whether the vertices of a given graph can be colored using at most 'M' distinct colors such that no two adjacent vertices have the same color. It's a classic NP-complete problem often solved using backtracking. The problem has applications in various domains like map coloring, register allocation in compilers, and job scheduling.",
    "time": "O(M^V)",
    "space": "O(V)",
    "code": "// C++ program for m-coloring problem\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if the current color assignment is safe\nbool isSafe(int v, vector<vector<bool>>& graph, vector<int>& color, int c) {\n    for (int i = 0; i < graph.size(); i++) {\n        if (graph[v][i] && c == color[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Recursive function to solve m-coloring problem using backtracking\nbool graphColoringUtil(vector<vector<bool>>& graph, int m, vector<int>& color, int v) {\n    // Base case: All vertices are assigned a color\n    if (v == graph.size()) {\n        return true;\n    }\n\n    // Try different colors for the current vertex\n    for (int c = 1; c <= m; c++) {\n        // Check if assigning color 'c' to vertex 'v' is safe\n        if (isSafe(v, graph, color, c)) {\n            color[v] = c;\n\n            // Recur to assign colors to the remaining vertices\n            if (graphColoringUtil(graph, m, color, v + 1)) {\n                return true;\n            }\n\n            // If assigning color 'c' doesn't lead to a solution, then remove it\n            color[v] = 0;\n        }\n    }\n\n    // If no color can be assigned to vertex 'v', then return false\n    return false;\n}\n\n// Function to solve m-coloring problem\nbool graphColoring(vector<vector<bool>>& graph, int m) {\n    int V = graph.size();\n    vector<int> color(V, 0); // Initialize all colors to 0\n\n    // Call the recursive utility function to solve m-coloring problem\n    if (graphColoringUtil(graph, m, color, 0)) {\n        cout << \"Solution Exists: Following are the assigned colors \\n\";\n        for (int i = 0; i < V; i++) {\n            cout << \"Vertex \" << i << \" -->  Color \" << color[i] << \"\\n\";\n        }\n        return true;\n    }\n\n    cout << \"Solution does not exist\\n\";\n    return false;\n}\n\n// Driver program to test above function\nint main() {\n    // Example graph represented as an adjacency matrix\n    vector<vector<bool>> graph = {\n        {0, 1, 1, 1},\n        {1, 0, 1, 0},\n        {1, 1, 0, 1},\n        {1, 0, 1, 0}\n    };\n    int m = 3; // Number of colors\n\n    // Function call\n    graphColoring(graph, m);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=05H0i1Wd4Ww"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  },
  "graph-algorithms": {
    "title": "Graph Algorithms",
    "short": "Graph algorithms are a set of computational procedures used to analyze and manipulate graphs, which are data structures consisting of nodes (vertices) connected by edges. These algorithms are used to solve various problems, such as finding the shortest path between two vertices, detecting cycles, and determining the connectivity of the graph. They are extensively used in network analysis, social network analysis, route planning, and many other fields where relationships between entities are important.",
    "time": "Varies significantly depending on the specific algorithm. Common algorithms include: BFS/DFS (O(V+E)), Dijkstra (O(E log V) using a priority queue), Bellman-Ford (O(V*E)), Floyd-Warshall (O(V^3)), Kruskal's (O(E log E) or O(E log V) using union-find), Prim's (O(E log V)).",
    "space": "Varies based on the graph representation (adjacency matrix or adjacency list) and the specific algorithm. Adjacency Matrix: O(V^2). Adjacency List: O(V+E). Many algorithms also require O(V) auxiliary space for things like visited sets or distance arrays.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\n// Structure to represent an edge in the graph\nstruct Edge {\n    int destination;\n    int weight;\n};\n\n// Function to perform Dijkstra's algorithm to find the shortest paths from a source vertex to all other vertices\nvector<int> dijkstra(const vector<vector<Edge>>& graph, int source) {\n    int numVertices = graph.size();\n    vector<int> distance(numVertices, numeric_limits<int>::max()); // Initialize distances to infinity\n    vector<bool> visited(numVertices, false);\n\n    distance[source] = 0; // Distance from source to itself is 0\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // Min-priority queue\n    pq.push({0, source}); // {distance, vertex}\n\n    while (!pq.empty()) {\n        int u = pq.top().second; // Vertex with the smallest distance\n        pq.pop();\n\n        if (visited[u]) continue; // Skip if already visited\n        visited[u] = true;\n\n        for (const Edge& edge : graph[u]) {\n            int v = edge.destination; // Neighboring vertex\n            int weight = edge.weight; // Weight of the edge\n\n            if (distance[u] != numeric_limits<int>::max() && distance[u] + weight < distance[v]) {\n                distance[v] = distance[u] + weight; // Update distance\n                pq.push({distance[v], v}); // Add to the priority queue\n            }\n        }\n    }\n\n    return distance;\n}\n\nint main() {\n    // Example Graph (Adjacency List Representation)\n    int numVertices = 6;  // Number of vertices in the graph\n    vector<vector<Edge>> graph(numVertices);\n\n    // Adding edges to the graph (u -> v, weight)\n    graph[0].push_back({1, 4});\n    graph[0].push_back({2, 2});\n    graph[1].push_back({2, 5});\n    graph[1].push_back({3, 10});\n    graph[2].push_back({4, 3});\n    graph[3].push_back({5, 11});\n    graph[4].push_back({3, 4});\n    graph[4].push_back({5, 1});\n\n    // Source vertex for Dijkstra's algorithm\n    int source = 0;\n\n    // Calculate shortest paths from source using Dijkstra's algorithm\n    vector<int> shortestDistances = dijkstra(graph, source);\n\n    // Print the shortest distances\n    cout << \"Shortest distances from vertex \" << source << \":\" << endl;\n    for (int i = 0; i < numVertices; ++i) {\n        cout << \"Vertex \" << i << \": \";\n        if (shortestDistances[i] == numeric_limits<int>::max()) {\n            cout << \"Infinity\" << endl;\n        } else {\n            cout << shortestDistances[i] << endl;\n        }\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=tKuo9dQc3l4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  },
  "graph-representations": {
    "title": "Graph Representations",
    "short": "Graph representations are ways to encode graphs for efficient manipulation and analysis within a computer program. They are fundamental to algorithms dealing with networks, relationships, and connectivity. Common representations include Adjacency Matrices, which use a matrix to indicate the presence of edges between vertices, and Adjacency Lists, which use a list to store the neighbors of each vertex, offering different trade-offs in space and time complexity depending on the graph's density.",
    "time": "Adjacency Matrix: Access/Check Edge: O(1), Add Edge: O(1), Remove Edge: O(1), Iterate Neighbors: O(V). Adjacency List: Access/Check Edge: O(V) (worst case), Add Edge: O(1), Remove Edge: O(V), Iterate Neighbors: O(degree(V))",
    "space": "Adjacency Matrix: O(V^2), Adjacency List: O(V + E)",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\n// Adjacency Matrix representation\nclass GraphMatrix {\nprivate:\n    int numVertices;\n    vector<vector<int>> adjMatrix;\n\npublic:\n    GraphMatrix(int vertices) : numVertices(vertices), adjMatrix(vertices, vector<int>(vertices, 0)) {}\n\n    void addEdge(int u, int v) {\n        // Assuming an undirected graph\n        adjMatrix[u][v] = 1;\n        adjMatrix[v][u] = 1;\n    }\n\n    void removeEdge(int u, int v) {\n        adjMatrix[u][v] = 0;\n        adjMatrix[v][u] = 0;\n    }\n\n    bool hasEdge(int u, int v) {\n        return adjMatrix[u][v] == 1;\n    }\n\n    void printGraph() {\n        cout << \"Adjacency Matrix:\" << endl;\n        for (int i = 0; i < numVertices; ++i) {\n            for (int j = 0; j < numVertices; ++j) {\n                cout << adjMatrix[i][j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\n// Adjacency List representation\nclass GraphList {\nprivate:\n    int numVertices;\n    vector<list<int>> adjList;\n\npublic:\n    GraphList(int vertices) : numVertices(vertices), adjList(vertices) {}\n\n    void addEdge(int u, int v) {\n        // Assuming an undirected graph\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n\n    void removeEdge(int u, int v) {\n        adjList[u].remove(v);\n        adjList[v].remove(u);\n    }\n\n    bool hasEdge(int u, int v) {\n        for (int neighbor : adjList[u]) {\n            if (neighbor == v) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void printGraph() {\n        cout << \"Adjacency List:\" << endl;\n        for (int i = 0; i < numVertices; ++i) {\n            cout << \"Vertex \" << i << \": \";\n            for (int neighbor : adjList[i]) {\n                cout << neighbor << \" -> \";\n            }\n            cout << \"nullptr\" << endl;\n        }\n    }\n};\n\nint main() {\n    // Example usage for Adjacency Matrix\n    GraphMatrix gm(5);\n    gm.addEdge(0, 1);\n    gm.addEdge(0, 4);\n    gm.addEdge(1, 2);\n    gm.addEdge(1, 3);\n    gm.addEdge(1, 4);\n    gm.addEdge(2, 3);\n    gm.addEdge(3, 4);\n    gm.printGraph();\n\n    // Example usage for Adjacency List\n    GraphList gl(5);\n    gl.addEdge(0, 1);\n    gl.addEdge(0, 4);\n    gl.addEdge(1, 2);\n    gl.addEdge(1, 3);\n    gl.addEdge(1, 4);\n    gl.addEdge(2, 3);\n    gl.addEdge(3, 4);\n    gl.printGraph();\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/graph-and-its-representations/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=gXEuZHg1Uc8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  },
  "bfs-and-dfs": {
    "title": "Breadth-First Search (BFS) and Depth-First Search (DFS)",
    "short": "BFS and DFS are graph traversal algorithms used to explore all reachable vertices from a given starting node. BFS explores the graph level by level, using a queue to visit all neighbors of a node before moving to the next level. DFS explores as far as possible along each branch before backtracking, utilizing a stack (implicitly through recursion or explicitly). These algorithms are fundamental in pathfinding, connectivity analysis, and many other graph-related problems.",
    "time": "O(V + E) for average, best, and worst cases, where V is the number of vertices and E is the number of edges.",
    "space": "BFS: O(W), where W is the maximum width of the graph. DFS: O(H), where H is the maximum depth of the graph (in the worst case, can be O(V)).",
    "code": "// C++ implementation of BFS and DFS for graph traversal\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n// Adjacency list representation of the graph\nvector<vector<int>> adj;\nvector<bool> visited;\n\n// BFS traversal\nvoid bfs(int start_node) {\n  queue<int> q;\n  visited.assign(adj.size(), false);\n\n  q.push(start_node);\n  visited[start_node] = true;\n\n  cout << \"BFS Traversal: \";\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    cout << u << \" \";\n\n    for (int v : adj[u]) {\n      if (!visited[v]) {\n        visited[v] = true;\n        q.push(v);\n      }\n    }\n  }\n  cout << endl;\n}\n\n// DFS traversal (recursive)\nvoid dfs(int u) {\n  visited[u] = true;\n  cout << u << \" \";\n\n  for (int v : adj[u]) {\n    if (!visited[v]) {\n      dfs(v);\n    }\n  }\n}\n\n// DFS traversal (iterative)\nvoid iterative_dfs(int start_node) {\n  stack<int> s;\n  visited.assign(adj.size(), false);\n\n  s.push(start_node);\n\n  cout << \"Iterative DFS Traversal: \";\n  while (!s.empty()) {\n    int u = s.top();\n    s.pop();\n\n    if (!visited[u]) {\n      cout << u << \" \";\n      visited[u] = true;\n    }\n\n    // Push neighbors in reverse order to maintain the order of traversal\n    for (int i = adj[u].size() - 1; i >= 0; --i) {\n      int v = adj[u][i];\n      if (!visited[v]) {\n        s.push(v);\n      }\n    }\n  }\n  cout << endl;\n}\n\nint main() {\n  int num_vertices = 6;\n  adj.resize(num_vertices);\n\n  // Example graph (adjacency list)\n  adj[0] = {1, 2};\n  adj[1] = {0, 3, 4};\n  adj[2] = {0, 4};\n  adj[3] = {1, 5};\n  adj[4] = {1, 2, 5};\n  adj[5] = {3, 4};\n\n  // Perform BFS starting from vertex 0\n  bfs(0);\n\n  // Perform DFS starting from vertex 0\n  visited.assign(adj.size(), false);\n  cout << \"Recursive DFS Traversal: \";\n  dfs(0);\n  cout << endl;\n\n  // Perform iterative DFS starting from vertex 0\n  iterative_dfs(0);\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=QrJdfX4gJXM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/breadth-first-search/"
      ]
    ]
  },
  "minimum-spanning-tree": {
    "title": "Minimum Spanning Tree (MST)",
    "short": "A Minimum Spanning Tree (MST) is a subgraph of a connected, weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.  MST algorithms aim to find this subgraph.  Common applications include network design (e.g., connecting computers with the least amount of cable) and clustering problems.",
    "time": "Kruskal's Algorithm: O(E log E) or O(E log V) (E is the number of edges, V is the number of vertices) due to sorting edges; Prim's Algorithm: O(E + V log V) with a good implementation using a priority queue.",
    "space": "O(V) (for storing the MST itself and auxiliary data structures like parent arrays or priority queues)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an edge in the graph\nstruct Edge {\n    int src, dest, weight;\n};\n\n// Function to find the parent of a node in the disjoint-set data structure\nint find(vector<int>& parent, int i) {\n    if (parent[i] == i)\n        return i;\n    return parent[i] = find(parent, parent[i]); // Path compression\n}\n\n// Function to perform union of two sets\nvoid unionSets(vector<int>& parent, vector<int>& rank, int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n\n    // Attach smaller rank tree under root of high rank tree\n    // (Union by Rank)\n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\n// Kruskal's algorithm to find the Minimum Spanning Tree\nvector<Edge> kruskalMST(vector<Edge>& edges, int numVertices) {\n    vector<Edge> mst;\n    // Sort edges by weight in ascending order\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n        return a.weight < b.weight;\n    });\n\n    // Initialize disjoint-set data structure\n    vector<int> parent(numVertices);\n    vector<int> rank(numVertices, 0);\n    for (int i = 0; i < numVertices; i++)\n        parent[i] = i;\n\n    // Iterate through sorted edges\n    for (const Edge& edge : edges) {\n        int rootSrc = find(parent, edge.src);\n        int rootDest = find(parent, edge.dest);\n\n        // If including this edge doesn't cause a cycle, include it in MST\n        if (rootSrc != rootDest) {\n            mst.push_back(edge);\n            unionSets(parent, rank, rootSrc, rootDest);\n        }\n    }\n\n    return mst;\n}\n\nint main() {\n    int numVertices = 4;\n    vector<Edge> edges = {\n        {0, 1, 10},\n        {0, 2, 6},\n        {0, 3, 5},\n        {1, 3, 15},\n        {2, 3, 4}\n    };\n\n    vector<Edge> mst = kruskalMST(edges, numVertices);\n\n    cout << \"Edges in MST:\\n\";\n    int totalWeight = 0;\n    for (const Edge& edge : mst) {\n        cout << edge.src << \" - \" << edge.dest << \" : \" << edge.weight << endl;\n        totalWeight += edge.weight;\n    }\n\n    cout << \"Total weight of MST: \" << totalWeight << endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=fAuF0EuZlUc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/minimum-spanning-tree/"
      ]
    ]
  },
  "bellman-ford": {
    "title": "Bellman-Ford Algorithm",
    "short": "The Bellman-Ford algorithm is used to find the shortest paths from a single source vertex to all other vertices in a weighted graph, even when the graph contains edges with negative weights. It works by iteratively relaxing the edges of the graph, updating distance estimates until they converge to the shortest path lengths or a negative cycle is detected. Unlike Dijkstra's algorithm, Bellman-Ford can handle negative edge weights, making it suitable for a wider range of applications.",
    "time": "Average: N/A (iterative algorithm); Best: O(E) (if no relaxation occurs after the first iteration); Worst: O(V*E), where V is the number of vertices and E is the number of edges.",
    "space": "O(V), where V is the number of vertices (for storing distances).",
    "code": "// A C++ program for Bellman-Ford's single source shortest path algorithm.\n#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\n// Structure to represent an edge in the graph\nstruct Edge {\n    int src, dest, weight;\n};\n\n// Function to implement Bellman-Ford algorithm\nvoid bellmanFord(int V, int E, vector<Edge>& edges, int src) {\n    // Initialize distances from the source to all other vertices as infinite\n    vector<int> dist(V, numeric_limits<int>::max());\n    dist[src] = 0;\n\n    // Relax all edges |V| - 1 times. A simple shortest path from src to any other\n    // vertex can have at-most |V| - 1 edges\n    for (int i = 1; i <= V - 1; i++) {\n        for (int j = 0; j < E; j++) {\n            int u = edges[j].src;\n            int v = edges[j].dest;\n            int weight = edges[j].weight;\n            if (dist[u] != numeric_limits<int>::max() && dist[u] + weight < dist[v])\n                dist[v] = dist[u] + weight;\n        }\n    }\n\n    // Check for negative-weight cycles.  The above step guarantees shortest distances\n    // if graph doesn't contain negative weight cycle.  If we get a shorter\n    // path, then there is a cycle.\n    for (int j = 0; j < E; j++) {\n        int u = edges[j].src;\n        int v = edges[j].dest;\n        int weight = edges[j].weight;\n        if (dist[u] != numeric_limits<int>::max() && dist[u] + weight < dist[v]) {\n            cout << \"Graph contains negative weight cycle\" << endl;\n            return;\n        }\n    }\n\n    cout << \"Vertex   Distance from Source\" << endl;\n    for (int i = 0; i < V; i++)\n        cout << i << \"\\t\\t\" << dist[i] << endl;\n}\n\n// Driver program to test above function\nint main() {\n    int V = 5;  // Number of vertices in graph\n    int E = 8;  // Number of edges in graph\n\n    vector<Edge> edges(E);\n\n    // Example graph (edges with weights)\n    edges[0] = {0, 1, -1};\n    edges[1] = {0, 2, 4};\n    edges[2] = {1, 2, 3};\n    edges[3] = {1, 3, 2};\n    edges[4] = {1, 4, 2};\n    edges[5] = {3, 2, 5};\n    edges[6] = {3, 1, 1};\n    edges[7] = {4, 3, -3};\n\n    bellmanFord(V, E, edges, 0); // Source vertex is 0\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/bellman-ford-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=rt_PqMDm-0Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/bellman-ford/"
      ]
    ]
  },
  "floyd-warshall": {
    "title": "Floyd-Warshall Algorithm",
    "short": "The Floyd-Warshall algorithm is a dynamic programming algorithm used to find the shortest paths between all pairs of vertices in a weighted graph. It works by iteratively considering each vertex as an intermediate node in a potential shortest path. This allows it to handle graphs with positive or negative edge weights (but not negative cycles), and efficiently computes all-pairs shortest paths in a single run.",
    "time": "O(V^3), where V is the number of vertices.",
    "space": "O(V^2)",
    "code": " #include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9; // Represents infinity (a large value indicating no path)\n\n/*\n * Floyd-Warshall algorithm implementation to find the shortest paths between all pairs of vertices.\n * \n * @param graph Adjacency matrix representing the graph. graph[i][j] is the weight of the edge from vertex i to vertex j.\n *              If there is no edge, graph[i][j] should be set to INF.\n * @param V Number of vertices in the graph.\n * \n * @return A matrix representing the shortest path distances between all pairs of vertices.\n */\nvector<vector<int>> floydWarshall(vector<vector<int>>& graph, int V) {\n    vector<vector<int>> dist = graph; // Initialize the distance matrix with the graph\n\n    // Iterate through all vertices as intermediate nodes\n    for (int k = 0; k < V; ++k) {\n        // Iterate through all vertices as source nodes\n        for (int i = 0; i < V; ++i) {\n            // Iterate through all vertices as destination nodes\n            for (int j = 0; j < V; ++j) {\n                // If vertex k provides a shorter path from i to j, update dist[i][j]\n                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n\n    // Check for negative cycles\n    for (int i = 0; i < V; ++i) {\n        if (dist[i][i] < 0) {\n            cout << \"Negative cycle detected!\" << endl;\n            return vector<vector<int>>(); // Return empty vector to signal error\n        }\n    }\n\n    return dist;\n}\n\nint main() {\n    int V = 4; // Number of vertices\n    vector<vector<int>> graph = {\n        {0,   5,   INF, 10},\n        {INF, 0,   3,   INF},\n        {INF, INF, 0,   1},\n        {INF, INF, INF, 0}\n    };\n\n    vector<vector<int>> shortestPaths = floydWarshall(graph, V);\n\n    if (!shortestPaths.empty()) {\n        cout << \"Shortest paths between all pairs of vertices:\" << endl;\n        for (int i = 0; i < V; ++i) {\n            for (int j = 0; j < V; ++j) {\n                if (shortestPaths[i][j] == INF) {\n                    cout << \"INF\\t\";\n                } else {\n                    cout << shortestPaths[i][j] << \"\\t\";\n                }\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/floyd-warshall-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=4OQeCuLYj-4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/floyd-warshall/"
      ]
    ]
  },
  "topological-sort": {
    "title": "Topological Sort",
    "short": "Topological sort is an algorithm used to order the vertices of a directed acyclic graph (DAG) such that for every directed edge from vertex A to vertex B, vertex A appears before vertex B in the ordering.  It essentially orders the vertices based on their dependencies. A common application is scheduling tasks where some tasks depend on others.",
    "time": "O(V + E), where V is the number of vertices and E is the number of edges.",
    "space": "O(V), primarily for storing the in-degree count and the result list.",
    "code": "// C++ program to implement Topological Sort\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to perform topological sort\nvector<int> topologicalSort(int V, vector<vector<int>>& adj) {\n    vector<int> in_degree(V, 0); // Array to store in-degrees of vertices\n\n    // Calculate in-degrees for each vertex\n    for (int u = 0; u < V; u++) {\n        for (int v : adj[u]) {\n            in_degree[v]++;\n        }\n    }\n\n    queue<int> q; // Queue to store vertices with in-degree 0\n\n    // Add vertices with in-degree 0 to the queue\n    for (int i = 0; i < V; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector<int> result; // Vector to store the topological order\n\n    int count = 0; // Count of visited vertices\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        result.push_back(u);\n\n        // Decrease in-degree of adjacent vertices\n        for (int v : adj[u]) {\n            if (--in_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n        count++;\n    }\n\n    // Check if there is a cycle.  If count != V, then there's a cycle\n    if (count != V) {\n        cout << \"Error: Graph contains a cycle! Topological sort not possible.\";\n        return {}; // Return an empty vector to indicate failure.\n    }\n\n    return result;\n}\n\nint main() {\n    int V = 6; // Number of vertices\n    vector<vector<int>> adj(V); // Adjacency list representation of the graph\n\n    // Example graph:\n    // 5 -> 2\n    // 5 -> 0\n    // 4 -> 0\n    // 4 -> 1\n    // 2 -> 3\n    // 3 -> 1\n\n    adj[5].push_back(2);\n    adj[5].push_back(0);\n    adj[4].push_back(0);\n    adj[4].push_back(1);\n    adj[2].push_back(3);\n    adj[3].push_back(1);\n\n    vector<int> sorted_order = topologicalSort(V, adj);\n\n    if (!sorted_order.empty()) {\n        cout << \"Topological Sort: \";\n        for (int node : sorted_order) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/topological-sorting/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=eL-K9EOGqTg"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/topological-sort/"
      ]
    ]
  },
  "articulation-points": {
    "title": "Articulation Points (Cut Vertices)",
    "short": "Articulation points, also known as cut vertices, are vertices in a connected, undirected graph that, when removed along with their incident edges, disconnect the graph into two or more connected components.  They are crucial for understanding the connectivity and robustness of a network. The identification of these points is often achieved using Depth-First Search (DFS) to analyze the 'discovery' and 'low-link' values of each node to detect points where removing the node would increase the number of connected components.",
    "time": "O(V + E), where V is the number of vertices and E is the number of edges.",
    "space": "O(V), where V is the number of vertices.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Graph {\npublic:\n    int V;\n    vector<vector<int>> adj;\n    vector<bool> visited;\n    vector<int> disc, low, parent;\n    vector<bool> ap; // articulation points\n\n    Graph(int V) : V(V), adj(V), visited(V, false), disc(V, -1), low(V, -1), parent(V, -1), ap(V, false) {}\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // A recursive function to find articulation points using DFS\n    void APUtil(int u, int &time) {\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        int children = 0;\n\n        // Go through all vertices adjacent to this\n        for (int v : adj[u]) {\n            // If v is not visited yet, then make it a child of u\n            // in DFS tree and recur for it\n            if (!visited[v]) {\n                children++;\n                parent[v] = u;\n                APUtil(v, time);\n\n                // Check if the subtree rooted with v has a connection to\n                // one of the ancestors of u\n                low[u] = min(low[u], low[v]);\n\n                // u is an articulation point in following cases\n\n                // (1) u is root of DFS tree and has two or more children.\n                if (parent[u] == -1 && children > 1)\n                    ap[u] = true;\n\n                // (2) If u is not root and low value of one of its child\n                // is more than discovery value of u.\n                if (parent[u] != -1 && low[v] >= disc[u])\n                    ap[u] = true;\n            }\n\n            // Update low value of u for parent function calls.\n            else if (v != parent[u])\n                low[u] = min(low[u], disc[v]);\n        }\n    }\n\n    // The main function that finds all articulation points.\n    void findAPs() {\n        int time = 0;\n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                APUtil(i, time);\n            }\n        }\n\n        cout << \"Articulation points are: \";\n        for (int i = 0; i < V; i++) {\n            if (ap[i]) {\n                cout << i << \" \";\n            }\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    // Create a sample graph\n    Graph g1(5);\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.findAPs(); // Output: Articulation points are: 0 3\n\n    Graph g2(4);\n    g2.addEdge(0, 1);\n    g2.addEdge(1, 2);\n    g2.addEdge(2, 3);\n    g2.findAPs(); // Output: Articulation points are: 1 2\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=2eB-K5yZXWI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/articulation-point/"
      ]
    ]
  },
  "strongly-connected-components": {
    "title": "Strongly Connected Components (SCC)",
    "short": "A strongly connected component (SCC) of a directed graph is a subgraph in which every vertex is reachable from every other vertex. Finding SCCs is crucial for understanding the structure of directed graphs and has applications in network analysis, compiler design, and data mining. The common algorithms for finding SCCs, like Kosaraju's and Tarjan's algorithm, efficiently identify these components by traversing the graph and exploiting properties of depth-first search.",
    "time": "O(V+E) for Kosaraju's and Tarjan's algorithms, where V is the number of vertices and E is the number of edges.",
    "space": "O(V) for storing visited nodes, stack, and recursion stack.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\n// Function to add an edge to the graph\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n}\n\n// Depth-First Search (DFS) function to populate the stack with vertices in finishing order\nvoid dfs1(vector<vector<int>>& adj, int v, vector<bool>& visited, stack<int>& st) {\n    visited[v] = true;\n\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs1(adj, adj[v][0], visited, st);\n        }\n    }\n    st.push(v);\n}\n\n// Function to get the transpose of the graph\nvector<vector<int>> getTranspose(vector<vector<int>>& adj, int V) {\n    vector<vector<int>> transpose(V);\n    for (int i = 0; i < V; i++) {\n        for (int j : adj[i]) {\n            transpose[j].push_back(i);\n        }\n    }\n    return transpose;\n}\n\n// DFS function to find strongly connected components\nvoid dfs2(vector<vector<int>>& adj, int v, vector<bool>& visited) {\n    visited[v] = true;\n    cout << v << \" \";\n\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs2(adj, u, visited);\n        }\n    }\n}\n\n// Function to find and print strongly connected components using Kosaraju's algorithm\nvoid findSCCs(vector<vector<int>>& adj, int V) {\n    stack<int> st;\n    vector<bool> visited(V, false);\n\n    // Step 1: Populate the stack with vertices in finishing order\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            dfs1(adj, i, visited, st);\n        }\n    }\n\n    // Step 2: Get the transpose of the graph\n    vector<vector<int>> transpose = getTranspose(adj, V);\n\n    // Reset visited array\n    for (int i = 0; i < V; i++) {\n        visited[i] = false;\n    }\n\n    // Step 3: Process vertices in the order defined by the stack\n    while (!st.empty()) {\n        int v = st.top();\n        st.pop();\n\n        if (!visited[v]) {\n            dfs2(transpose, v, visited);\n            cout << endl;  // New line for each SCC\n        }\n    }\n}\n\nint main() {\n    int V = 5;  // Number of vertices\n    vector<vector<int>> adj(V);\n    addEdge(adj, 1, 0);\n    addEdge(adj, 0, 2);\n    addEdge(adj, 2, 1);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 3, 4);\n\n    cout << \"Strongly Connected Components:\\n\";\n    findSCCs(adj, V);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/strongly-connected-components/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=RpgcYiky7uw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/strongly-connected-component/"
      ]
    ]
  },
  "network-flow": {
    "title": "Network Flow (Maximum Flow)",
    "short": "Network flow algorithms solve the problem of finding the maximum amount of \"flow\" that can be sent from a source to a sink in a network, given edge capacities. The most common approach involves iteratively finding augmenting paths from source to sink and increasing the flow along these paths until no more augmenting paths exist. This has applications in various areas such as resource allocation, scheduling, and image segmentation.",
    "time": "O(V*E^2) for Edmonds-Karp, O(E*V^2) for Dinic's Algorithm, where V is the number of vertices and E is the number of edges.",
    "space": "O(V+E)",
    "code": "// C++ implementation of the Edmonds-Karp algorithm for Maximum Flow\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\n// Function to perform BFS to find an augmenting path\nbool bfs(vector<vector<int>>& graph, int s, int t, vector<int>& parent) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    parent[s] = -1;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v = 0; v < n; ++v) {\n            if (visited[v] == false && graph[u][v] > 0) {\n                if (v == t) {\n                    parent[v] = u;\n                    return true;\n                }\n                q.push(v);\n                parent[v] = u;\n                visited[v] = true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Edmonds-Karp algorithm to find the maximum flow\nint edmondsKarp(vector<vector<int>> graph, int s, int t) {\n    int n = graph.size();\n    vector<vector<int>> residualGraph = graph; // Create a residual graph\n    vector<int> parent(n);\n    int maxFlow = 0;\n\n    // Augment the flow while there is a path from source to sink\n    while (bfs(residualGraph, s, t, parent)) {\n        int pathFlow = INT_MAX;\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            pathFlow = min(pathFlow, residualGraph[u][v]);\n        }\n\n        // Update residual capacities of the edges and reverse edges along the path\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            residualGraph[u][v] -= pathFlow;\n            residualGraph[v][u] += pathFlow;\n        }\n\n        maxFlow += pathFlow;\n    }\n\n    return maxFlow;\n}\n\nint main() {\n    // Example graph represented as an adjacency matrix\n    vector<vector<int>> graph = {\n        {0, 16, 13, 0, 0, 0},\n        {0, 0, 10, 12, 0, 0},\n        {0, 4, 0, 0, 14, 0},\n        {0, 0, 9, 0, 0, 20},\n        {0, 0, 0, 7, 0, 4},\n        {0, 0, 0, 0, 0, 0}\n    };\n\n    int source = 0;  // Source node\n    int sink = 5;    // Sink node\n\n    cout << \"The maximum possible flow is \" << edmondsKarp(graph, source, sink) << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=GiN3jRdgxU4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/max-flow/"
      ]
    ]
  },
  "eulerian": {
    "title": "Eulerian Path and Circuit",
    "short": "An Eulerian path is a path in a graph that visits every edge exactly once. An Eulerian circuit is an Eulerian path that starts and ends at the same vertex. These paths and circuits exist in graphs that meet specific degree requirements. Eulerian paths and circuits are used in various applications, such as DNA sequencing and network routing.",
    "time": "O(E), where E is the number of edges. Finding the path itself is linear in the number of edges.",
    "space": "O(V + E), where V is the number of vertices and E is the number of edges. This accounts for the adjacency list representation of the graph and the stack used in the algorithm.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\n// Function to check if a graph is Eulerian\nbool isEulerian(const vector<vector<int>>& adj) {\n    int oddDegreeCount = 0;\n    for (const auto& neighbors : adj) {\n        if (neighbors.size() % 2 != 0) {\n            oddDegreeCount++;\n        }\n    }\n\n    if (oddDegreeCount > 2) {\n        return false; // More than 2 vertices with odd degree\n    } else if (oddDegreeCount == 2) {\n        return true; // Eulerian path exists\n    } else {\n        // Check if the graph is connected. If it is not connected,\n        // then there is no Eulerian path or circuit\n        if (adj.empty()) return true; //empty graph\n        int start_node = 0; \n        while(start_node < adj.size() && adj[start_node].empty()) start_node++;\n        if (start_node == adj.size()) return true; // No edges\n\n        vector<bool> visited(adj.size(), false);\n        stack<int> dfs_stack;\n        dfs_stack.push(start_node);\n        visited[start_node] = true;\n\n        while(!dfs_stack.empty()) {\n            int u = dfs_stack.top();\n            dfs_stack.pop();\n            for (int v : adj[u]) {\n                if(!visited[v]) {\n                    visited[v] = true;\n                    dfs_stack.push(v);\n                }\n            }\n        }\n\n        for(int i = 0; i < adj.size(); i++) {\n            if(!adj[i].empty() && !visited[i]) {\n                return false;\n            }\n        }\n\n        return true; // Eulerian circuit exists\n    }\n}\n\n// Function to find the Eulerian path/circuit using Hierholzer's Algorithm\nvector<int> findEulerianPath(vector<vector<int>> adj) {\n    if (!isEulerian(adj)) {\n        return {}; // No Eulerian path/circuit exists\n    }\n\n    int startNode = 0;\n    int oddDegreeCount = 0;\n    for(int i = 0; i < adj.size(); ++i) {\n        if(adj[i].size() % 2 != 0) {\n            startNode = i;\n            oddDegreeCount++;\n            break; //Start from a vertex with odd degree, if such a vertex exists.\n        }\n    }\n\n    stack<int> path;\n    vector<int> circuit;\n    path.push(startNode);\n\n    while (!path.empty()) {\n        int u = path.top();\n        if (!adj[u].empty()) {\n            int v = adj[u].back(); // Get the last neighbor of u\n            adj[u].pop_back();      // Remove the edge u-v\n            \n            //Remove u from v's adjacency list\n            for(int i = 0; i < adj[v].size(); ++i) {\n                if(adj[v][i] == u) {\n                    adj[v].erase(adj[v].begin() + i);\n                    break;\n                }\n            }\n            path.push(v);\n        } else {\n            circuit.push_back(u);\n            path.pop();\n        }\n    }\n    reverse(circuit.begin(), circuit.end());\n    return circuit;\n}\n\nint main() {\n    // Example graph represented as an adjacency list\n    vector<vector<int>> adj = {\n        {1, 2},\n        {0, 2, 2},\n        {0, 1, 1}\n    };\n\n    vector<int> eulerianPath = findEulerianPath(adj);\n\n    if (eulerianPath.empty()) {\n        cout << \"No Eulerian path/circuit exists.\\n\";\n    } else {\n        cout << \"Eulerian Path/Circuit: \";\n        for (int vertex : eulerianPath) {\n            cout << vertex << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/eulerian-path-and-circuit/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=w9bK0Yt-wus"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  },
  "pattern-matching": {
    "title": "Knuth-Morris-Pratt (KMP) Algorithm",
    "short": "The Knuth-Morris-Pratt (KMP) algorithm is a linear time string searching algorithm that efficiently finds occurrences of a pattern within a text. It avoids redundant comparisons by pre-processing the pattern to create a lookup table (the LPS array) that indicates the longest proper prefix of the pattern that is also a suffix. This pre-computed table allows the algorithm to shift the pattern more intelligently after a mismatch, leading to significant performance improvements compared to naive approaches.",
    "time": "Average: O(n+m), Best: O(n), Worst: O(n+m) where n is the length of the text and m is the length of the pattern.",
    "space": "O(m) where m is the length of the pattern (due to the LPS array).",
    "code": "// C++ implementation of the KMP algorithm\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the Longest Proper Prefix which is also a Suffix (LPS) array\nvector<int> computeLPSArray(const string& pattern) {\n    int m = pattern.length();\n    vector<int> lps(m, 0);\n    int len = 0; // Length of the previous longest prefix suffix\n    int i = 1;\n    lps[0] = 0; // lps[0] is always 0\n\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n// Function to implement the KMP algorithm\nvoid KMPSearch(const string& text, const string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n\n    vector<int> lps = computeLPSArray(pattern);\n\n    int i = 0; // index for text\n    int j = 0; // index for pattern\n\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            j++;\n            i++;\n        }\n\n        if (j == m) {\n            cout << \"Pattern found at index \" << i - j << endl;\n            j = lps[j - 1];\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n}\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n    KMPSearch(text, pattern);\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=GTJrB_wm_L0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/string/"
      ]
    ]
  },
  "kmp": {
    "title": "Knuth-Morris-Pratt (KMP) Algorithm",
    "short": "The Knuth-Morris-Pratt (KMP) algorithm is a string searching algorithm that efficiently finds occurrences of a pattern string within a larger text string. It avoids unnecessary comparisons by precomputing a prefix table (LPS table) for the pattern, which helps determine the next position to start searching from after a mismatch. This optimized approach leads to a linear time complexity, making it a preferred choice for many string matching tasks.",
    "time": "Search: Best: O(n), Average: O(n), Worst: O(n); Preprocessing (LPS Table): O(m), where n is the text length and m is the pattern length.",
    "space": "O(m), where m is the pattern length (due to the LPS table).",
    "code": " #include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to compute the longest proper prefix which is also a suffix (LPS) array\nvector<int> computeLPSArray(const string& pattern) {\n    int m = pattern.length();\n    vector<int> lps(m, 0); // Initialize LPS array with 0\n    int len = 0; // Length of the previous longest prefix suffix\n    int i = 1; // Index for pattern\n\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1]; // This is tricky. Consider the example AAACAAAA and i = 7\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n// Function to implement the KMP algorithm\nvector<int> KMPSearch(const string& text, const string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> lps = computeLPSArray(pattern); // Compute LPS array for the pattern\n    vector<int> occurrences; // Store the starting indices of occurrences\n\n    int i = 0; // Index for text\n    int j = 0; // Index for pattern\n\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n\n        if (j == m) {\n            occurrences.push_back(i - j); // Pattern found at index i-j\n            j = lps[j - 1]; // Prepare j for the next possible match\n        } else if (i < n && pattern[j] != text[i]) {\n            // Do not match lps[0..lps[j-1]] characters, they will match anyway\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return occurrences;\n}\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n\n    vector<int> occurrences = KMPSearch(text, pattern);\n\n    cout << \"Pattern found at indices: \";\n    for (int index : occurrences) {\n        cout << index << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=GTJrB_0WzGk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/string-matching/"
      ]
    ]
  },
  "rabin-karp": {
    "title": "Rabin-Karp Algorithm",
    "short": "The Rabin-Karp algorithm is a string searching algorithm that uses hashing to find any one of a set of pattern strings in a text. It works by computing a hash value for the pattern and then for each substring of the text of the same length. If the hash values match, a character-by-character comparison is performed to verify the match, thus significantly reducing the number of character comparisons needed.",
    "time": {
      "average": "O(n + m)",
      "best": "O(n + m)",
      "worst": "O(n * m)"
    },
    "space": "O(1)",
    "code": " #include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to implement the Rabin-Karp Algorithm\nvector<int> rabinKarp(const string& text, const string& pattern, int prime = 101) {\n    vector<int> occurrences;\n    int n = text.length();\n    int m = pattern.length();\n\n    // Basic error handling: Pattern can't be longer than text\n    if (m > n) {\n        return occurrences; // Return empty vector if pattern is longer than text\n    }\n\n    // Compute the hash value of the pattern\n    long long patternHash = 0;\n    for (int i = 0; i < m; i++) {\n        patternHash = (patternHash * prime + pattern[i]) % INT_MAX; // Use INT_MAX to prevent overflow\n    }\n\n    // Compute the hash value of the first substring of the text\n    long long textHash = 0;\n    for (int i = 0; i < m; i++) {\n        textHash = (textHash * prime + text[i]) % INT_MAX;\n    }\n\n    // Slide the pattern over the text\n    for (int i = 0; i <= n - m; i++) {\n        // If the hash values match, check for a true match\n        if (patternHash == textHash) {\n            bool match = true;\n            for (int j = 0; j < m; j++) {\n                if (text[i + j] != pattern[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                occurrences.push_back(i);\n            }\n        }\n\n        // Compute the hash value of the next substring of the text\n        if (i < n - m) {\n            textHash = (textHash - text[i] * pow(prime, m - 1)) % INT_MAX; // Remove leading digit\n            textHash = (textHash * prime + text[i + m]) % INT_MAX; // Add trailing digit\n            if (textHash < 0) {\n               textHash += INT_MAX; // Ensure the hash value is positive.\n            }\n        }\n    }\n\n    return occurrences;\n}\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n\n    vector<int> occurrences = rabinKarp(text, pattern);\n\n    if (occurrences.empty()) {\n        cout << \"Pattern not found in text.\" << endl;\n    } else {\n        cout << \"Pattern found at index/indices: \";\n        for (int index : occurrences) {\n            cout << index << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=QzW66wVbm38"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/rabin-karp/"
      ]
    ]
  },
  "z-algorithm": {
    "title": "Z Algorithm",
    "short": "The Z Algorithm is a linear time string searching algorithm used to find all occurrences of a pattern in a text. It constructs a Z array, where Z[i] stores the length of the longest substring starting at index i of the string that matches the prefix of the string. This array is then used to efficiently locate instances of the pattern within the text by concatenating the pattern and the text, separated by a unique delimiter.",
    "time": "Construction: O(n), Search: O(n)",
    "space": "O(n)",
    "code": "// C++ implementation of Z algorithm\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to compute the Z array\nvector<int> computeZArray(const string& str) {\n    int n = str.length();\n    vector<int> Z(n, 0);\n    int left = 0, right = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if (i > right) {\n            // Case 1: i is outside the Z-box\n            left = right = i;\n            while (right < n && str[right - left] == str[right]) {\n                right++;\n            }\n            Z[i] = right - left;\n            right--;\n        } else {\n            // Case 2: i is inside the Z-box\n            int k = i - left;\n            if (Z[k] < right - i + 1) {\n                // Case 2a: Z[k] is contained within the Z-box\n                Z[i] = Z[k];\n            } else {\n                // Case 2b: Z[k] extends beyond the Z-box\n                left = i;\n                while (right < n && str[right - left] == str[right]) {\n                    right++;\n                }\n                Z[i] = right - left;\n                right--;\n            }\n        }\n    }\n    return Z;\n}\n\n// Function to search for a pattern in a text using Z algorithm\nvoid searchPattern(const string& text, const string& pattern) {\n    string combinedString = pattern + \"$\" + text; // Concatenate pattern and text with a delimiter\n    int n = combinedString.length();\n    vector<int> Z = computeZArray(combinedString);\n\n    for (int i = 0; i < n; ++i) {\n        if (Z[i] == pattern.length()) {\n            cout << \"Pattern found at index \" << i - pattern.length() - 1 << endl;\n        }\n    }\n}\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n\n    cout << \"Searching for pattern '\" << pattern << \"' in text '\" << text << \"'\" << endl;\n    searchPattern(text, pattern);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=JoF0Z7iCQVA"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/zwppj0c/"
      ]
    ]
  },
  "basic-operations": {
    "title": "Basic Array Operations",
    "short": "Basic array operations encompass fundamental actions performed on arrays, such as accessing, searching, inserting, and deleting elements. Arrays provide direct access to elements via their index, making access a fast operation. However, inserting or deleting elements in the middle of an array often requires shifting other elements, which can be time-consuming. Arrays are widely used as a foundational data structure in various algorithms and programming tasks.",
    "time": {
      "Access": "O(1) (Average, Best, Worst)",
      "Search": "O(n) (Average, Worst), O(1) (Best) - if the element is at the beginning or if we know the index",
      "Insertion": "O(n) (Average, Worst), O(1) (Best) - if inserting at the end when enough space is available",
      "Deletion": "O(n) (Average, Worst), O(1) (Best) - if deleting from the end"
    },
    "space": "O(n) where n is the size of the array",
    "code": "// Basic Array Operations in C++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    // 1. Array Initialization\n    vector<int> myArray = {10, 20, 30, 40, 50};\n\n    // 2. Accessing an element (O(1))\n    int elementAtIndex2 = myArray[2];\n    cout << \"Element at index 2: \" << elementAtIndex2 << endl;\n\n    // 3. Modifying an element (O(1))\n    myArray[1] = 25;\n    cout << \"Modified array: \";\n    for (int num : myArray) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // 4. Searching for an element (O(n))\n    int searchElement = 40;\n    int index = -1;\n    for (int i = 0; i < myArray.size(); ++i) {\n        if (myArray[i] == searchElement) {\n            index = i;\n            break;\n        }\n    }\n\n    if (index != -1) {\n        cout << \"Element \" << searchElement << \" found at index: \" << index << endl;\n    } else {\n        cout << \"Element \" << searchElement << \" not found in the array.\" << endl;\n    }\n\n    // 5. Inserting an element at the end (O(1) amortized, O(n) if reallocation needed) - vector handles reallocation\n    myArray.push_back(60);\n    cout << \"Array after insertion at the end: \";\n    for (int num : myArray) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // 6. Inserting an element at a specific index (O(n))\n    myArray.insert(myArray.begin() + 3, 35); // Inserts 35 at index 3, shifting elements to the right\n    cout << \"Array after insertion at index 3: \";\n    for (int num : myArray) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // 7. Deleting an element from the end (O(1))\n    myArray.pop_back();\n    cout << \"Array after deletion from the end: \";\n    for (int num : myArray) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // 8. Deleting an element from a specific index (O(n))\n    myArray.erase(myArray.begin() + 2); // Deletes element at index 2, shifting elements to the left\n    cout << \"Array after deletion at index 2: \";\n    for (int num : myArray) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // 9. Array Size\n    cout << \"Current size of the array: \" << myArray.size() << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/array-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=D97hZwP-Pzg"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/array/"
      ]
    ]
  },
  "set": {
    "title": "Set (Data Structure)",
    "short": "A set is an abstract data type that stores unordered collections of distinct elements. It provides efficient membership testing (checking if an element is present) and allows for common set operations like union, intersection, and difference. Sets are commonly implemented using hash tables (unordered sets) or balanced binary search trees (ordered sets), enabling fast lookups and maintaining uniqueness of elements.",
    "time": "Average: Access - N/A, Search - O(1), Insertion - O(1), Deletion - O(1); Worst: Access - N/A, Search - O(n), Insertion - O(n), Deletion - O(n) (for hash tables with collisions or tree-based implementations requiring rebalancing)",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <unordered_set>\n#include <set>\n\nusing namespace std;\n\nint main() {\n  // Example using unordered_set (hash table implementation)\n  unordered_set<int> myUnorderedSet;\n\n  // Insertion\n  myUnorderedSet.insert(10);\n  myUnorderedSet.insert(20);\n  myUnorderedSet.insert(30);\n  myUnorderedSet.insert(20); // Duplicate insertion is ignored\n\n  cout << \"Unordered Set contents: \";\n  for (int element : myUnorderedSet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  // Searching\n  if (myUnorderedSet.count(20) > 0) {\n    cout << \"20 is present in the unordered set\" << endl;\n  } else {\n    cout << \"20 is not present in the unordered set\" << endl;\n  }\n\n  // Deletion\n  myUnorderedSet.erase(20);\n\n  cout << \"Unordered Set contents after erasing 20: \";\n  for (int element : myUnorderedSet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n\n  // Example using set (tree-based implementation - usually a red-black tree)\n  set<int> mySet;\n\n  // Insertion\n  mySet.insert(10);\n  mySet.insert(20);\n  mySet.insert(30);\n  mySet.insert(20); // Duplicate insertion is ignored\n\n  cout << \"Set contents (ordered): \";\n  for (int element : mySet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  // Searching\n  if (mySet.count(20) > 0) {\n    cout << \"20 is present in the set\" << endl;\n  } else {\n    cout << \"20 is not present in the set\" << endl;\n  }\n\n  // Deletion\n  mySet.erase(20);\n\n  cout << \"Set contents after erasing 20: \";\n  for (int element : mySet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/set-in-cpp-stl/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=K86x0Lz8E_w"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/set/"
      ]
    ]
  },
  "counting-set-bits": {
    "title": "Counting Set Bits",
    "short": "Counting set bits (also known as population count) involves determining the number of bits that are set to 1 in a binary representation of an integer.  Efficient algorithms can avoid iterating through every bit. This operation is used in various applications, including cryptography, information theory, and error correction codes.",
    "time": "O(1) to O(log n) depending on the method used, where n is the number.",
    "space": "O(1)",
    "code": "// C++ program to count set bits in an integer using different methods\n#include <iostream>\n#include <algorithm> // For std::bitset (if needed for alternative approach)\n\n// 1. Naive Approach: Iterate through bits\n// Time Complexity: O(log n), where n is the number.  Each bit is checked.\n// Space Complexity: O(1)\nunsigned int countSetBitsNaive(unsigned int n) {\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1; // Check the last bit\n        n >>= 1;      // Right shift to check the next bit\n    }\n    return count;\n}\n\n// 2. Brian Kernighan's Algorithm\n// Time Complexity: O(number of set bits)\n// Space Complexity: O(1)\nunsigned int countSetBitsBrianKernighan(unsigned int n) {\n    unsigned int count = 0;\n    while (n) {\n        n &= (n - 1); // Unsets the rightmost set bit\n        count++;\n    }\n    return count;\n}\n\n// 3. Lookup Table Method (for smaller numbers - e.g., 8-bit integers)\n// This requires pre-computation and is more suited when counting set bits repeatedly.\n// Time Complexity: O(1) after precomputation\n// Space Complexity: O(size of the table)\n\n// Example with an 8-bit lookup table:\nunsigned int setBitLookup[256];\n\nvoid initializeLookupTable() {\n    for (int i = 0; i < 256; i++) {\n        setBitLookup[i] = countSetBitsNaive(i); // Initialize using the naive method\n    }\n}\n\nunsigned int countSetBitsLookup(unsigned int n) {\n    // This method is efficient for smaller numbers, as it performs array lookups.\n    // For larger numbers, you'd need to split into bytes and sum the lookups.\n    unsigned char byte1 = n & 0xFF;  // Extract the least significant byte\n    unsigned char byte2 = (n >> 8) & 0xFF; // Extract the next byte\n    unsigned char byte3 = (n >> 16) & 0xFF; // Extract the next byte\n    unsigned char byte4 = (n >> 24) & 0xFF; // Extract the most significant byte\n    return setBitLookup[byte1] + setBitLookup[byte2] + setBitLookup[byte3] + setBitLookup[byte4];\n}\n\n\n// 4. Using built-in __builtin_popcount() (GCC specific)\n// Time Complexity: O(1) - generally uses hardware instructions if available\n// Space Complexity: O(1)\n#ifdef __GNUC__ // Check if it's a GCC compiler\nunsigned int countSetBitsBuiltin(unsigned int n) {\n    return __builtin_popcount(n); // Requires GCC compiler\n}\n#endif\n\n\nint main() {\n    unsigned int num = 7; // Example number\n\n    std::cout << \"Number: \" << num << std::endl;\n\n    std::cout << \"Naive Approach: \" << countSetBitsNaive(num) << std::endl;\n    std::cout << \"Brian Kernighan's Algorithm: \" << countSetBitsBrianKernighan(num) << std::endl;\n\n    // Example using Lookup Table:\n    initializeLookupTable(); // Must be called before using countSetBitsLookup\n    std::cout << \"Lookup Table Approach: \" << countSetBitsLookup(num) << std::endl;\n\n#ifdef __GNUC__\n    std::cout << \"Built-in Approach: \" << countSetBitsBuiltin(num) << std::endl;\n#endif\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=KJQrZ9l4imQ"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/bit-manipulation/"
      ]
    ]
  },
  "bitmask-dp": {
    "title": "Bitmask Dynamic Programming",
    "short": "Bitmask Dynamic Programming is a technique used to solve problems where the state of the DP can be represented as a bitmask. A bitmask is an integer where each bit represents the presence or absence of a specific element. This technique is particularly useful for problems involving sets, subsets, or permutations, especially when the size of the input is limited, allowing the number of possible states (2^n) to be manageable.",
    "time": "Often O(n * 2^n) or O(2^n * 2^m), where n and m are related to the size of the bitmask.",
    "space": "O(2^n)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the minimum cost to visit all cities exactly once.\n// This is a simplified version of the Traveling Salesman Problem (TSP).\n\nint tsp(int mask, int pos, vector<vector<int>>& dist, vector<vector<int>>& dp, int n) {\n  // Base case: All cities have been visited\n  if (mask == (1 << n) - 1) {\n    return dist[pos][0]; // Return to the starting city (city 0)\n  }\n\n  // If the result is already calculated, return it\n  if (dp[mask][pos] != -1) {\n    return dp[mask][pos];\n  }\n\n  int ans = INT_MAX;\n\n  // Try to visit all unvisited cities\n  for (int city = 0; city < n; city++) {\n    // If the city is not visited\n    if ((mask & (1 << city)) == 0) {\n      int newAns = dist[pos][city] + tsp(mask | (1 << city), city, dist, dp, n);\n      ans = min(ans, newAns);\n    }\n  }\n\n  // Store the result in the dp table and return it\n  return dp[mask][pos] = ans;\n}\n\nint main() {\n  int n = 4; // Number of cities\n\n  // dist[i][j] is the distance from city i to city j\n  vector<vector<int>> dist = {\n    {0, 10, 15, 20},\n    {10, 0, 35, 25},\n    {15, 35, 0, 30},\n    {20, 25, 30, 0}\n  };\n\n  // dp[mask][pos] stores the minimum cost to visit all cities represented by the mask,\n  // starting from the city at position 'pos'.\n  vector<vector<int>> dp((1 << n), vector<int>(n, -1));\n\n  // Call the TSP function starting from city 0 with an initial mask of 1 (city 0 visited).\n  cout << \"Minimum cost to visit all cities: \" << tsp(1, 0, dist, dp, n) << endl;\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-tsp/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=4fQG_3xmc2g"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/bitmask/"
      ]
    ]
  },
  "tree": {
    "title": "Tree Data Structure",
    "short": "A tree is a hierarchical data structure consisting of nodes connected by edges. It has a root node and zero or more subtrees, each of which is also a tree. Trees are commonly used to represent hierarchical relationships, organize data in a structured manner, and facilitate efficient searching and sorting, such as in file systems, organizational charts, and decision trees.",
    "time": {
      "Access": "O(n) (worst case, skewed tree), O(log n) (average case, balanced tree)",
      "Search": "O(n) (worst case, skewed tree), O(log n) (average case, balanced tree)",
      "Insertion": "O(n) (worst case, skewed tree), O(log n) (average case, balanced tree)",
      "Deletion": "O(n) (worst case, skewed tree), O(log n) (average case, balanced tree)"
    },
    "space": "O(n)",
    "code": " #include <iostream>\n#include <queue>\n\n// Define a structure for a tree node\nstruct TreeNode {\n    int data;\n    TreeNode* left;\n    TreeNode* right;\n\n    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nclass BinaryTree {\npublic:\n    TreeNode* root;\n\n    BinaryTree() : root(nullptr) {}\n\n    // Function to insert a node into the tree (iterative level order insertion)\n    void insert(int data) {\n        TreeNode* newNode = new TreeNode(data);\n        if (!root) {\n            root = newNode;\n            return;\n        }\n\n        std::queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            TreeNode* current = q.front();\n            q.pop();\n\n            if (!current->left) {\n                current->left = newNode;\n                return;\n            } else {\n                q.push(current->left);\n            }\n\n            if (!current->right) {\n                current->right = newNode;\n                return;\n            } else {\n                q.push(current->right);\n            }\n        }\n    }\n\n    // Function to perform an inorder traversal of the tree\n    void inorderTraversal(TreeNode* node) {\n        if (node) {\n            inorderTraversal(node->left);\n            std::cout << node->data << \" \";\n            inorderTraversal(node->right);\n        }\n    }\n\n    // Function to search for a node in the tree (simple recursive search)\n    TreeNode* search(TreeNode* node, int key) {\n        if (node == nullptr || node->data == key) {\n            return node;\n        }\n\n        TreeNode* leftResult = search(node->left, key);\n        if (leftResult != nullptr) return leftResult;\n\n        return search(node->right, key);\n    }\n\n};\n\nint main() {\n    // Create a binary tree\n    BinaryTree tree;\n\n    // Insert some nodes\n    tree.insert(1);\n    tree.insert(2);\n    tree.insert(3);\n    tree.insert(4);\n    tree.insert(5);\n    tree.insert(6);\n\n    // Perform inorder traversal\n    std::cout << \"Inorder Traversal: \";\n    tree.inorderTraversal(tree.root);\n    std::cout << std::endl;\n\n    // Search for a node\n    int searchKey = 4;\n    TreeNode* foundNode = tree.search(tree.root, searchKey);\n    if (foundNode) {\n        std::cout << \"Node with data \" << searchKey << \" found.\" << std::endl;\n    } else {\n        std::cout << \"Node with data \" << searchKey << \" not found.\" << std::endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/tree-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=oSWTXtMgl90"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/tree/"
      ]
    ]
  },
  "inorder": {
    "title": "Inorder Traversal of a Binary Tree",
    "short": "Inorder traversal is a tree traversal algorithm that visits the left subtree, then the root node, and finally the right subtree. This results in visiting the nodes of a binary search tree (BST) in ascending order. It's primarily used for printing nodes in sorted order in BSTs and for evaluating expressions represented as expression trees.",
    "time": "Average/Best/Worst: O(n), where n is the number of nodes in the tree.",
    "space": "O(h), where h is the height of the tree (worst case O(n) for a skewed tree, best/average case O(log n) for a balanced tree). This is due to the call stack during recursion.",
    "code": " #include <iostream>\n#include <stack>\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(int data) : data(data), left(nullptr), right(nullptr) {}\n};\n\n// Recursive Inorder Traversal\nvoid inorderRecursive(Node* root) {\n    if (root == nullptr) {\n        return;\n    }\n\n    inorderRecursive(root->left); // Traverse the left subtree\n    std::cout << root->data << \" \";  // Visit the root node\n    inorderRecursive(root->right); // Traverse the right subtree\n}\n\n// Iterative Inorder Traversal using a stack\nvoid inorderIterative(Node* root) {\n    std::stack<Node*> stack;\n    Node* current = root;\n\n    while (current != nullptr || !stack.empty()) {\n        // Reach the leftmost node of the current node\n        while (current != nullptr) {\n            stack.push(current);\n            current = current->left;\n        }\n\n        // Current is nullptr, so pop from stack and print\n        current = stack.top();\n        stack.pop();\n\n        std::cout << current->data << \" \";\n\n        // Now visit the right subtree\n        current = current->right;\n    }\n}\n\nint main() {\n    // Example Binary Search Tree:\n    //       4\n    //      / \\\n    //     2   5\n    //    / \\\n    //   1   3\n    Node* root = new Node(4);\n    root->left = new Node(2);\n    root->right = new Node(5);\n    root->left->left = new Node(1);\n    root->left->right = new Node(3);\n\n    std::cout << \"Recursive Inorder Traversal: \";\n    inorderRecursive(root);\n    std::cout << std::endl;\n\n    std::cout << \"Iterative Inorder Traversal: \";\n    inorderIterative(root);\n    std::cout << std::endl;\n\n    // Clean up memory (important to prevent memory leaks!)\n    delete root->left->left; \n    delete root->left->right;\n    delete root->left;\n    delete root->right;\n    delete root;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/inorder-tree-traversal/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=gm8DUJJhmY4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-tree/"
      ]
    ]
  },
  "morris-traversal": {
    "title": "Morris Traversal",
    "short": "Morris Traversal is a space-optimized in-order tree traversal algorithm for binary trees. It avoids recursion or a stack by cleverly using the tree's structure itself to keep track of the traversal. The core idea involves creating temporary links (threads) from predecessor nodes to successor nodes within the inorder sequence, allowing the traversal to proceed without extra space.",
    "time": "Average, Best, Worst: O(n)",
    "space": "O(1)",
    "code": "cpp\n#include <iostream>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nvoid morrisInorderTraversal(TreeNode* root) {\n    TreeNode* current = root;\n    while (current != nullptr) {\n        if (current->left == nullptr) {\n            // If no left child, visit the current node and move to the right\n            std::cout << current->val << \" \";\n            current = current->right;\n        } else {\n            // Find the inorder predecessor\n            TreeNode* predecessor = current->left;\n            while (predecessor->right != nullptr && predecessor->right != current) {\n                predecessor = predecessor->right;\n            }\n\n            // If the right child of the predecessor is not the current node\n            if (predecessor->right == nullptr) {\n                // Create the thread\n                predecessor->right = current;\n                current = current->left;\n            } else {\n                // Break the thread\n                predecessor->right = nullptr;\n                std::cout << current->val << \" \";\n                current = current->right;\n            }\n        }\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    // Create a sample binary tree\n    TreeNode* root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    root->left->left = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n\n    std::cout << \"Morris Inorder Traversal: \";\n    morrisInorderTraversal(root);\n\n    // Clean up memory (optional, but good practice)\n    delete root->left->left;\n    delete root->left->right;\n    delete root->left;\n    delete root->right;\n    delete root;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/morris-traversal-for-inorder/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=80Zug6D1cZ4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/tree/"
      ]
    ]
  },
  "threaded-binary-trees": {
    "title": "Threaded Binary Trees",
    "short": "A threaded binary tree is a binary tree variation where null pointers (left or right) are replaced with pointers to other nodes in the tree, called threads. These threads typically point to the inorder predecessor or inorder successor of the node, facilitating efficient traversal without recursion or a stack. They are primarily used to optimize inorder traversal in memory-constrained environments where stack space is limited.",
    "time": "Access: O(1), Search: O(log n) average, O(n) worst, Insertion: O(log n) average, O(n) worst, Deletion: O(log n) average, O(n) worst, Inorder Traversal: O(n)",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    bool leftThread;\n    bool rightThread;\n\n    Node(int val) : data(val), left(nullptr), right(nullptr), leftThread(false), rightThread(false) {}\n};\n\nclass ThreadedBinaryTree {\npublic:\n    Node* root;\n\n    ThreadedBinaryTree() : root(nullptr) {}\n\n    // Inorder successor\n    Node* inorderSuccessor(Node* node) {\n        // If right thread exists, return the node pointed by it\n        if (node->rightThread) {\n            return node->right;\n        }\n\n        // Else return leftmost child of right subtree\n        Node* current = node->right;\n        while (current != nullptr && !current->leftThread)\n            current = current->left;\n        return current;\n    }\n\n    // Inserts a new node with the given key\n    void insert(int key) {\n        Node* newNode = new Node(key);\n\n        if (root == nullptr) {\n            root = newNode;\n            return;\n        }\n\n        Node* current = root;\n        Node* parent = nullptr;\n\n        while (current != nullptr) {\n            parent = current;\n\n            if (key < current->data) {\n                if (current->leftThread) {\n                    break;\n                } else {\n                    current = current->left;\n                }\n            } else {\n                if (current->rightThread) {\n                    break;\n                } else {\n                    current = current->right;\n                }\n            }\n        }\n\n        if (key < parent->data) {\n            newNode->right = parent;\n            newNode->left = parent->left;\n            parent->left = newNode;\n            parent->leftThread = false;\n            newNode->rightThread = true;\n        } else {\n            newNode->left = parent;\n            newNode->right = parent->right;\n            parent->right = newNode;\n            parent->rightThread = false;\n            newNode->leftThread = true;\n        }\n    }\n\n    // Inorder traversal using threads\n    void inorderTraversal() {\n        if (root == nullptr) return;\n\n        // Find the leftmost node\n        Node* current = root;\n        while (current->left != nullptr && !current->leftThread) {\n            current = current->left;\n        }\n\n        // One by one print successors\n        while (current != nullptr) {\n            std::cout << current->data << \" \";\n            current = inorderSuccessor(current);\n        }\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    ThreadedBinaryTree tree;\n    tree.insert(20);\n    tree.insert(10);\n    tree.insert(30);\n    tree.insert(5);\n    tree.insert(16);\n    tree.insert(14);\n    tree.insert(40);\n    tree.insert(25);\n\n    std::cout << \"Inorder traversal of the threaded binary tree: \";\n    tree.inorderTraversal(); // Output: 5 10 14 16 20 25 30 40 \n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/threaded-binary-tree/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=H3Pq-F9tJ9g"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=binary%20tree"
      ]
    ]
  },
  "common-algorithms": {
    "title": "Binary Search",
    "short": "Binary search is an efficient algorithm for finding a specific element within a sorted array. It works by repeatedly dividing the search interval in half. If the middle element is the target value, the search is complete. Otherwise, if the target is smaller, the search continues in the left half; if larger, in the right half.  This process continues until the target is found or the interval is empty, indicating the target is not present.",
    "time": "Average: O(log n), Best: O(1), Worst: O(log n)",
    "space": "O(1)",
    "code": "// C++ implementation of Binary Search\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform binary search in a sorted array\nint binarySearch(const vector<int>& arr, int target) {\n    int low = 0;                  // Initialize the lower bound of the search space\n    int high = arr.size() - 1;    // Initialize the upper bound of the search space\n\n    while (low <= high) {         // Continue searching as long as the search space is not empty\n        int mid = low + (high - low) / 2;  // Calculate the middle index to prevent potential overflow\n\n        if (arr[mid] == target) {   // If the middle element is the target, return its index\n            return mid;             \n        } else if (arr[mid] < target) { // If the target is greater than the middle element, search in the right half\n            low = mid + 1;        \n        } else {                     // If the target is less than the middle element, search in the left half\n            high = mid - 1;       \n        }\n    }\n\n    return -1; // If the target is not found, return -1\n}\n\nint main() {\n    vector<int> sortedArray = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int targetValue = 23;\n\n    int result = binarySearch(sortedArray, targetValue);\n\n    if (result == -1) {\n        cout << \"Element is not found in the array\" << endl;\n    } else {\n        cout << \"Element is found at index: \" << result << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=oSU5jGiGjAY"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search/"
      ]
    ]
  },
  "kadane": {
    "title": "Kadane's Algorithm",
    "short": "Kadane's Algorithm is a dynamic programming algorithm used to find the maximum sum of a contiguous subarray within a one-dimensional array. It works by iterating through the array, maintaining two variables: `max_so_far` (maximum sum found so far) and `current_max` (maximum sum ending at the current position). The algorithm updates `current_max` by either adding the current element or starting a new subarray from the current element, and then updates `max_so_far` if `current_max` is greater. It's primarily used to solve problems related to maximizing the sum of a contiguous subsequence.",
    "time": "O(n)",
    "space": "O(1)",
    "code": "// C++ implementation of Kadane's Algorithm\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint kadane(const vector<int>& arr) {\n    // Initialize variables to store the maximum sum found so far and the current maximum sum.\n    int max_so_far = arr[0]; // Initialize with the first element to handle cases where all elements are negative\n    int current_max = arr[0];\n\n    // Iterate through the array starting from the second element.\n    for (size_t i = 1; i < arr.size(); ++i) {\n        // Update current_max: either extend the previous subarray or start a new subarray from the current element.\n        current_max = max(arr[i], current_max + arr[i]);\n\n        // Update max_so_far if the current maximum sum is greater.\n        max_so_far = max(max_so_far, current_max);\n    }\n\n    // Return the maximum sum found.\n    return max_so_far;\n}\n\nint main() {\n    // Example usage\n    vector<int> arr = {-2, -3, 4, -1, -2, 1, 5, -3};  // Example array\n\n    // Calculate the maximum sum using Kadane's algorithm.\n    int max_sum = kadane(arr);\n\n    // Print the maximum sum to the console.\n    cout << \"Maximum contiguous sum is \" << max_sum << endl;\n\n    vector<int> arr2 = {-1, -2, -3, -4}; // Test case with all negative numbers\n    int max_sum2 = kadane(arr2);\n    cout << \"Maximum contiguous sum is \" << max_sum2 << endl; // Expected output: -1\n\n    vector<int> arr3 = {1, 2, 3, 4}; // Test case with all positive numbers\n    int max_sum3 = kadane(arr3);\n    cout << \"Maximum contiguous sum is \" << max_sum3 << endl; // Expected output: 10\n\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=86CQq3pKSUw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/kadanes-algorithm/"
      ]
    ]
  },
  "fast-exponentiation": {
    "title": "Fast Exponentiation (Exponentiation by Squaring)",
    "short": "Fast exponentiation, also known as exponentiation by squaring, is an efficient algorithm for computing large integer powers of a number. It leverages the binary representation of the exponent to reduce the number of multiplications needed. Instead of performing 'n' multiplications to calculate a^n, it repeatedly squares the base and multiplies the result based on the bits of the exponent, significantly improving performance, particularly for large exponents. It is widely used in cryptography, number theory, and other areas requiring efficient power calculations.",
    "time": "O(log n)",
    "space": "O(1)",
    "code": " #include <iostream>\n\n // Function to calculate base^exp % mod efficiently using fast exponentiation\n long long fast_exponentiation(long long base, long long exp, long long mod) {\n  long long res = 1; // Initialize result to 1\n  base = base % mod; // Update base if it is more than or equal to mod\n\n  while (exp > 0) {\n   // If exp is odd, multiply base with result\n   if (exp % 2 == 1) {\n    res = (res * base) % mod;\n   }\n\n   // exp must be even now\n   exp = exp >> 1; // exp = exp/2\n   base = (base * base) % mod;\n  }\n  return res;\n }\n\n int main() {\n  long long base = 2; // The base number\n  long long exponent = 10; // The exponent\n  long long modulus = 1000000007; // A large prime number for modular arithmetic\n\n  long long result = fast_exponentiation(base, exponent, modulus);\n\n  std::cout << base << \"^\" << exponent << \" mod \" << modulus << \" = \" << result << std::endl;\n\n  base = 5;\n  exponent = 3;\n  modulus = 13;\n\n  result = fast_exponentiation(base, exponent, modulus);\n  std::cout << base << \"^\" << exponent << \" mod \" << modulus << \" = \" << result << std::endl;\n  return 0;\n }",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/exponentiation-by-squaring/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=Lgo6E5zLz_M"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/57344w6/"
      ]
    ]
  },
  "randomized-algorithms": {
    "title": "Randomized Algorithms",
    "short": "Randomized algorithms incorporate randomness as part of their logic. They make random choices during execution to guide the algorithm towards a solution. This approach often leads to simpler and more efficient solutions compared to deterministic algorithms, particularly for problems involving searching, sorting, or approximation. Randomized algorithms are widely used in various areas, including cryptography, data analysis, and optimization.",
    "time": "Varies greatly depending on the specific algorithm. Commonly O(n log n) or O(n) average case for sorting and searching. Worst case can sometimes degrade to O(n^2) or worse.",
    "space": "Varies greatly depending on the specific algorithm, but often O(1) or O(log n).",
    "code": "// Randomized QuickSort Implementation\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\n\n// Function to partition the array using the last element as the pivot\nint partition(vector<int>& arr, int low, int high) {\n    // Choose a random pivot index\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> distrib(low, high);\n    int randomIndex = distrib(gen);\n\n    // Swap random element with last element (pivot)\n    swap(arr[randomIndex], arr[high]);\n\n    int pivot = arr[high]; // pivot\n    int i = (low - 1); // Index of smaller element\n\n    for (int j = low; j <= high - 1; j++) {\n        // If current element is smaller than the pivot\n        if (arr[j] < pivot) {\n            i++; // increment index of smaller element\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\n// Function to implement quicksort\nvoid quickSort(vector<int>& arr, int low, int high) {\n    if (low < high) {\n        // pi is partitioning index, arr[p] is now at right place\n        int pi = partition(arr, low, high);\n\n        // Separately sort elements before partition and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Function to print an array\nvoid printArray(const vector<int>& arr) {\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n    cout << \"Unsorted array: \\n\";\n    printArray(arr);\n\n    quickSort(arr, 0, n - 1);\n\n    cout << \"Sorted array: \\n\";\n    printArray(arr);\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/randomized-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=6vF5XyCT_eM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=randomized"
      ]
    ]
  },
  "lru-cache-implementation": {
    "title": "LRU Cache Implementation",
    "short": "An LRU (Least Recently Used) cache is a cache eviction policy that prioritizes discarding the least recently used items first. It's commonly used in scenarios where memory is limited and frequently accessed data needs to be stored for faster retrieval. It typically uses a combination of a hash map for quick access to cached items and a doubly linked list to track access order and determine the least recently used item for eviction.",
    "time": "Access: O(1), Search: O(1), Insertion: O(1), Deletion: O(1)",
    "space": "O(N) where N is the cache capacity",
    "code": " #include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\n// Node structure for the doubly linked list\nstruct Node {\n    int key;\n    int value;\n    Node* prev;\n    Node* next;\n    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    int capacity;\n    unordered_map<int, Node*> cache;\n    Node* head;\n    Node* tail;\n\n    // Helper function to move a node to the head of the list (most recently used)\n    void moveToHead(Node* node) {\n        if (node == head) return;\n\n        if (node == tail) {\n            tail = node->prev;\n            tail->next = nullptr;\n        } else {\n            node->prev->next = node->next;\n            node->next->prev = node->prev;\n        }\n\n        node->next = head;\n        node->prev = nullptr;\n        head->prev = node;\n        head = node;\n    }\n\npublic:\n    LRUCache(int capacity) : capacity(capacity) {\n        head = nullptr;\n        tail = nullptr;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node* node = cache[key];\n            moveToHead(node);\n            return node->value;\n        } else {\n            return -1; // Key not found\n        }\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            // Key already exists, update the value and move to head\n            Node* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        } else {\n            // Key doesn't exist, create a new node\n            Node* newNode = new Node(key, value);\n            cache[key] = newNode;\n\n            if (cache.size() > capacity) {\n                // Evict the least recently used node (tail)\n                cache.erase(tail->key);\n                Node* temp = tail;\n                tail = tail->prev;\n                if (tail) {\n                    tail->next = nullptr;\n                }\n                delete temp;\n                temp = nullptr;\n                if(cache.size() == 0){\n                    head = nullptr;\n                    tail = nullptr;\n                }\n            }\n\n            if (head == nullptr) {\n                // Cache is empty\n                head = newNode;\n                tail = newNode;\n            } else {\n                // Add the new node to the head\n                newNode->next = head;\n                head->prev = newNode;\n                head = newNode;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache cache(2); // Capacity of 2\n\n    cache.put(1, 1);\n    cache.put(2, 2);\n    cout << cache.get(1) << endl;       // returns 1\n    cache.put(3, 3);    // evicts key 2\n    cout << cache.get(2) << endl;       // returns -1 (not found)\n    cache.put(4, 4);    // evicts key 1\n    cout << cache.get(1) << endl;       // returns -1 (not found)\n    cout << cache.get(3) << endl;       // returns 3\n    cout << cache.get(4) << endl;       // returns 4\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/lru-cache/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=7ABFKPK2hD4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/lru-cache/"
      ]
    ]
  },
  "practice-and-patterns": {
    "title": "Design Patterns: Singleton",
    "short": "The Singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global point of access to it. It's useful when exactly one object is needed to coordinate actions across the system. The pattern involves a private constructor, a static instance variable, and a static method to retrieve the instance.",
    "time": "Access: O(1)",
    "space": "O(1)",
    "code": "// Singleton Pattern Implementation\n#include <iostream>\n#include <mutex>\n\nclass Singleton {\nprivate:\n    // Private constructor to prevent instantiation from outside the class.\n    Singleton() {\n        std::cout << \"Singleton instance created.\\n\";\n    }\n\n    // Delete copy constructor and assignment operator.\n    Singleton(const Singleton&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n\n    // Static pointer to the single instance.\n    static Singleton* instance;\n\n    // Mutex for thread safety.\n    static std::mutex mutex;\n\npublic:\n    // Static method to get the singleton instance.\n    static Singleton* getInstance() {\n        // Use double-checked locking to ensure thread safety and efficiency.\n        std::lock_guard<std::mutex> lock(mutex);\n        if (instance == nullptr) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n\n    // Example method to demonstrate usage.\n    void doSomething() {\n        std::cout << \"Singleton is doing something!\\n\";\n    }\n\n    ~Singleton() {\n        std::cout << \"Singleton instance destroyed.\\n\";\n    }\n};\n\n// Initialize the static pointer to nullptr.\nSingleton* Singleton::instance = nullptr;\n\n// Initialize the static mutex.\nstd::mutex Singleton::mutex;\n\nint main() {\n    // Get the singleton instance.\n    Singleton* singleton1 = Singleton::getInstance();\n    singleton1->doSomething();\n\n    // Get the singleton instance again - it will be the same instance.\n    Singleton* singleton2 = Singleton::getInstance();\n    singleton2->doSomething();\n\n    // Verify that both pointers point to the same instance.\n    if (singleton1 == singleton2) {\n        std::cout << \"Both pointers point to the same instance.\\n\";\n    }\n\n    // No need to explicitly delete singleton1 or singleton2 because the destructor should be called when the program ends. However, for cleaner code, one should manage the instance and potentially delete it when no longer required.\n    // Uncomment the below lines when you are sure that the instance won't be used again.\n    // std::lock_guard<std::mutex> lock(Singleton::mutex); // protect the deletion\n    // delete Singleton::instance;\n    // Singleton::instance = nullptr;  // reset the pointer after deletion.\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/singleton-design-pattern/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=A32Uj-E5HkY"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=singleton"
      ]
    ]
  },
  "mock-interview-rounds": {
    "title": "Simulated Interview Rounds",
    "short": "Simulated interview rounds are structured practice sessions designed to mimic the experience of a real technical interview. These rounds typically involve presenting a problem, designing an algorithm and data structure to solve it, writing code (often on a whiteboard or shared document), and analyzing the code's correctness and efficiency. The primary use case is to prepare candidates for technical interviews by improving their problem-solving, communication, and coding skills under pressure.",
    "time": "Varies widely depending on the specific algorithms and data structures being practiced. No inherent time complexity.",
    "space": "Varies widely depending on the specific algorithms and data structures being practiced. No inherent space complexity.",
    "code": "/*\nThis C++ code simulates a very basic interview round.\nIt's more of a framework than a specific algorithm implementation,\nand demonstrates how one might structure a mock interview.\n\nImportant: This example focuses on structure, not a particular\nalgorithm.  A real mock interview would involve the candidate\nimplementing a specific algorithm given a problem statement.\n*/\n\n#include <iostream>\n#include <string>\n#include <chrono>\n#include <thread>\n\nusing namespace std;\n\n// Simulate the interviewer asking a question\nvoid interviewer_presents_problem(const string& problem_statement) {\n    cout << \"[Interviewer]: Here's the problem: \\n\" << problem_statement << endl;\n    this_thread::sleep_for(chrono::seconds(2)); // Simulate thinking time\n}\n\n// Simulate the candidate explaining their approach\nvoid candidate_explains_approach(const string& candidate_approach) {\n    cout << \"[Candidate]: My approach is as follows: \\n\" << candidate_approach << endl;\n    this_thread::sleep_for(chrono::seconds(1));\n}\n\n// Simulate the candidate writing code (simplified)\nvoid candidate_writes_code(const string& code_snippet) {\n    cout << \"[Candidate]: (Begins writing code...) \\n\" << code_snippet << endl;\n    this_thread::sleep_for(chrono::seconds(3));\n}\n\n// Simulate the interviewer asking about time complexity\nvoid interviewer_asks_time_complexity(const string& algorithm_name) {\n    cout << \"[Interviewer]: What is the time complexity of your \" << algorithm_name << \" implementation?\" << endl;\n    this_thread::sleep_for(chrono::seconds(1));\n}\n\n//Simulate the interviewer checking for edge cases\nvoid interviewer_asks_edge_cases(const string& algorithm_name){\n    cout << \"[Interviewer]: Have you considered potential edge cases with your \" << algorithm_name << \" implementation?\" << endl;\n    this_thread::sleep_for(chrono::seconds(1));\n}\n\n// Simulate the interviewer providing feedback\nvoid interviewer_provides_feedback(const string& feedback) {\n    cout << \"[Interviewer]: Here's some feedback: \\n\" << feedback << endl;\n}\n\n\nint main() {\n    // Example problem: (In a real interview, this would be more complex)\n    string problem = \"Implement a function to reverse a string.\";\n\n    // Simulate the interview process:\n    interviewer_presents_problem(problem);\n\n    string approach = \"I'll use a two-pointer approach. One pointer at the beginning and one at the end.  I'll swap characters until they meet in the middle.\";\n    candidate_explains_approach(approach);\n\n    string code = \"void reverseString(string& s) {\\n  int left = 0;\\n  int right = s.length() - 1;\\n  while (left < right) {\\n    swap(s[left++], s[right--]);\\n  }\\n}\";\n    candidate_writes_code(code);\n\n    interviewer_asks_time_complexity(\"reverseString\");\n\n    interviewer_asks_edge_cases(\"reverseString\");\n\n    string feedback = \"Good job! The code is correct and efficient. Consider adding error handling for null strings in a real-world scenario.\";\n    interviewer_provides_feedback(feedback);\n\n    cout << \"[End of Simulated Round]\" << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/how-to-prepare-for-technical-interviews/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=m3_n_t-2g28"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/top-interview-questions/"
      ]
    ]
  },
  "time-and-space-complexity-analysis": {
    "title": "Time and Space Complexity Analysis",
    "short": "Time and space complexity analysis is a crucial aspect of algorithm design and analysis, providing a way to understand and compare the efficiency of different algorithms. It involves estimating how the runtime (time complexity) and memory usage (space complexity) of an algorithm grow as the input size increases. We use Big O notation to express the upper bound of these complexities, focusing on the dominant terms and ignoring constant factors, thus enabling informed choices for optimal performance.",
    "time": "N/A (This is a methodology, not a specific algorithm or data structure)",
    "space": "N/A (This is a methodology, not a specific algorithm or data structure)",
    "code": "/*\n This code provides examples of how to analyze time and space complexity using Big O notation.\n It includes common examples to demonstrate the concepts.\n*/\n\n#include <iostream>\n#include <vector>\n\n// Example 1: O(1) - Constant Time and Space\nvoid constantTime(int arr[], int n) {\n // This operation takes constant time, regardless of the input size.\n int firstElement = arr[0]; // Accessing the first element of the array. Time: O(1)\n std::cout << \"First Element: \" << firstElement << std::endl;\n //The function uses a constant amount of extra memory regardless of input size. space : O(1).\n}\n\n// Example 2: O(n) - Linear Time and Constant Space\nvoid linearTime(int arr[], int n) {\n // This loop iterates through each element of the array once.\n for (int i = 0; i < n; ++i) { // Time: O(n)\n std::cout << arr[i] << \" \";\n }\n std::cout << std::endl;\n //The function uses a constant amount of extra memory regardless of input size. space : O(1).\n}\n\n// Example 3: O(n^2) - Quadratic Time and Constant Space\nvoid quadraticTime(int arr[], int n) {\n // Nested loops iterate through all possible pairs of elements in the array.\n for (int i = 0; i < n; ++i) {\n for (int j = 0; j < n; ++j) { // Time: O(n*n) = O(n^2)\n std::cout << arr[i] * arr[j] << \" \";\n }\n std::cout << std::endl;\n }\n //The function uses a constant amount of extra memory regardless of input size. space : O(1).\n}\n\n// Example 4: O(n) - Linear Time and Linear Space\nstd::vector<int> linearSpace(int arr[], int n) {\n // This function creates a new vector of size n.\n std::vector<int> newArr(n); // Space: O(n)\n for (int i = 0; i < n; ++i) { // Time: O(n)\n newArr[i] = arr[i] * 2;\n }\n return newArr;\n}\n\n//Example 5: O(log n) - Logarithmic Time\nint binarySearch(int arr[], int low, int high, int target){\n while(low <= high){\n int mid = low + (high - low) / 2;\n if(arr[mid] == target)\n return mid;\n else if (arr[mid] < target)\n low = mid + 1;\n else\n high = mid -1;\n }\n return -1; //Not found\n}\n\nint main() {\n int arr[] = {1, 2, 3, 4, 5};\n int n = sizeof(arr) / sizeof(arr[0]);\n\n std::cout << \"Constant Time Example: \";\n constantTime(arr, n);\n\n std::cout << \"Linear Time Example: \";\n linearTime(arr, n);\n\n std::cout << \"Quadratic Time Example: \" << std::endl;\n quadraticTime(arr, n);\n\n std::cout << \"Linear Space Example: \";\n std::vector<int> newArr = linearSpace(arr, n);\n for (int i = 0; i < n; ++i) {\n std::cout << newArr[i] << \" \";\n }\n std::cout << std::endl;\n \n int target = 3;\n int result = binarySearch(arr, 0, n-1, target);\n if(result == -1)\n std::cout << \"Element is not found!\";\n else\n std::cout << \"Element is found at index: \" << result << std::endl;\n\n return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/understanding-time-complexity-simple-guide/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=v4cd1O4zkGw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?topicSlugs=time-complexity"
      ]
    ]
  },
  "edge": {
    "title": "Edge (Graph Data Structure)",
    "short": "An edge represents a connection or relationship between two vertices (nodes) in a graph. It is a fundamental component for modeling networks and relationships. Edges can be directed (representing a one-way relationship) or undirected (representing a two-way relationship) and can also have weights associated with them, signifying the cost or strength of the connection. They are crucial for graph traversal algorithms and network analysis.",
    "time": "Access: O(1), Search: O(E) in an edge list, O(1) if using adjacency matrix, Insertion: O(1), Deletion: O(1)",
    "space": "O(1) for the edge object itself. The overall graph representation impacts the space complexity when storing many edges (e.g., O(V^2) for adjacency matrix or O(E) for adjacency list where V is the number of vertices and E is the number of edges).",
    "code": "// C++ implementation of an Edge for Graph Representation\n#include <iostream>\n#include <string>\n\nclass Edge {\npublic:\n    int source;    // Vertex where the edge originates\n    int destination; // Vertex where the edge terminates\n    int weight;      // Weight or cost associated with the edge (optional)\n\n    // Default constructor\n    Edge() : source(0), destination(0), weight(0) {}\n\n    // Parameterized constructor\n    Edge(int src, int dest, int w = 1) : source(src), destination(dest), weight(w) {}\n\n    // Overload the output stream operator to print the edge\n    friend std::ostream& operator<<(std::ostream& os, const Edge& edge) {\n        os << \"(\" << edge.source << \" -> \" << edge.destination << \", Weight: \" << edge.weight << \")\";\n        return os;\n    }\n\n    // Example usage: Check if two edges are equal\n    bool operator==(const Edge& other) const {\n        return (source == other.source && destination == other.destination && weight == other.weight);\n    }\n};\n\n// Main function for demonstration\nint main() {\n    // Create some edge objects\n    Edge edge1(0, 1, 5); // Edge from vertex 0 to 1 with weight 5\n    Edge edge2(1, 2);    // Edge from vertex 1 to 2 with default weight 1\n    Edge edge3(0, 1, 5);\n\n    // Print the edges\n    std::cout << \"Edge 1: \" << edge1 << std::endl;\n    std::cout << \"Edge 2: \" << edge2 << std::endl;\n\n    // Compare two edges\n    if (edge1 == edge3) {\n        std::cout << \"Edge 1 and Edge 3 are equal.\" << std::endl;\n    } else {\n        std::cout << \"Edge 1 and Edge 3 are not equal.\" << std::endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=gXEuC6j273Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  }
}