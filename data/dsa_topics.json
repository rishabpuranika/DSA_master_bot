{
  "arrays": {
    "title": "Arrays",
    "short": "Arrays are fundamental data structures that store a collection of elements of the same data type in contiguous memory locations. They provide direct access to elements using an index, allowing for efficient retrieval. Arrays are used extensively in programming for storing and manipulating collections of data, making them crucial for tasks such as sorting, searching, and data processing.",
    "time": {
      "Access": "O(1)",
      "Search": "O(n) (Unsorted), O(log n) (Sorted with Binary Search)",
      "Insertion": "O(n) (Worst Case: Beginning), O(1) (End)",
      "Deletion": "O(n) (Worst Case: Beginning), O(1) (End)"
    },
    "space": "O(n)",
    "code": "// A simple example of using arrays in C++\n#include <iostream>\n#include <algorithm> // Required for std::sort\n\nusing namespace std;\n\nint main() {\n    // Declare an array of integers with a fixed size\n    const int ARRAY_SIZE = 5;\n    int myArray[ARRAY_SIZE];\n\n    // Initialize the array elements\n    myArray[0] = 10;\n    myArray[1] = 5;\n    myArray[2] = 20;\n    myArray[3] = 15;\n    myArray[4] = 25;\n\n    // Print the array elements before sorting\n    cout << \"Array elements before sorting: \";\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n        cout << myArray[i] << \" \";\n    }\n    cout << endl;\n\n    // Sort the array in ascending order using std::sort from the <algorithm> library\n    std::sort(myArray, myArray + ARRAY_SIZE);\n\n    // Print the array elements after sorting\n    cout << \"Array elements after sorting: \";\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n        cout << myArray[i] << \" \";\n    }\n    cout << endl;\n\n    // Search for an element in the array (linear search in this unsorted example)\n    int searchElement = 15;\n    bool found = false;\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n        if (myArray[i] == searchElement) {\n            cout << \"Element \" << searchElement << \" found at index \" << i << endl;\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        cout << \"Element \" << searchElement << \" not found in the array.\" << endl;\n    }\n\n    //Demonstrating dynamic array allocation using new (important for cases where size is only known at runtime)\n    int dynamicArraySize = 3;\n    int* dynamicArray = new int[dynamicArraySize];\n    dynamicArray[0] = 1;\n    dynamicArray[1] = 2;\n    dynamicArray[2] = 3;\n\n    cout << \"Dynamic array elements: \";\n    for(int i = 0; i < dynamicArraySize; ++i){\n        cout << dynamicArray[i] << \" \";\n    }\n    cout << endl;\n\n    //Important: Remember to deallocate memory allocated with new to prevent memory leaks\n    delete[] dynamicArray;\n    dynamicArray = nullptr; // Set the pointer to null to avoid dangling pointer issues\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/array-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=l2oZfqvL5c4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/array/"
      ]
    ]
  },
  "linked-lists": {
    "title": "Linked Lists",
    "short": "A linked list is a linear data structure where elements, called nodes, are not stored in contiguous memory locations. Each node contains data and a pointer (or link) to the next node in the sequence. Linked lists offer dynamic memory allocation, efficient insertion and deletion operations at any position, but lack constant-time access to elements like arrays.",
    "time": {
      "Access": "Average: O(n), Best: O(1), Worst: O(n)",
      "Search": "Average: O(n), Best: O(1), Worst: O(n)",
      "Insertion": "Average: O(1) (given the node), Worst: O(n) (if searching for position)",
      "Deletion": "Average: O(1) (given the node), Worst: O(n) (if searching for position)"
    },
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n\n// Definition of a node in the linked list\nstruct Node {\n    int data;\n    Node* next;\n\n    // Constructor to initialize a node\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// Definition of the Linked List class\nclass LinkedList {\nprivate:\n    Node* head; // Pointer to the first node in the list\n\npublic:\n    // Constructor to initialize an empty list\n    LinkedList() : head(nullptr) {}\n\n    // Function to insert a new node at the beginning of the list\n    void insertAtBeginning(int value) {\n        Node* newNode = new Node(value);\n        newNode->next = head;\n        head = newNode;\n    }\n\n    // Function to insert a new node at the end of the list\n    void insertAtEnd(int value) {\n        Node* newNode = new Node(value);\n\n        if (head == nullptr) { // If list is empty\n            head = newNode;\n            return;\n        }\n\n        Node* current = head;\n        while (current->next != nullptr) {\n            current = current->next;\n        }\n\n        current->next = newNode;\n    }\n\n    // Function to delete a node with a given value\n    void deleteNode(int value) {\n        if (head == nullptr) return; // List is empty\n\n        if (head->data == value) { // If head needs to be deleted\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n            return;\n        }\n\n        Node* current = head;\n        while (current->next != nullptr && current->next->data != value) {\n            current = current->next;\n        }\n\n        if (current->next == nullptr) return; // Value not found\n\n        Node* temp = current->next;\n        current->next = current->next->next;\n        delete temp;\n    }\n\n    // Function to search for a value in the list\n    bool search(int value) {\n        Node* current = head;\n        while (current != nullptr) {\n            if (current->data == value) {\n                return true; // Value found\n            }\n            current = current->next;\n        }\n        return false; // Value not found\n    }\n\n    // Function to print the linked list\n    void printList() {\n        Node* current = head;\n        while (current != nullptr) {\n            std::cout << current->data << \" \";\n            current = current->next;\n        }\n        std::cout << std::endl;\n    }\n\n    //Destructor to prevent memory leaks\n    ~LinkedList() {\n      Node* current = head;\n      while (current != nullptr) {\n        Node* next = current->next;\n        delete current;\n        current = next;\n      }\n      head = nullptr;\n    }\n};\n\nint main() {\n    // Create a linked list\n    LinkedList myList;\n\n    // Insert elements\n    myList.insertAtEnd(10);\n    myList.insertAtBeginning(5);\n    myList.insertAtEnd(20);\n    myList.insertAtBeginning(1);\n\n    // Print the list\n    std::cout << \"Linked list: \";\n    myList.printList(); // Output: 1 5 10 20\n\n    // Search for an element\n    std::cout << \"Searching for 10: \" << (myList.search(10) ? \"Found\" : \"Not Found\") << std::endl; // Output: Found\n    std::cout << \"Searching for 15: \" << (myList.search(15) ? \"Found\" : \"Not Found\") << std::endl; // Output: Not Found\n\n    // Delete an element\n    myList.deleteNode(10);\n    std::cout << \"Linked list after deleting 10: \";\n    myList.printList(); // Output: 1 5 20\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/data-structures/linked-list/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=njFHsLyN9zc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/linked-list/"
      ]
    ]
  },
  "stacks": {
    "title": "Stacks",
    "short": "A stack is a linear data structure that follows the Last-In, First-Out (LIFO) principle, meaning the last element added is the first one removed. Elements are added and removed from only one end, called the 'top'. Stacks are commonly used for function call management, expression evaluation, and undo/redo functionality.",
    "time": "Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1)",
    "space": "O(n)",
    "code": " #include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n  // Creating a stack of integers\n  stack<int> myStack;\n\n  // Pushing elements onto the stack\n  myStack.push(10);\n  myStack.push(20);\n  myStack.push(30);\n\n  cout << \"Stack after pushing elements:\" << endl;\n\n  // Displaying the top element\n  cout << \"Top element: \" << myStack.top() << endl;\n\n  // Getting the size of the stack\n  cout << \"Size of the stack: \" << myStack.size() << endl;\n\n  // Popping elements from the stack\n  cout << \"Popping elements:\" << endl;\n  while (!myStack.empty()) {\n    cout << \"Popped element: \" << myStack.top() << endl;\n    myStack.pop(); // Removes the top element\n  }\n\n  // Checking if the stack is empty after popping all elements\n  if (myStack.empty()) {\n    cout << \"Stack is now empty.\" << endl;\n  }\n\n  // Example use case: Checking for balanced parentheses\n  string expression = \"{ [ ( ) ] }\";\n  stack<char> parenthesisStack;\n  bool balanced = true;\n\n  for (char c : expression) {\n    if (c == '(' || c == '[' || c == '{') {\n      parenthesisStack.push(c);\n    } else if (c == ')' || c == ']' || c == '}') {\n      if (parenthesisStack.empty()) {\n        balanced = false;\n        break;\n      }\n      char top = parenthesisStack.top();\n      parenthesisStack.pop();\n      if ((c == ')' && top != '(') || (c == ']' && top != '[') || (c == '}' && top != '{')) {\n        balanced = false;\n        break;\n      }\n    }\n  }\n\n  if (!parenthesisStack.empty()) {\n    balanced = false;\n  }\n\n  if (balanced) {\n    cout << \"The expression \\\"\" << expression << \"\\\" has balanced parentheses.\" << endl;\n  } else {\n    cout << \"The expression \\\"\" << expression << \"\\\" does NOT have balanced parentheses.\" << endl;\n  }\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/stack-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=F1F2imiOJfk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/stack/"
      ]
    ]
  },
  "queues": {
    "title": "Queues",
    "short": "A queue is a fundamental data structure that follows the First-In-First-Out (FIFO) principle, meaning the first element added to the queue is the first one to be removed. It operates like a real-world waiting line. Queues are commonly used in scenarios like managing tasks, handling print jobs, and implementing breadth-first search algorithms.",
    "time": "Access: O(n), Search: O(n), Insertion: O(1), Deletion: O(1)",
    "space": "O(n)",
    "code": " #include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n  // Creating a queue of integers\n  queue<int> myQueue;\n\n  // Adding elements to the queue (enqueue)\n  myQueue.push(10);\n  myQueue.push(20);\n  myQueue.push(30);\n\n  cout << \"Queue elements: \";\n  queue<int> tempQueue = myQueue; // Copy the queue for printing without modifying the original\n  while (!tempQueue.empty()) {\n    cout << tempQueue.front() << \" \"; // Access the front element\n    tempQueue.pop(); // Remove the front element from the copy\n  }\n  cout << endl;\n\n  // Checking the front element of the queue\n  cout << \"Front element: \" << myQueue.front() << endl;\n\n  // Checking the back element of the queue\n  cout << \"Back element: \" << myQueue.back() << endl;\n\n  // Checking the size of the queue\n  cout << \"Queue size: \" << myQueue.size() << endl;\n\n  // Removing elements from the queue (dequeue)\n  myQueue.pop();\n  cout << \"Queue after removing the front element: \";\n  tempQueue = myQueue;\n  while (!tempQueue.empty()) {\n    cout << tempQueue.front() << \" \";\n    tempQueue.pop();\n  }\n  cout << endl;\n\n  // Checking if the queue is empty\n  if (myQueue.empty()) {\n    cout << \"Queue is empty.\" << endl;\n  } else {\n    cout << \"Queue is not empty.\" << endl;\n  }\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/queue-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=jaKzmsKp4HM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/queue/"
      ]
    ]
  },
  "linear-search": {
    "title": "Linear Search",
    "short": "Linear search, also known as sequential search, is a straightforward algorithm used to find a target element within a list. It works by sequentially examining each element of the list until the target is found or the end of the list is reached. This algorithm is best suited for small, unsorted datasets where efficiency is not a primary concern, or when the data is stored in a format that does not easily allow for more complex search algorithms.",
    "time": {
      "Average": "O(n)",
      "Best": "O(1)",
      "Worst": "O(n)"
    },
    "space": "O(1)",
    "code": "// C++ implementation of Linear Search\n#include <iostream>\n#include <vector>\n\n// Function to perform linear search\nint linearSearch(const std::vector<int>& arr, int target) {\n    // Iterate through each element of the array\n    for (size_t i = 0; i < arr.size(); ++i) {\n        // Check if the current element matches the target\n        if (arr[i] == target) {\n            // Return the index of the target element if found\n            return i;\n        }\n    }\n    // Return -1 if the target element is not found in the array\n    return -1;\n}\n\nint main() {\n    // Example usage\n    std::vector<int> arr = {5, 12, 7, 23, 1, 9};\n    int target = 23;\n\n    // Call the linearSearch function\n    int index = linearSearch(arr, target);\n\n    // Print the result\n    if (index != -1) {\n        std::cout << \"Element \" << target << \" found at index: \" << index << std::endl;\n    } else {\n        std::cout << \"Element \" << target << \" not found in the array.\" << std::endl;\n    }\n\n    target = 100;\n    index = linearSearch(arr, target);\n\n    if (index != -1) {\n        std::cout << \"Element \" << target << \" found at index: \" << index << std::endl;\n    } else {\n        std::cout << \"Element \" << target << \" not found in the array.\" << std::endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/linear-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=CZ3l_v29xFY"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=Linear%20Search"
      ]
    ]
  },
  "binary-search": {
    "title": "Binary Search",
    "short": "Binary search is an efficient algorithm used to find a specific element within a sorted array. It works by repeatedly dividing the search interval in half. If the middle element matches the target value, the search is successful. If the target is less than the middle element, the search continues in the left half; otherwise, it continues in the right half. This process continues until the target is found or the interval is empty.",
    "time": "Average: O(log n), Best: O(1), Worst: O(log n)",
    "space": "O(1) (Iterative), O(log n) (Recursive, due to call stack)",
    "code": "// Binary Search implementation in C++\n#include <iostream>\n#include <vector>\n\n// Iterative Binary Search Function\nint binarySearch(const std::vector<int>& arr, int target) {\n    int low = 0;\n    int high = arr.size() - 1;\n\n    while (low <= high) {\n        // Calculate the middle index to avoid potential overflow\n        int mid = low + (high - low) / 2;\n\n        // Check if the target is present at the middle\n        if (arr[mid] == target) {\n            return mid; // Target found at index mid\n        }\n\n        // If target is smaller, ignore right half\n        else if (arr[mid] > target) {\n            high = mid - 1;\n        }\n\n        // If target is greater, ignore left half\n        else {\n            low = mid + 1;\n        }\n    }\n\n    // If we reach here, then the target was not present\n    return -1; // Target not found\n}\n\n// Recursive Binary Search Function\nint binarySearchRecursive(const std::vector<int>& arr, int target, int low, int high) {\n    if (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] > target) {\n            return binarySearchRecursive(arr, target, low, mid - 1);\n        }\n        return binarySearchRecursive(arr, target, mid + 1, high);\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<int> sortedArray = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int targetValue = 23;\n\n    // Using iterative binary search\n    int resultIterative = binarySearch(sortedArray, targetValue);\n\n    if (resultIterative == -1) {\n        std::cout << \"Element is not present in array (Iterative)\\n\";\n    } else {\n        std::cout << \"Element is present at index \" << resultIterative << \" (Iterative)\\n\";\n    }\n\n    // Using recursive binary search\n    int resultRecursive = binarySearchRecursive(sortedArray, targetValue, 0, sortedArray.size() - 1);\n\n    if (resultRecursive == -1) {\n        std::cout << \"Element is not present in array (Recursive)\\n\";\n    } else {\n        std::cout << \"Element is present at index \" << resultRecursive << \" (Recursive)\\n\";\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=oSU5jGiGq1U"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search/"
      ]
    ]
  },
  "selection-sort": {
    "title": "Selection Sort",
    "short": "Selection sort is a simple, in-place comparison sorting algorithm. It works by repeatedly finding the minimum element from the unsorted part of the array and placing it at the beginning. The algorithm divides the input list into two parts: the sorted sublist of elements which is built up from left to right at the front (left) of the list and the sublist of the remaining unsorted elements that occupy the rest of the list. Selection sort is noted for its simplicity and performance advantages over more complicated algorithms in certain situations, particularly when memory write operations are costly.",
    "time": {
      "average": "O(n^2)",
      "best": "O(n^2)",
      "worst": "O(n^2)"
    },
    "space": "O(1)",
    "code": " #include <iostream>\n#include <vector>\n#include <algorithm> // for std::swap\n\n// Function to perform selection sort\nvoid selectionSort(std::vector<int>& arr) {\n  int n = arr.size();\n\n  // Traverse through all array elements\n  for (int i = 0; i < n - 1; i++) {\n    // Find the minimum element in unsorted array\n    int min_idx = i;\n    for (int j = i + 1; j < n; j++) {\n      if (arr[j] < arr[min_idx])\n        min_idx = j;\n    }\n\n    // Swap the found minimum element with the first element\n    if (min_idx != i)\n      std::swap(arr[i], arr[min_idx]);\n  }\n}\n\n// Main function to demonstrate selection sort\nint main() {\n  std::vector<int> arr = {64, 25, 12, 22, 11};\n  int n = arr.size();\n\n  std::cout << \"Unsorted array: \\n\";\n  for (int i = 0; i < n; i++)\n    std::cout << arr[i] << \" \";\n  std::cout << std::endl;\n\n  selectionSort(arr);\n\n  std::cout << \"Sorted array: \\n\";\n  for (int i = 0; i < n; i++)\n    std::cout << arr[i] << \" \";\n  std::cout << std::endl;\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/selection-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=xWBP4lUhNM0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sort/"
      ]
    ]
  },
  "insertion-sort": {
    "title": "Insertion Sort",
    "short": "Insertion Sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It iterates through the input elements, taking each element and 'inserting' it into its correct position within the already sorted portion of the array. This algorithm is efficient for small datasets or nearly sorted data and is an in-place sorting algorithm.",
    "time": {
      "Average": "O(n^2)",
      "Best": "O(n)",
      "Worst": "O(n^2)"
    },
    "space": "O(1)",
    "code": "// Insertion Sort Implementation in C++\n#include <iostream>\n#include <vector>\n\nvoid insertionSort(std::vector<int>& arr) {\n  // Iterate through the array, starting from the second element\n  for (int i = 1; i < arr.size(); ++i) {\n    int key = arr[i]; // The element to be inserted into the sorted portion\n    int j = i - 1;   // Index of the last element in the sorted portion\n\n    // Move elements of arr[0..i-1], that are greater than key,\n    // to one position ahead of their current position\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j]; // Shift the element to the right\n      j = j - 1;          // Move to the next element in the sorted portion\n    }\n    arr[j + 1] = key; // Insert the key into its correct position\n  }\n}\n\nint main() {\n  std::vector<int> arr = {12, 11, 13, 5, 6}; // Example array\n\n  std::cout << \"Unsorted array: \";\n  for (int num : arr) {\n    std::cout << num << \" \";\n  }\n  std::cout << std::endl;\n\n  insertionSort(arr); // Sort the array\n\n  std::cout << \"Sorted array: \";\n  for (int num : arr) {\n    std::cout << num << \" \";\n  }\n  std::cout << std::endl;\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/insertion-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=JU767MXtY7I"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/insertion-sort/"
      ]
    ]
  },
  "merge-sort": {
    "title": "Merge Sort",
    "short": "Merge Sort is a divide-and-conquer sorting algorithm that recursively divides an unsorted list into smaller sublists until each sublist contains only one element, which is considered sorted. Then, it repeatedly merges the sublists to produce new sorted sublists until there is only one sorted list remaining. It's commonly used for sorting large datasets due to its guaranteed performance.",
    "time": "Average: O(n log n), Best: O(n log n), Worst: O(n log n)",
    "space": "O(n)",
    "code": " #include <iostream>\n#include <vector>\n\n// Function to merge two sorted subarrays\nvoid merge(std::vector<int>& arr, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    // Create temporary arrays\n    std::vector<int> L(n1), R(n2);\n\n    // Copy data to temporary arrays L[] and R[]\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    // Merge the temporary arrays back into arr[left...right]\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// Main function that sorts arr[left...right] using merge()\nvoid mergeSort(std::vector<int>& arr, int left, int right) {\n    if (left < right) {\n        // Find the middle point\n        int mid = left + (right - left) / 2; // Prevent potential overflow\n\n        // Sort first and second halves\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n\n        // Merge the sorted halves\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    std::vector<int> arr = {12, 11, 13, 5, 6, 7};\n    int arr_size = arr.size();\n\n    std::cout << \"Given array is \\n\";\n    for (int i = 0; i < arr_size; i++)\n        std::cout << arr[i] << \" \";\n    std::cout << \"\\n\";\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    std::cout << \"\\nSorted array is \\n\";\n    for (int i = 0; i < arr_size; i++)\n        std::cout << arr[i] << \" \";\n    std::cout << \"\\n\";\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/merge-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=KF2j-9i8WkA"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/merge-sort/"
      ]
    ]
  },
  "quick-sort": {
    "title": "Quick Sort",
    "short": "Quick Sort is a divide-and-conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted. This process continues until the entire array is sorted. It's widely used due to its efficiency and simplicity.",
    "time": "Average: O(n log n), Best: O(n log n), Worst: O(n^2)",
    "space": "O(log n) (average), O(n) (worst)",
    "code": "// C++ implementation of QuickSort\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to partition the array using Lomuto partition scheme\nint partition(vector<int>& arr, int low, int high) {\n    int pivot = arr[high]; // Choosing the last element as pivot\n    int i = (low - 1); // Index of smaller element\n\n    for (int j = low; j <= high - 1; j++) {\n        // If current element is smaller than or equal to pivot\n        if (arr[j] <= pivot) {\n            i++; // increment index of smaller element\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\n// Function to implement QuickSort\nvoid quickSort(vector<int>& arr, int low, int high) {\n    if (low < high) {\n        // pi is partitioning index, arr[pi] is now at right place\n        int pi = partition(arr, low, high);\n\n        // Separately sort elements before partition and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Function to print an array\nvoid printArray(const vector<int>& arr) {\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n// Main function\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n    cout << \"Unsorted array: \\n\";\n    printArray(arr);\n\n    quickSort(arr, 0, n - 1);\n\n    cout << \"Sorted array: \\n\";\n    printArray(arr);\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/quick-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=MZaf_9IZCrc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/quickselect/"
      ]
    ]
  },
  "heap-sort": {
    "title": "Heap Sort",
    "short": "Heap Sort is a comparison-based sorting algorithm that leverages the properties of a binary heap data structure. It first transforms the input array into a max-heap (or min-heap, depending on the desired sorting order). Then, it repeatedly extracts the maximum (or minimum) element from the heap and places it at the end of the sorted portion of the array, effectively sorting the array in place. Heap sort is efficient and guaranteed to perform well even in the worst-case scenario.",
    "time": {
      "Average": "O(n log n)",
      "Best": "O(n log n)",
      "Worst": "O(n log n)"
    },
    "space": "O(1)",
    "code": "// Heap Sort in C++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to heapify a subtree rooted at node i\n// in a max-heap\nvoid heapify(std::vector<int>& arr, int n, int i) {\n  int largest = i; // Initialize largest as root\n  int left = 2 * i + 1; // left = 2*i + 1\n  int right = 2 * i + 2; // right = 2*i + 2\n\n  // If left child is larger than root\n  if (left < n && arr[left] > arr[largest])\n    largest = left;\n\n  // If right child is larger than largest so far\n  if (right < n && arr[right] > arr[largest])\n    largest = right;\n\n  // If largest is not root\n  if (largest != i) {\n    std::swap(arr[i], arr[largest]);\n\n    // Recursively heapify the affected sub-tree\n    heapify(arr, n, largest);\n  }\n}\n\n// Main function to perform heap sort\nvoid heapSort(std::vector<int>& arr) {\n  int n = arr.size();\n\n  // Build max heap (rearrange array)\n  for (int i = n / 2 - 1; i >= 0; i--)\n    heapify(arr, n, i);\n\n  // One by one extract an element from heap\n  for (int i = n - 1; i > 0; i--) {\n    // Move current root to end\n    std::swap(arr[0], arr[i]);\n\n    // call max heapify on the reduced heap\n    heapify(arr, i, 0);\n  }\n}\n\n// Utility function to print an array\nvoid printArray(const std::vector<int>& arr) {\n  for (int value : arr)\n    std::cout << value << \" \";\n  std::cout << std::endl;\n}\n\n// Example usage\nint main() {\n  std::vector<int> arr = {12, 11, 13, 5, 6, 7};\n  int n = arr.size();\n\n  std::cout << \"Unsorted array: \\n\";\n  printArray(arr);\n\n  heapSort(arr);\n\n  std::cout << \"\\nSorted array: \\n\";\n  printArray(arr);\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/heap-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=MtQL_LL5c20"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/heap/"
      ]
    ]
  },
  "counting-sort": {
    "title": "Counting Sort",
    "short": "Counting sort is a non-comparative sorting algorithm that sorts elements by counting the number of occurrences of each unique element in the input array. This count is then used to determine the position of each element in the sorted output array. Counting sort is particularly efficient for sorting data where the range of input values is not significantly greater than the number of elements to be sorted, and it is often used as a subroutine in other sorting algorithms like radix sort.",
    "time": "Average: O(n+k), Best: O(n+k), Worst: O(n+k), where n is the number of elements and k is the range of input",
    "space": "O(k)",
    "code": "// Counting Sort Implementation in C++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform counting sort\nvector<int> countingSort(vector<int> arr, int k) {\n    // k is the range of input, i.e., numbers between 0 and k-1\n    int n = arr.size();\n\n    // Create count array to store the frequency of each element\n    vector<int> count(k, 0);\n\n    // Create output array to store the sorted elements\n    vector<int> output(n);\n\n    // Store the count of each element in the count array\n    for (int i = 0; i < n; i++) {\n        count[arr[i]]++;\n    }\n\n    // Modify the count array to store the cumulative count\n    for (int i = 1; i < k; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // Fill the output array based on the count array\n    for (int i = n - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n\n    return output;\n}\n\nint main() {\n    vector<int> arr = {4, 2, 2, 8, 3, 3, 1};\n    int k = 9; // Range of input is 0-8, so k=9\n\n    vector<int> sortedArr = countingSort(arr, k);\n\n    cout << \"Sorted array: \";\n    for (int i = 0; i < sortedArr.size(); i++) {\n        cout << sortedArr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/counting-sort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=4YRqE-uNJYM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sort/"
      ]
    ]
  },
  "shell-sort": {
    "title": "Shell Sort",
    "short": "Shell sort is a generalization of insertion sort that avoids large shifts of elements by first sorting elements that are far apart. It gradually reduces the gap between elements to be compared, eventually performing a standard insertion sort on the nearly sorted array. This makes it more efficient than insertion sort for larger datasets by reducing the number of comparisons and swaps needed.",
    "time": "Average: O(n(logn)^2), Best: O(nlogn), Worst: O(n^2)",
    "space": "O(1)",
    "code": "// Shell Sort Implementation in C++\n#include <iostream>\n#include <vector>\n\n// Function to perform Shell Sort\nvoid shellSort(std::vector<int>& arr) {\n    int n = arr.size();\n\n    // Start with a large gap and reduce it until it's 1\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements arr[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire arrray is\n        // gap sorted \n        for (int i = gap; i < n; i += 1) {\n            // add arr[i] to the elements that have been gap sorted\n            // save arr[i] in temp and make a hole at position i\n            int temp = arr[i];\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for arr[i] is found\n            int j;\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n                arr[j] = arr[j - gap];\n\n            // put temp (the original arr[i]) in its correct location\n            arr[j] = temp;\n        }\n    }\n}\n\n// Function to print an array\nvoid printArray(const std::vector<int>& arr) {\n    for (int value : arr) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> arr = {12, 34, 54, 2, 3, 33, 56, 23, 1, 9};\n\n    std::cout << \"Array before sorting: \\n\";\n    printArray(arr);\n\n    shellSort(arr);\n\n    std::cout << \"Array after sorting: \\n\";\n    printArray(arr);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/shellsort/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=ddeLefj44lw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/shellsort/"
      ]
    ]
  },
  "hash-tables": {
    "title": "Hash Tables",
    "short": "A hash table (or hash map) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Ideal for situations where fast insertion, deletion, and search operations are crucial based on a key.",
    "time": "Average: Access/Search/Insertion/Deletion: O(1); Best: Access/Search/Insertion/Deletion: O(1); Worst: Access/Search/Insertion/Deletion: O(n) (collision)",
    "space": "O(n)",
    "code": "// A simple Hash Table implementation in C++ using separate chaining.\n#include <iostream>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\n// Hash table class\ntemplate <typename K, typename V>\nclass HashTable {\nprivate:\n    // Number of buckets\n    int capacity;\n\n    // Array of buckets (linked lists)\n    vector<list<pair<K, V>>> table;\n\n    // Hash function (simple modulo operation)\n    int hashFunction(K key) {\n        return (hash<K>{}(key) % capacity);\n    }\n\npublic:\n    // Constructor\n    HashTable(int capacity) : capacity(capacity) {\n        table.resize(capacity);\n    }\n\n    // Insert a key-value pair\n    void insert(K key, V value) {\n        int index = hashFunction(key);\n        table[index].push_back(make_pair(key, value));\n    }\n\n    // Search for a value given a key\n    V* search(K key) {\n        int index = hashFunction(key);\n        for (auto& pair : table[index]) {\n            if (pair.first == key) {\n                return &pair.second;\n            }\n        }\n        return nullptr; // Key not found\n    }\n\n    // Delete a key-value pair\n    void remove(K key) {\n        int index = hashFunction(key);\n        table[index].remove_if([key](const pair<K, V>& p) { return p.first == key; });\n    }\n\n    // Display the hash table\n    void display() {\n        for (int i = 0; i < capacity; ++i) {\n            cout << \"Bucket \" << i << \": \";\n            for (auto& pair : table[i]) {\n                cout << \"(\" << pair.first << \", \" << pair.second << \") \";\n            }\n            cout << endl;\n        }\n    }\n};\n\n// Example usage\nint main() {\n    HashTable<string, int> ht(10); // Capacity of 10\n\n    ht.insert(\"Alice\", 25);\n    ht.insert(\"Bob\", 30);\n    ht.insert(\"Charlie\", 35);\n    ht.insert(\"David\", 40);\n    ht.insert(\"Eve\", 45);\n\n    cout << \"Hash Table contents:\\n\";\n    ht.display();\n\n    int* age = ht.search(\"Bob\");\n    if (age != nullptr) {\n        cout << \"\\nBob's age: \" << *age << endl;\n    } else {\n        cout << \"\\nBob not found.\\n\";\n    }\n\n    ht.remove(\"Bob\");\n    cout << \"\\nHash Table after removing Bob:\\n\";\n    ht.display();\n\n    age = ht.search(\"Bob\");\n    if (age != nullptr) {\n        cout << \"\\nBob's age: \" << *age << endl;\n    } else {\n        cout << \"\\nBob not found.\\n\";\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/hashing-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=MfhjkfocRR0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/hash-table/"
      ]
    ]
  },
  "hash-sets": {
    "title": "Hash Sets",
    "short": "A hash set is a data structure that implements an abstract set, offering efficient methods to add, remove, and check the presence of elements. It achieves this efficiency by using a hash function to map elements to indices in an underlying array (hash table). Unlike other set implementations, hash sets do not guarantee any specific order of elements and excel in scenarios where fast membership tests are required.",
    "time": "Average: Access: O(1), Search: O(1), Insertion: O(1), Deletion: O(1); Worst: Access: O(n), Search: O(n), Insertion: O(n), Deletion: O(n); Best: Access: O(1), Search: O(1), Insertion: O(1), Deletion: O(1)",
    "space": "O(n), where n is the number of elements in the set.",
    "code": "cpp\n#include <iostream>\n#include <unordered_set>\n#include <string>\n\nusing namespace std;\n\nint main() {\n  // Create an unordered_set to store strings.\n  unordered_set<string> mySet;\n\n  // Insert elements into the set.\n  mySet.insert(\"apple\");\n  mySet.insert(\"banana\");\n  mySet.insert(\"cherry\");\n\n  // Check if an element exists in the set.\n  if (mySet.count(\"banana\") > 0) {\n    cout << \"Banana exists in the set.\\n\";\n  } else {\n    cout << \"Banana does not exist in the set.\\n\";\n  }\n\n  // Try to insert a duplicate element.\n  mySet.insert(\"apple\"); // This will not add a duplicate.\n\n  // Print the number of elements in the set.\n  cout << \"The set contains \" << mySet.size() << \" elements.\\n\";\n\n  // Iterate over the elements in the set (order is not guaranteed).\n  cout << \"Elements in the set are:\\n\";\n  for (const string& element : mySet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  // Remove an element from the set.\n  mySet.erase(\"banana\");\n\n  // Check if banana is removed\n    if (mySet.count(\"banana\") > 0) {\n    cout << \"Banana exists in the set.\\n\";\n  } else {\n    cout << \"Banana does not exist in the set.\\n\";\n  }\n\n  // Clear all elements from the set.\n  mySet.clear();\n\n  // Check if the set is empty.\n  if (mySet.empty()) {\n    cout << \"The set is now empty.\\n\";\n  } else {\n    cout << \"The set is not empty.\\n\";\n  }\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/unordered_set-in-cpp-stl/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=w30o_EXB7lU"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/hash-table/"
      ]
    ]
  },
  "recursion": {
    "title": "Recursion",
    "short": "Recursion is a programming technique where a function calls itself within its own definition. This allows for solving problems by breaking them down into smaller, self-similar subproblems. A recursive function consists of a base case, which stops the recursion, and a recursive step, which calls the function again with a modified input. It is especially useful for problems with inherent recursive structures, such as tree traversals or mathematical definitions like the factorial.",
    "time": "Varies significantly depending on the problem. Often O(2^n) or O(n!), but can be O(n) or O(log n) in certain cases if optimized correctly using techniques like tail recursion or memoization. Difficult to generalize.",
    "space": "O(n) on average, where n is the depth of the recursion (stack space). In worst-case scenarios, it can be higher if intermediate data is being stored.",
    "code": "cpp\n#include <iostream>\n\n// Recursive function to calculate factorial\nunsigned long long factorial(int n) {\n    // Base case: factorial of 0 is 1\n    if (n == 0) {\n        return 1;\n    }\n    // Recursive step: n! = n * (n-1)!\n    else {\n        return n * factorial(n - 1);\n    }\n}\n\n// Recursive function to calculate the nth fibonacci number\nint fibonacci(int n) {\n  //Base cases: 0th fibonacci number is 0, 1st fibonacci number is 1\n  if (n <= 1) {\n    return n;\n  }\n  // Recursive step: nth fibonacci number is the sum of the (n-1)th and (n-2)th fibonacci numbers\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n\n//Recursive function to calculate the sum of digits of a number\nint sum_of_digits(int n) {\n    // Base case: if n is 0, the sum is 0\n    if(n == 0){\n        return 0;\n    }\n    // Recursive step: get the last digit, add it to the sum of the remaining digits\n    return (n % 10) + sum_of_digits(n / 10);\n}\n\nint main() {\n    int num = 5;\n    unsigned long long fact = factorial(num);\n    std::cout << \"Factorial of \" << num << \" is: \" << fact << std::endl;\n\n    int fib_num = 10;\n    int fib = fibonacci(fib_num);\n    std::cout << \"The \" << fib_num << \"th Fibonacci number is: \" << fib << std::endl;\n\n    int digit_num = 12345;\n    int sum = sum_of_digits(digit_num);\n    std::cout << \"The sum of the digits of \" << digit_num << \" is: \" << sum << std::endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/recursion/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=Mv9NEXX1VHc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/recursion-i/"
      ]
    ]
  },
  "principles-and-examples": {
    "title": "Binary Search",
    "short": "Binary search is an efficient algorithm for finding a target value within a sorted array. It works by repeatedly dividing the search interval in half. If the middle element is the target value, the search is successful. Otherwise, the search continues in either the left or right half, depending on whether the target value is smaller or larger than the middle element, respectively. It is primarily used for quickly locating elements in ordered datasets.",
    "time": "Average: O(log n), Best: O(1), Worst: O(log n)",
    "space": "O(1)",
    "code": " #include <iostream>\n#include <vector>\n\n// Function to perform binary search on a sorted vector\nint binarySearch(const std::vector<int>& arr, int target) {\n    int left = 0; // Initialize left boundary\n    int right = arr.size() - 1; // Initialize right boundary\n\n    while (left <= right) { // Continue as long as the search space is valid\n        int mid = left + (right - left) / 2; // Calculate the middle index.  Avoids potential overflow.\n\n        if (arr[mid] == target) { // If the middle element is the target\n            return mid; // Return the index of the target\n        } else if (arr[mid] < target) { // If the target is greater than the middle element\n            left = mid + 1; // Adjust the left boundary to search the right half\n        } else { // If the target is less than the middle element\n            right = mid - 1; // Adjust the right boundary to search the left half\n        }\n    }\n\n    return -1; // If the target is not found, return -1\n}\n\nint main() {\n    std::vector<int> sortedArray = {2, 5, 7, 8, 11, 12}; // Example sorted array\n    int targetValue = 13; // Example target value\n\n    int result = binarySearch(sortedArray, targetValue); // Perform binary search\n\n    if (result == -1) {\n        std::cout << \"Element is not found in the array\" << std::endl;\n    } else {\n        std::cout << \"Element is found at index: \" << result << std::endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=JsUTriDkm-g"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search/"
      ]
    ]
  },
  "mathematical-recursion": {
    "title": "Mathematical Recursion",
    "short": "Mathematical recursion is a method of defining a function or relation in terms of itself. It works by breaking down a problem into smaller, self-similar subproblems until a base case is reached, at which point the recursion unwinds, combining the solutions of the subproblems.  This approach is commonly used for problems with inherent self-similarity, such as factorials, Fibonacci sequences, and tree traversals.",
    "time": "Varies depending on the function, but often O(b^d) or O(d) where b is the branching factor and d is the depth of recursion. Can also be exponential (e.g., naive Fibonacci).",
    "space": "O(d) on average due to the call stack, where d is the maximum depth of recursion.",
    "code": "// A simple example of mathematical recursion: calculating the factorial of a number.\n#include <iostream>\n\n// Recursive function to calculate factorial\nunsigned long long factorial(int n) {\n  // Base case: factorial of 0 is 1\n  if (n == 0) {\n    return 1;\n  }\n  // Recursive step: n! = n * (n-1)!\n  else if (n > 0) {\n      return n * factorial(n - 1);\n  } else {\n      std::cerr << \"Error: Factorial is not defined for negative numbers.\\n\";\n      return 0; // Or throw an exception\n  }\n}\n\n// Another example: Fibonacci sequence\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nint main() {\n  int num = 5;\n  std::cout << \"Factorial of \" << num << \" is: \" << factorial(num) << std::endl;\n  std::cout << \"Fibonacci of \" << num << \" is: \" << fibonacci(num) << std::endl;\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/recursion/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=Mv9NEXX1VHc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?topicSlugs=recursion"
      ]
    ]
  },
  "backtracking-recursion-basics": {
    "title": "Backtracking Recursion Basics",
    "short": "Backtracking is a general algorithmic technique for solving problems by incrementally building candidates to the solutions, and abandoning a candidate (\"backtracking\") as soon as it determines that the candidate cannot possibly lead to a valid solution. It's often implemented using recursion to explore the decision tree. Backtracking is typically used to solve constraint satisfaction problems, such as finding all permutations of a string, solving Sudoku puzzles, or finding subsets that sum to a particular target.",
    "time": "O(b^d) where b is the branching factor (number of choices at each decision point) and d is the depth of the search tree. In the worst case, it might explore all possible solutions.",
    "space": "O(d) due to the recursion depth, where d is the maximum depth of the recursion tree. In some implementations, additional space may be used to store the solution or keep track of the visited states.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to print all permutations of a string using backtracking.\nvoid printPermutations(string str, int l, int r, vector<string>& result) {\n    // Base case: If l == r, it means we have a complete permutation.\n    if (l == r) {\n        result.push_back(str);\n        return;\n    }\n\n    // Recursive case: iterate from l to r to generate permutations.\n    for (int i = l; i <= r; i++) {\n        // Fix the character at the l-th position by swapping with i-th character.\n        swap(str[l], str[i]);\n\n        // Recursively generate permutations for the rest of the string.\n        printPermutations(str, l + 1, r, result);\n\n        // Backtrack: Restore the string to its original state.\n        swap(str[l], str[i]);\n    }\n}\n\nint main() {\n    string str = \"ABC\";\n    int n = str.size();\n    vector<string> permutations;\n    printPermutations(str, 0, n - 1, permutations);\n\n    cout << \"All permutations of \" << str << \" are:\\n\";\n    for (const string& perm : permutations) {\n        cout << perm << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/backtracking-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=DKCbsiDBKcw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/backtracking/"
      ]
    ]
  },
  "two-pointer": {
    "title": "Two Pointer Technique",
    "short": "The Two Pointer technique is an algorithmic approach that uses two pointers to traverse a data structure, often an array or linked list, in a coordinated manner. It is particularly useful for solving problems involving searching pairs, finding specific conditions, or merging sorted data. By intelligently moving the pointers based on problem-specific criteria, it can often achieve optimal time complexity compared to naive approaches.",
    "time": "O(N) - Often linear, depending on the specific problem and how the pointers are moved.",
    "space": "O(1) - Usually constant, as it typically involves only a few extra variables.",
    "code": "// C++ implementation of the Two Pointer technique\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find a pair in a sorted array that sums up to a target value\nbool findPairSum(vector<int>& arr, int target) {\n    // Array must be sorted for this implementation\n    sort(arr.begin(), arr.end());\n\n    int left = 0;                  // Initialize the left pointer\n    int right = arr.size() - 1;    // Initialize the right pointer\n\n    while (left < right) {\n        int sum = arr[left] + arr[right];\n\n        if (sum == target) {\n            cout << \"Pair found: (\" << arr[left] << \", \" << arr[right] << \")\" << endl;\n            return true;          // Pair found\n        } else if (sum < target) {\n            left++;             // Move the left pointer to increase the sum\n        } else {\n            right--;            // Move the right pointer to decrease the sum\n        }\n    }\n\n    cout << \"No pair found with the given sum.\" << endl;\n    return false;               // No pair found\n}\n\nint main() {\n    vector<int> arr = {2, 7, 11, 15, 4, 9, 1, 5};  // Example array\n    int targetSum = 20;                               // Example target sum\n\n    findPairSum(arr, targetSum);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/two-pointers-technique/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=B4btxZPd_t8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/two-pointers/"
      ]
    ]
  },
  "two-pointer-problems": {
    "title": "Two Pointer Problems",
    "short": "The two-pointer technique is an algorithmic pattern that uses two pointers to iterate through a data structure (typically an array or linked list) simultaneously. It is often used to reduce the time complexity of solving problems by avoiding nested loops or redundant computations. The pointers move in a coordinated manner to find a solution, such as identifying pairs that satisfy a certain condition or reversing a portion of the data structure.",
    "time": "O(N) - where N is the size of the input data structure (array, string, linked list, etc.).",
    "space": "O(1)",
    "code": "// Two Pointer Example: Finding a pair with a given sum in a sorted array\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*\n    This function takes a sorted array and a target sum as input.\n    It uses the two-pointer technique to find if there exists a pair\n    of elements in the array whose sum is equal to the target sum.\n    \n    Returns true if such a pair exists, false otherwise.\n*/\nbool findPairWithSum(const vector<int>& arr, int targetSum) {\n    // Check if the array is empty\n    if (arr.empty()) {\n        return false;\n    }\n\n    // Initialize two pointers, one at the beginning and one at the end\n    int left = 0;\n    int right = arr.size() - 1;\n\n    // Iterate until the pointers meet\n    while (left < right) {\n        // Calculate the current sum\n        int currentSum = arr[left] + arr[right];\n\n        // If the current sum is equal to the target sum, we found a pair\n        if (currentSum == targetSum) {\n            return true;\n        }\n        // If the current sum is less than the target sum, move the left pointer to the right\n        else if (currentSum < targetSum) {\n            left++;\n        }\n        // If the current sum is greater than the target sum, move the right pointer to the left\n        else {\n            right--;\n        }\n    }\n\n    // If no pair is found, return false\n    return false;\n}\n\nint main() {\n    vector<int> arr = {2, 7, 11, 15};\n    int targetSum = 9;\n\n    if (findPairWithSum(arr, targetSum)) {\n        cout << \"Pair with sum \" << targetSum << \" exists in the array.\" << endl;\n    } else {\n        cout << \"Pair with sum \" << targetSum << \" does not exist in the array.\" << endl;\n    }\n\n    // Example with a different target\n    targetSum = 22;\n    if (findPairWithSum(arr, targetSum)) {\n        cout << \"Pair with sum \" << targetSum << \" exists in the array.\" << endl;\n    } else {\n        cout << \"Pair with sum \" << targetSum << \" does not exist in the array.\" << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/two-pointers-technique/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=jvYhJUQjT5A"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/two-pointers/"
      ]
    ]
  },
  "sliding-window": {
    "title": "Sliding Window",
    "short": "The sliding window technique is an algorithm design paradigm used to reduce the time complexity of certain problems by maintaining a \"window\" of elements within a larger data structure, typically an array or string.  This window slides across the data, performing computations only on the elements within the window at each step, rather than recomputing for the entire data set repeatedly. It's particularly effective for problems involving finding subarrays or substrings that satisfy specific conditions, such as finding the maximum sum of a contiguous subarray of a given size or finding the smallest substring containing all characters from another string.",
    "time": "O(N) - where N is the size of the input data. The window slides across the data once.",
    "space": "O(1) - The space complexity is usually constant as it typically only requires a few variables to maintain the window's state, regardless of the input size. In some specialized cases it could be O(K) where K is the window size.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the maximum sum of a subarray of size k using the sliding window technique\nint maxSubarraySum(const vector<int>& arr, int k) {\n    // Check if the array size is less than k\n    if (arr.size() < k) {\n        cout << \"Invalid: k is greater than the array size\" << endl;\n        return -1; // Return -1 to indicate an error\n    }\n\n    // Calculate the sum of the first k elements\n    int maxSum = 0;\n    for (int i = 0; i < k; ++i) {\n        maxSum += arr[i];\n    }\n\n    // Initialize the current window sum\n    int windowSum = maxSum;\n\n    // Slide the window through the array\n    for (int i = k; i < arr.size(); ++i) {\n        // Subtract the first element of the previous window and add the next element\n        windowSum += arr[i] - arr[i - k];\n\n        // Update maxSum if the current window sum is greater\n        maxSum = max(maxSum, windowSum);\n    }\n\n    return maxSum;\n}\n\nint main() {\n    vector<int> arr = {1, 4, 2, 10, 2, 3, 1, 0, 20};\n    int k = 4; // Size of the subarray\n\n    int result = maxSubarraySum(arr, k);\n\n    if (result != -1) {\n        cout << \"Maximum sum of subarray of size \" << k << \" is: \" << result << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/window-sliding-technique/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=MK-NZ4hN7rs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sliding-window/"
      ]
    ]
  },
  "advanced-data-structures": {
    "title": "B-Trees",
    "short": "A B-Tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. B-Trees are optimized for disk-oriented database systems, where reading and writing blocks of data is expensive. Unlike binary search trees, B-Trees can have multiple children (referred to as the 'order' of the tree), reducing the height of the tree and minimizing disk accesses for data retrieval.",
    "time": "Average: Access - O(log_b n), Search - O(log_b n), Insertion - O(log_b n), Deletion - O(log_b n); Best: Access - O(1), Search - O(1), Insertion - O(1), Deletion - O(1); Worst: Access - O(log_b n), Search - O(log_b n), Insertion - O(log_b n), Deletion - O(log_b n), where 'b' is the branching factor (order) of the B-Tree and 'n' is the number of keys.",
    "space": "O(n), where 'n' is the number of keys stored in the B-Tree.",
    "code": "// C++ implementation of B-Tree\n#include <iostream>\n#include <vector>\n\nclass BTreeNode {\npublic:\n    std::vector<int> keys;\n    int t;      // Minimum degree (defines the range for number of keys)\n    BTreeNode **C; // Array of child pointers\n    int n;      // Current number of keys\n    bool leaf;  // Is true when node is leaf. Otherwise false\n\n    BTreeNode(int t, bool leaf);\n\n    // A function to insert a new key in this B-Tree node\n    // Note that this function assumes that the node is not full when this\n    // function is called\n    void insertNonFull(int k);\n\n    // A function to split the child y of this node\n    void splitChild(int i, BTreeNode *y);\n\n    // A function to traverse all nodes in a subtree rooted with this node\n    void traverse();\n\n    // A function to search a key in the subtree rooted with this node.\n    BTreeNode *search(int k);\n\n    // A function to delete a key from the sub-tree rooted with this node\n    void remove(int k);\n\n    // A function to find the predecessor of a key in the subtree rooted with this node\n    int findPredecessor();\n\n    // A function to find the successor of a key in the subtree rooted with this node\n    int findSuccessor();\n\n    // A function to fill child C[idx] which has less than t-1 keys\n    void fill(int idx);\n\n    // A function to borrow a key from the previous child\n    void borrowFromPrev(int idx);\n\n    // A function to borrow a key from the next child\n    void borrowFromNext(int idx);\n\n    // A function to merge child C[idx] with C[idx+1]\n    void merge(int idx);\n};\n\nclass BTree {\npublic:\n    BTreeNode *root; // Pointer to root node\n    int t;           // Minimum degree\n\n    // Constructor\n    BTree(int t);\n\n    // function to traverse the tree\n    void traverse();\n\n    // function to search a key in this tree\n    BTreeNode *search(int k);\n\n    // function to insert a key in this tree\n    void insert(int k);\n\n    // function to delete a key in this tree\n    void remove(int k);\n};\n\n// Constructor for BTreeNode class\nBTreeNode::BTreeNode(int t, bool leaf)\n{ \n    this->t = t; \n    this->leaf = leaf; \n    keys.resize(2*t -1); // Allocate memory for maximum degree\n    C = new BTreeNode *[2*t]; //Allocate memory for child pointers\n    n = 0;  // Initialize number of keys as 0 \n}\n\n// Function to traverse all nodes in a subtree rooted with this node\nvoid BTreeNode::traverse()\n{ \n    // There are n keys and n+1 children, traverse through n keys \n    // and first n children \n    int i; \n    for (i = 0; i < n; i++) { \n        // If this is not leaf, then before printing key[i], \n        // traverse the subtree rooted with child C[i]. \n        if (leaf == false)\n            C[i]->traverse(); \n        std::cout << \" \" << keys[i]; \n    } \n  \n    // Print the subtree rooted with last child \n    if (leaf == false)\n        C[i]->traverse(); \n}\n\n// Function to search key k in subtree rooted with this node\nBTreeNode *BTreeNode::search(int k)\n{ \n    // Find the first key greater than or equal to k \n    int i = 0; \n    while (i < n && k > keys[i]) \n        i++; \n  \n    // If the key is found at index i\n    if (keys[i] == k) \n        return this; \n  \n    // If key is not found here and this is a leaf node\n    if (leaf == true) \n        return nullptr; \n  \n    // Go to the appropriate child \n    return C[i]->search(k); \n}\n\n// Function to insert a new key in this B-Tree node\n// Note that this function assumes that the node is not full when this\n// function is called\nvoid BTreeNode::insertNonFull(int k) {\n    // Initialize index as index of rightmost element\n    int i = n - 1;\n\n    // If this is a leaf node\n    if (leaf == true) {\n        // The following loop does two things\n        // a) Finds the location of new key to be inserted\n        // b) Moves all greater keys to one place ahead\n        while (i >= 0 && keys[i] > k) {\n            keys[i + 1] = keys[i];\n            i--;\n        }\n\n        // Insert the new key at found location\n        keys[i + 1] = k;\n        n = n + 1;\n    } else { // If this node is not leaf\n        // Find the child which is going to have the new key\n        while (i >= 0 && keys[i] > k)\n            i--;\n\n        // See if the found child is full\n        if (C[i + 1]->n == 2 * t - 1) {\n            // If the child is full, then split it\n            splitChild(i + 1, C[i + 1]);\n\n            // After split, the middle key of C[i] goes up and\n            // C[i] is splitted into two.  See which of the two\n            // is going to have the new key\n            if (keys[i + 1] < k)\n                i++;\n        }\n        C[i + 1]->insertNonFull(k);\n    }\n}\n\n// A function to split the child y of this node\n// Note that y must be full when this function is called\nvoid BTreeNode::splitChild(int i, BTreeNode *y) {\n    // Create a new node which is going to store t-1 keys\n    // of y\n    BTreeNode *z = new BTreeNode(y->t, y->leaf);\n    z->n = t - 1;\n\n    // Copy the last (t-1) keys of y to z\n    for (int j = 0; j < t - 1; j++)\n        z->keys[j] = y->keys[j + t];\n\n    // Copy the last t children of y to z\n    if (y->leaf == false) {\n        for (int j = 0; j < t; j++)\n            z->C[j] = y->C[j + t];\n    }\n\n    // Reduce the number of keys in y\n    y->n = t - 1;\n\n    // Since this node is going to have a new child, create space of\n    // new child\n    for (int j = n; j >= i + 1; j++)\n        C[j + 1] = C[j];\n\n    // Link the new child to this node\n    C[i + 1] = z;\n\n    // A key of y will move to this node. Find the location of\n    // new key and move all greater keys one space ahead\n    for (int j = n - 1; j >= i; j--)\n        keys[j + 1] = keys[j];\n\n    // Copy the middle key of y to this node\n    keys[i] = y->keys[t - 1];\n\n    // Increment number of keys in this node\n    n = n + 1;\n}\n\n// Constructor for BTree class\nBTree::BTree(int t)\n{ \n    root = nullptr; \n    this->t = t; \n}\n\n// Function to traverse the tree\nvoid BTree::traverse()\n{ \n    if (root != nullptr)\n        root->traverse(); \n}\n\n// Function to search a key in this tree\nBTreeNode *BTree::search(int k)\n{ \n    return (root == nullptr)? nullptr : root->search(k); \n}\n\n// Function to insert a new key in this B-Tree\nvoid BTree::insert(int k) {\n    // If tree is empty\n    if (root == nullptr) {\n        // Allocate memory for root\n        root = new BTreeNode(t, true);\n        root->keys[0] = k;  // Insert key\n        root->n = 1;  // Update number of keys in root\n    } else {\n        // If root is full, then tree grows in height\n        if (root->n == 2 * t - 1) {\n            // Allocate memory for new root\n            BTreeNode *s = new BTreeNode(t, false);\n\n            // Make old root as child of new root\n            s->C[0] = root;\n\n            // Split the old root and move 1 key to the new root\n            s->splitChild(0, root);\n\n            // New root has two children now.  Decide which of the\n            // two children is going to have new key\n            int i = 0;\n            if (s->keys[0] < k)\n                i++;\n            s->C[i]->insertNonFull(k);\n\n            // Change root\n            root = s;\n        } else {  // If root is not full, call insertNonFull for root\n            root->insertNonFull(k);\n        }\n    }\n}\n\n\nint BTreeNode::findPredecessor()\n{\n    // Keep moving to the rightmost node until we reach a leaf\n    BTreeNode *cur = this;\n    while (!cur->leaf)\n        cur = cur->C[cur->n];\n\n    // Return the last key of the leaf\n    return cur->keys[cur->n - 1];\n}\n\nint BTreeNode::findSuccessor()\n{\n    // Keep moving the leftmost node starting from C[i+1] until we reach a leaf\n    BTreeNode *cur = this;\n    while (!cur->leaf)\n        cur = cur->C[0];\n\n    // Return the first key of the leaf\n    return cur->keys[0];\n}\n\nvoid BTreeNode::fill(int idx)\n{\n    // If the previous child(C[idx-1]) has more than t-1 keys, borrow a key\n    if (idx != 0 && C[idx - 1]->n >= t) {\n        borrowFromPrev(idx);\n    }\n\n    // If the next child(C[idx+1]) has more than t-1 keys, borrow a key\n    else if (idx != n && C[idx + 1]->n >= t) {\n        borrowFromNext(idx);\n    }\n\n    // Merge C[idx] with its sibling\n    else {\n        if (idx != n) {\n            merge(idx);\n        }\n        else {\n            merge(idx - 1);\n        }\n    }\n}\n\n// Borrow a key from C[idx-1] and insert it into C[idx]\nvoid BTreeNode::borrowFromPrev(int idx)\n{\n    BTreeNode *child = C[idx];\n    BTreeNode *sibling = C[idx - 1];\n\n    // The last key from C[idx-1] goes to the parent and key[idx-1]\n    // from parent is inserted as the leftmost key in C[idx]\n    // Move all keys in C[idx] one step ahead\n    for (int i = child->n - 1; i >= 0; --i)\n        child->keys[i + 1] = child->keys[i];\n\n    // If C[idx] is not a leaf, move all its child pointers one step ahead\n    if (!child->leaf) {\n        for (int i = child->n; i >= 0; --i)\n            child->C[i + 1] = child->C[i];\n    }\n\n    // Setting the child's first key equal to keys[idx-1] from the current node\n    child->keys[0] = keys[idx - 1];\n\n    //If C[idx] is not a leaf, move the last child of sibling as the first child of C[idx]\n    if (!child->leaf)\n        child->C[0] = sibling->C[sibling->n];\n\n    // Moving the key from the sibling to the parent\n    // This key will be inserted at index idx-1 in keys[]\n    keys[idx - 1] = sibling->keys[sibling->n - 1];\n\n    // Increase n of C[idx] and decrease n of C[idx-1]\n    child->n += 1;\n    sibling->n -= 1;\n}\n\n\nvoid BTreeNode::borrowFromNext(int idx)\n{\n    BTreeNode *child = C[idx];\n    BTreeNode *sibling = C[idx + 1];\n\n    // keys[idx] is inserted as the last key in C[idx]\n    child->keys[(child->n)] = keys[idx];\n\n    // If C[idx] is not a leaf, sibling's first child is inserted as the last child of C[idx]\n    if (!(child->leaf)) {\n        child->C[(child->n) + 1] = sibling->C[0];\n    }\n\n    //The first key from sibling is inserted in keys[idx]\n    keys[idx] = sibling->keys[0];\n\n    // Move all keys in sibling one step behind\n    for (int i = 1; i < sibling->n; ++i)\n        sibling->keys[i - 1] = sibling->keys[i];\n\n    // If sibling is not a leaf, move the child pointers one step behind\n    if (!sibling->leaf) {\n        for (int i = 1; i <= sibling->n; ++i)\n            sibling->C[i - 1] = sibling->C[i];\n    }\n\n    // Increase n of C[idx] and decrease n of C[idx+1]\n    child->n += 1;\n    sibling->n -= 1;\n}\n\n\n// Merge C[idx] with C[idx+1]\n// C[idx+1] is freed after merging\nvoid BTreeNode::merge(int idx)\n{\n    BTreeNode *child = C[idx];\n    BTreeNode *sibling = C[idx + 1];\n\n    // Pulling a key from the current node and inserting it into (t-1)th\n    // position of C[idx]\n    child->keys[t - 1] = keys[idx];\n\n    // Copying the keys from C[idx+1] to C[idx] at the end\n    for (int i = 0; i < sibling->n; ++i)\n        child->keys[i + t] = sibling->keys[i];\n\n    // Copying the child pointers from C[idx+1] to C[idx]\n    if (!child->leaf) {\n        for (int i = 0; i <= sibling->n; ++i)\n            child->C[i + t] = sibling->C[i];\n    }\n\n    // Moving all keys after idx in the current node one step before -\n    // to fill the gap created by moving keys[idx] to C[idx]\n    for (int i = idx + 1; i < n; ++i)\n        keys[i - 1] = keys[i];\n\n    // Moving the child pointers after (idx+1) in the current node one\n    // step before\n    for (int i = idx + 2; i <= n; ++i)\n        C[i - 1] = C[i];\n\n    // Updating the key count of child\n    child->n += sibling->n + 1;\n\n    // Reducing the key count of the current node\n    n--;\n\n    // Freeing the memory occupied by sibling\n    delete(sibling);\n}\n\n// Function to remove the key k from the tree\nvoid BTreeNode::remove(int k) {\n    int idx = 0;\n    while (idx < n && keys[idx] < k)\n        ++idx;\n\n    // The key to be removed is present in this node\n    if (idx < n && keys[idx] == k) {\n\n        // If the node is a leaf node - removeFromLeaf is called\n        if (leaf)\n        {\n            // Remove the key from the leaf node\n            for (int i = idx + 1; i < n; ++i)\n                keys[i - 1] = keys[i];\n\n            n--;\n        }\n\n        // If the node is not a leaf node - removeFromNonLeaf is called\n        else\n        {\n            // Find the predecessor and successor of k\n            int predecessor = findPredecessor();\n            int successor = findSuccessor();\n\n            // If the child that precedes k has at least t keys\n            if (C[idx]->n >= t)\n            {\n                // Replace k with the predecessor\n                keys[idx] = predecessor;\n                // Recursively delete predecessor from the child that precedes k\n                C[idx]->remove(predecessor);\n            }\n\n            // If the child that succeeds k has at least t keys\n            else if (C[idx + 1]->n >= t)\n            {\n                // Replace k with the successor\n                keys[idx] = successor;\n\n                // Recursively delete successor from the child that succeeds k\n                C[idx + 1]->remove(successor);\n            }\n\n            // If both the child that precedes k and the child that succeeds k has less than t keys\n            else\n            {\n                // Merge k and all of C[idx+1] into C[idx]\n                merge(idx);\n                // Recursively delete k from C[idx]\n                C[idx]->remove(k);\n            }\n        }\n    }\n\n    // If the key isn't present in this node, it's in one of the children\n    else\n    {\n        // If this node is a leaf node, then the key is not present in the tree\n        if (leaf)\n        {\n            std::cout << \"The key \" << k << \" is not present in the tree\\n\";\n            return;\n        }\n\n        // The key to be removed is present in the sub-tree rooted with this node\n        // flag indicates whether the key is present in the sub-tree rooted with the last child\n        bool flag = (idx == n);\n\n        // If the child where the key is supposed to exist has less than t keys, we fill that child\n        if (C[idx]->n < t)\n            fill(idx);\n\n        // If the last child has been merged, then we recur on the (idx-1)th child. Else, we recur on the (idx)th child which now has at least t keys\n        if (flag && idx > n)\n            C[idx - 1]->remove(k);\n        else\n            C[idx]->remove(k);\n    }\n}\n\n\nvoid BTree::remove(int k) {\n    if (!root) {\n        std::cout << \"The tree is empty\\n\";\n        return;\n    }\n\n    // Call the remove function for root\n    root->remove(k);\n\n    // If the root node has 0 keys, then make the first child as the new root\n    //  if it has a child, otherwise set root as NULL\n    if (root->n == 0) {\n        BTreeNode *tmp = root;\n        if (root->leaf)\n            root = nullptr;\n        else\n            root = root->C[0];\n\n        // Free the old root\n        delete tmp;\n    }\n}\n\n\n// Driver program to test above functions\nint main() {\n    BTree t(3); // A B-Tree with minium degree 3 (t=3)\n    t.insert(10);\n    t.insert(20);\n    t.insert(5);\n    t.insert(6);\n    t.insert(12);\n    t.insert(30);\n    t.insert(7);\n    t.insert(17);\n\n    std::cout << \"Traversal of the constructed tree is \";\n    t.traverse();\n    std::cout << std::endl;\n\n    int k = 6;\n    (t.search(k) != nullptr)? std::cout << \"Present\\n\" : std::cout << \"Not Present\\n\";\n\n    k = 15;\n    (t.search(k) != nullptr)? std::cout << \"Present\\n\" : std::cout << \"Not Present\\n\";\n\n    t.remove(6);\n    std::cout << \"Traversal of the tree after deleting 6\\n\";\n    t.traverse();\n    std::cout << std::endl;\n\n    t.remove(12);\n    std::cout << \"Traversal of the tree after deleting 12\\n\";\n    t.traverse();\n    std::cout << std::endl;\n\n    t.remove(20);\n    std::cout << \"Traversal of the tree after deleting 20\\n\";\n    t.traverse();\n    std::cout << std::endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=mN6tV-i7y9w"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/n-ary-tree/"
      ]
    ]
  },
  "trie": {
    "title": "Trie (Prefix Tree)",
    "short": "A Trie, also known as a prefix tree, is a tree-like data structure used for efficient retrieval of keys in a dataset. These keys are most often strings. Each node in a trie represents a single character of a key, and the path from the root to a node represents a prefix. Tries enable fast prefix-based search and autocompletion features.",
    "time": "Average/Best/Worst Case: Access: O(1), Search: O(m), Insertion: O(m), Deletion: O(m), where m is the length of the key.",
    "space": "O(m * n * k), where m is the average key length, n is the number of keys, and k is the size of the alphabet.",
    "code": "cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int ALPHABET_SIZE = 26; // Assuming lowercase English alphabet\n\n// Trie node\nstruct TrieNode {\n    TrieNode* children[ALPHABET_SIZE];\n    bool isEndOfWord;\n\n    TrieNode() {\n        isEndOfWord = false;\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\n            children[i] = nullptr;\n        }\n    }\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a key into the trie\n    void insert(string key) {\n        TrieNode* current = root;\n        for (char c : key) {\n            int index = c - 'a';\n            if (!current->children[index]) {\n                current->children[index] = new TrieNode();\n            }\n            current = current->children[index];\n        }\n        current->isEndOfWord = true;\n    }\n\n    // Searches for a key in the trie\n    bool search(string key) {\n        TrieNode* current = root;\n        for (char c : key) {\n            int index = c - 'a';\n            if (!current->children[index]) {\n                return false;\n            }\n            current = current->children[index];\n        }\n        return (current != nullptr && current->isEndOfWord);\n    }\n\n    // Returns true if there is any word in the trie that starts with the given prefix\n    bool startsWith(string prefix) {\n        TrieNode* current = root;\n        for (char c : prefix) {\n            int index = c - 'a';\n            if (!current->children[index]) {\n                return false;\n            }\n            current = current->children[index];\n        }\n        return true;\n    }\n};\n\nint main() {\n    Trie trie;\n\n    // Insert some words\n    trie.insert(\"apple\");\n    trie.insert(\"app\");\n    trie.insert(\"application\");\n\n    // Search for words\n    cout << \"Search 'apple': \" << trie.search(\"apple\") << endl;     // Output: 1\n    cout << \"Search 'app': \" << trie.search(\"app\") << endl;         // Output: 1\n    cout << \"Search 'banana': \" << trie.search(\"banana\") << endl;   // Output: 0\n\n    // Check prefixes\n    cout << \"StartsWith 'app': \" << trie.startsWith(\"app\") << endl;   // Output: 1\n    cout << \"StartsWith 'ban': \" << trie.startsWith(\"ban\") << endl;   // Output: 0\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/trie-insert-and-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=TQ9U57iJJyk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/trie/"
      ]
    ]
  },
  "segment-tree": {
    "title": "Segment Tree",
    "short": "A Segment Tree is a tree data structure used for storing information about array intervals, or segments. It allows querying which segments contain a given point. Specifically, it can be used to efficiently perform range queries (like sum, min, max) and updates on array elements. The tree represents array intervals where each node holds aggregate information for an interval covered by it.",
    "time": "Query: O(log n), Update: O(log n), Construction: O(n)",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree; // The segment tree array\n    vector<int> arr;  // The original array\n    int n;           // Size of the original array\n\n    // Function to build the segment tree\n    void buildTree(int node, int start, int end) {\n        if (start == end) {\n            // Leaf node, store the value from the original array\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            // Recursively build the left and right subtrees\n            buildTree(2 * node, start, mid);\n            buildTree(2 * node + 1, mid + 1, end);\n            // Store the aggregate value (in this case, sum) in the current node\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    // Function to update a value in the segment tree\n    void updateValue(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            // Found the index, update the value in the original array and the tree\n            arr[idx] = val;\n            tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx >= start && idx <= mid) {\n                // Index is in the left subtree\n                updateValue(2 * node, start, mid, idx, val);\n            } else {\n                // Index is in the right subtree\n                updateValue(2 * node + 1, mid + 1, end, idx, val);\n            }\n            // Update the aggregate value in the current node\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    // Function to query the segment tree for a range sum\n    int queryRange(int node, int start, int end, int l, int r) {\n        if (l > end || r < start) {\n            // Current segment is completely outside the query range\n            return 0; //Identity Element for sum operation\n        } else if (l <= start && end <= r) {\n            // Current segment is completely inside the query range\n            return tree[node];\n        } else {\n            // Partially overlapping case\n            int mid = (start + end) / 2;\n            int p1 = queryRange(2 * node, start, mid, l, r);\n            int p2 = queryRange(2 * node + 1, mid + 1, end, l, r);\n            return (p1 + p2);\n        }\n    }\n\npublic:\n    // Constructor\n    SegmentTree(vector<int>& inputArr) {\n        arr = inputArr;\n        n = arr.size();\n        tree.resize(4 * n); // The segment tree requires 4*n space in worst case.\n        buildTree(1, 0, n - 1);\n    }\n\n    // Update value at index idx to val\n    void update(int idx, int val) {\n        updateValue(1, 0, n - 1, idx, val);\n    }\n\n    // Query for sum in range [l, r]\n    int query(int l, int r) {\n        return queryRange(1, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    vector<int> arr = {1, 3, 5, 7, 9, 11};\n    SegmentTree st(arr);\n\n    // Query for sum in range [1, 3]\n    cout << \"Sum of range [1, 3]: \" << st.query(1, 3) << endl; // Output: 15 (3 + 5 + 7)\n\n    // Update value at index 2 to 10\n    st.update(2, 10);\n\n    // Query for sum in range [1, 3] again\n    cout << \"Sum of range [1, 3] after update: \" << st.query(1, 3) << endl; // Output: 20 (3 + 10 + 7)\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=ZBHKZF5w4YU"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/segment-tree/"
      ]
    ]
  },
  "fenwick-tree": {
    "title": "Fenwick Tree (Binary Indexed Tree)",
    "short": "A Fenwick Tree, also known as a Binary Indexed Tree (BIT), is a data structure used for efficiently calculating prefix sums in an array. It allows for both querying the sum of a prefix range (from index 1 to i) and updating an element in the array in logarithmic time. It's particularly useful when frequent updates and prefix sum queries are required on the same data.",
    "time": {
      "Access": "N/A (Not applicable for prefix sum queries)",
      "Search": "N/A (Not applicable for search)",
      "Insertion": "O(log N)",
      "Deletion": "N/A (Updates mimic deletion in the sense of decrementing values)",
      "Range Sum Query": "O(log N)"
    },
    "space": "O(N)",
    "code": "// C++ implementation of Fenwick Tree (Binary Indexed Tree)\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass FenwickTree {\nprivate:\n    vector<int> bit;\n    int n;\n\npublic:\n    // Constructor: Initializes the Fenwick Tree with the given size\n    FenwickTree(int n) : n(n), bit(n + 1, 0) {}\n\n    // Constructor: Initializes the Fenwick Tree from an input array\n    FenwickTree(const vector<int>& arr) : n(arr.size()), bit(n + 1, 0) {\n        for (int i = 0; i < n; ++i) {\n            update(i, arr[i]);\n        }\n    }\n\n    // Updates the value at index 'idx' by adding 'val'\n    void update(int idx, int val) {\n        idx++; // Fenwick Tree indices are 1-based\n        while (idx <= n) {\n            bit[idx] += val;\n            idx += idx & -idx; // Move to the next index to update\n        }\n    }\n\n    // Queries the prefix sum from index 0 to 'idx'\n    int query(int idx) {\n        idx++; // Fenwick Tree indices are 1-based\n        int sum = 0;\n        while (idx > 0) {\n            sum += bit[idx];\n            idx -= idx & -idx; // Move to the next index to query\n        }\n        return sum;\n    }\n\n    // Queries the range sum from index 'l' to 'r' (inclusive)\n    int rangeSum(int l, int r) {\n        return query(r) - query(l - 1);\n    }\n};\n\nint main() {\n    vector<int> arr = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};\n    int n = arr.size();\n\n    // Create a Fenwick Tree from the array\n    FenwickTree ft(arr);\n\n    // Example usage:\n    cout << \"Sum of first 5 elements: \" << ft.query(4) << endl; // Output: 9\n    cout << \"Sum from index 2 to 6: \" << ft.rangeSum(2, 6) << endl; // Output: 13\n\n    // Update the value at index 3 by adding 5\n    ft.update(3, 5);\n\n    cout << \"Sum of first 5 elements after update: \" << ft.query(4) << endl; // Output: 14\n    cout << \"Sum from index 2 to 6 after update: \" << ft.rangeSum(2, 6) << endl; // Output: 18\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=WbafSgetDDk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-indexed-tree/"
      ]
    ]
  },
  "disjoint-set-union": {
    "title": "Disjoint Set Union (DSU)",
    "short": "Disjoint Set Union (DSU), also known as Union-Find, is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) sets. It supports two primary operations: finding which set a particular element belongs to (Find), and merging two sets together (Union). DSU is commonly used to solve problems involving connectivity, cycles, and clustering, offering efficient operations for managing disjoint sets.",
    "time": "Average: O((n)) for both Union and Find, where (n) is the inverse Ackermann function, which grows extremely slowly and is practically constant. Worst: O(log n) without path compression or union by rank, O(n) with path compression or union by rank individually, O((n)) with both path compression and union by rank.",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nclass DisjointSetUnion {\nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank;\n\npublic:\n    // Constructor: Initializes the DSU with 'n' elements, each in its own set.\n    DisjointSetUnion(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i; // Each element is initially its own parent\n        }\n    }\n\n    // Find: Returns the representative (root) of the set that 'x' belongs to.\n    // Path compression: Updates the parent pointers along the path to the root.\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    // Union: Merges the sets containing 'x' and 'y' into a single set.\n    // Union by rank: Attaches the shorter tree to the taller tree to minimize height.\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\n    // Check if two elements are connected (belong to the same set)\n    bool isConnected(int x, int y) {\n      return find(x) == find(y);\n    }\n};\n\nint main() {\n    // Example usage:\n    int n = 5; // Number of elements\n    DisjointSetUnion dsu(n);\n\n    // Unite some elements:\n    dsu.unite(0, 1);\n    dsu.unite(2, 3);\n    dsu.unite(1, 4);\n\n    // Check if elements are connected:\n    std::cout << \"Is 0 and 4 connected? \" << (dsu.isConnected(0, 4) ? \"Yes\" : \"No\") << std::endl; // Expected: Yes\n    std::cout << \"Is 0 and 2 connected? \" << (dsu.isConnected(0, 2) ? \"Yes\" : \"No\") << std::endl; // Expected: No\n\n    // Find the representative of an element:\n    std::cout << \"Representative of 4: \" << dsu.find(4) << std::endl; // Should be the same as representative of 0 and 1.\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/disjoint-set-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=VJlP9w71e8Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/union-find/"
      ]
    ]
  },
  "self-balancing-bsts": {
    "title": "Self-Balancing Binary Search Trees",
    "short": "Self-balancing Binary Search Trees (BSTs) are binary search tree data structures that automatically adjust their structure to maintain a balanced state, ensuring logarithmic time complexity for search, insertion, and deletion operations. They prevent the worst-case scenario of a skewed tree, which would degrade performance to linear time.  Examples include AVL trees, Red-Black trees, and B-trees, each employing different balancing techniques to achieve this goal. Self-balancing BSTs are crucial for efficient implementations of ordered sets and maps where frequent modifications are expected.",
    "time": "Average: Access - O(log n), Search - O(log n), Insertion - O(log n), Deletion - O(log n); Best: Access - O(1), Search - O(1), Insertion - O(1), Deletion - O(1); Worst: Access - O(log n), Search - O(log n), Insertion - O(log n), Deletion - O(log n)",
    "space": "O(n)",
    "code": "// A simple implementation of an AVL tree\n#include <iostream>\n#include <algorithm> // Required for std::max\n\n// AVL Tree Node\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    int height;\n\n    Node(int k) : key(k), left(nullptr), right(nullptr), height(1) {}\n};\n\n// Function to get the height of a node\nint height(Node* N) {\n    if (N == nullptr)\n        return 0;\n    return N->height;\n}\n\n// Function to get the balance factor of a node\nint getBalance(Node* N) {\n    if (N == nullptr)\n        return 0;\n    return height(N->left) - height(N->right);\n}\n\n// Right rotate subtree rooted with y\nNode* rightRotate(Node* y) {\n    Node* x = y->left;\n    Node* T2 = x->right;\n\n    // Perform rotation\n    x->right = y;\n    y->left = T2;\n\n    // Update heights\n    y->height = std::max(height(y->left), height(y->right)) + 1;\n    x->height = std::max(height(x->left), height(x->right)) + 1;\n\n    // Return new root\n    return x;\n}\n\n// Left rotate subtree rooted with x\nNode* leftRotate(Node* x) {\n    Node* y = x->right;\n    Node* T2 = y->left;\n\n    // Perform rotation\n    y->left = x;\n    x->right = T2;\n\n    //  Update heights\n    x->height = std::max(height(x->left), height(x->right)) + 1;\n    y->height = std::max(height(y->left), height(y->right)) + 1;\n\n    // Return new root\n    return y;\n}\n\n// Insert a node into the AVL tree\nNode* insert(Node* node, int key) {\n    // 1.  Perform the normal BST insertion\n    if (node == nullptr)\n        return (new Node(key));\n\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    else // Equal keys are not allowed in BST\n        return node;\n\n    // 2. Update height of the ancestor node\n    node->height = 1 + std::max(height(node->left), height(node->right));\n\n    // 3. Get the balance factor of this ancestor node to check whether this node became unbalanced\n    int balance = getBalance(node);\n\n    // If this node becomes unbalanced, then there are 4 cases\n\n    // Left Left Case\n    if (balance > 1 && key < node->left->key)\n        return rightRotate(node);\n\n    // Right Right Case\n    if (balance < -1 && key > node->right->key)\n        return leftRotate(node);\n\n    // Left Right Case\n    if (balance > 1 && key > node->left->key) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    // Right Left Case\n    if (balance < -1 && key < node->right->key) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    // return the (unchanged) node pointer\n    return node;\n}\n\n// A utility function to print preorder traversal of the tree.\nvoid preOrder(Node* root) {\n    if (root != nullptr) {\n        std::cout << root->key << \" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n\n// Driver code\nint main() {\n    Node* root = nullptr;\n\n    root = insert(root, 10);\n    root = insert(root, 20);\n    root = insert(root, 30);\n    root = insert(root, 40);\n    root = insert(root, 50);\n    root = insert(root, 25);\n\n    std::cout << \"Preorder traversal of the constructed AVL tree is \\n\";\n    preOrder(root);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/self-balancing-binary-search-tree/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=p96dFJuJ5rM"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search-tree/"
      ]
    ]
  },
  "heap-and-priority-queue": {
    "title": "Heap and Priority Queue",
    "short": "A heap is a specialized tree-based data structure that satisfies the heap property: in a min-heap, the value of each node is less than or equal to the value of its children; in a max-heap, the value of each node is greater than or equal to the value of its children.  Priority queues are abstract data types that provide access to the element with the highest (or lowest) priority. Heaps are commonly used to implement priority queues efficiently because they provide fast access to the minimum or maximum element and maintain the heap property efficiently after insertion or deletion.",
    "time": "Access: O(1) (for min/max element), Search: O(n), Insertion: O(log n), Deletion: O(log n), Heapify: O(n)",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass MinHeap {\nprivate:\n    std::vector<int> heap;\n\n    // Helper function to maintain the min-heap property\n    void heapify(int i) {\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        int smallest = i;\n\n        if (left < heap.size() && heap[left] < heap[smallest]) {\n            smallest = left;\n        }\n\n        if (right < heap.size() && heap[right] < heap[smallest]) {\n            smallest = right;\n        }\n\n        if (smallest != i) {\n            std::swap(heap[i], heap[smallest]);\n            heapify(smallest);\n        }\n    }\n\npublic:\n    MinHeap() {}\n\n    // Insert a new element into the heap\n    void insert(int key) {\n        heap.push_back(key);\n        int i = heap.size() - 1;\n\n        // Maintain the min-heap property after insertion\n        while (i != 0 && heap[(i - 1) / 2] > heap[i]) {\n            std::swap(heap[i], heap[(i - 1) / 2]);\n            i = (i - 1) / 2;\n        }\n    }\n\n    // Extract the minimum element from the heap\n    int extractMin() {\n        if (heap.empty()) {\n            return -1; // Or throw an exception\n        }\n\n        if (heap.size() == 1) {\n            int root = heap[0];\n            heap.pop_back();\n            return root;\n        }\n\n        int root = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n        heapify(0);\n\n        return root;\n    }\n\n    // Get the minimum element without removing it\n    int getMin() {\n        if (!heap.empty()) {\n            return heap[0];\n        } else {\n            return -1; // or throw exception\n        }\n    }\n\n    // Check if the heap is empty\n    bool isEmpty() {\n        return heap.empty();\n    }\n\n    //Print Heap\n    void printHeap() {\n      for (int i = 0; i < heap.size(); ++i){\n        std::cout << heap[i] << \" \";\n      }\n      std::cout << std::endl;\n    }\n};\n\nint main() {\n    MinHeap minHeap;\n    minHeap.insert(3);\n    minHeap.insert(2);\n    minHeap.insert(15);\n    minHeap.insert(5);\n    minHeap.insert(4);\n    minHeap.insert(45);\n\n    std::cout << \"Min element: \" << minHeap.getMin() << std::endl;\n    std::cout << \"Heap elements: \";\n    minHeap.printHeap();\n\n    std::cout << \"Extracting min: \" << minHeap.extractMin() << std::endl;\n    std::cout << \"New min element: \" << minHeap.getMin() << std::endl;\n    std::cout << \"Heap elements: \";\n    minHeap.printHeap();\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/heap-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=t0cQ6tVNRBA"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/heap-priority-queue/"
      ]
    ]
  },
  "greedy-algorithms": {
    "title": "Greedy Algorithms",
    "short": "Greedy algorithms are an algorithmic paradigm that makes the locally optimal choice at each step with the hope of finding a global optimum. They are straightforward and often efficient but do not guarantee an optimal solution for all problems.  Greedy approaches are suitable for optimization problems where a series of choices needs to be made, and the locally best choice at each step leads to a globally good solution.",
    "time": "Varies greatly depending on the problem and implementation. Generally, O(n log n) if sorting is involved; otherwise, O(n) in many cases.",
    "space": "Varies depending on the problem. Can range from O(1) to O(n) in certain cases.",
    "code": "// A C++ implementation of a greedy algorithm for the Fractional Knapsack problem\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an item in the knapsack\nstruct Item {\n    int value;\n    int weight;\n    double ratio; // Value/Weight ratio\n\n    Item(int v, int w) : value(v), weight(w) { ratio = (double)v / w; }\n};\n\n// Function to compare items based on their value/weight ratio in descending order\nbool compareItems(const Item& a, const Item& b) {\n    return a.ratio > b.ratio;\n}\n\n// Function to solve the Fractional Knapsack problem using a greedy approach\ndouble fractionalKnapsack(int capacity, vector<Item>& items) {\n    // Sort items based on their value/weight ratio\n    sort(items.begin(), items.end(), compareItems);\n\n    double totalValue = 0.0;\n    int currentWeight = 0;\n\n    // Iterate through the sorted items\n    for (const auto& item : items) {\n        // If the item can be added completely\n        if (currentWeight + item.weight <= capacity) {\n            currentWeight += item.weight;\n            totalValue += item.value;\n        } else {\n            // If the item can be added partially\n            int remainingCapacity = capacity - currentWeight;\n            totalValue += item.ratio * remainingCapacity;\n            break; // Knapsack is full\n        }\n    }\n\n    return totalValue;\n}\n\nint main() {\n    int capacity = 50;\n    vector<Item> items;\n    items.emplace_back(60, 10);\n    items.emplace_back(100, 20);\n    items.emplace_back(120, 30);\n\n    double maxValue = fractionalKnapsack(capacity, items);\n\n    cout << \"Maximum value in Knapsack = \" << maxValue << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/greedy-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=ARvKFc5jJRs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/greedy/"
      ]
    ]
  },
  "activity": {
    "title": "Activity Selection Problem",
    "short": "The Activity Selection Problem is a classic optimization problem where the goal is to select the maximum number of non-overlapping activities from a set of activities, each with a start and finish time.  It's typically solved using a greedy approach, where activities are sorted by their finish times, and then iteratively selecting activities that don't overlap with previously selected ones. This problem is frequently encountered in scheduling and resource allocation scenarios.",
    "time": "O(n log n) for sorting, O(n) for selection",
    "space": "O(1) excluding the input array",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an activity\nstruct Activity {\n    int start;\n    int finish;\n};\n\n// Custom comparison function to sort activities based on finish time\nbool compareActivities(const Activity &a, const Activity &b) {\n    return (a.finish < b.finish);\n}\n\n// Function to solve the Activity Selection Problem\nvector<Activity> activitySelection(vector<Activity> activities) {\n    int n = activities.size();\n\n    // Sort activities based on their finish times\n    sort(activities.begin(), activities.end(), compareActivities);\n\n    vector<Activity> selectedActivities;\n\n    // The first activity is always selected\n    selectedActivities.push_back(activities[0]);\n\n    // Index of the last selected activity\n    int lastSelected = 0;\n\n    // Iterate through the remaining activities\n    for (int i = 1; i < n; i++) {\n        // If the current activity's start time is greater than or equal to the finish time\n        // of the last selected activity, then select it\n        if (activities[i].start >= activities[lastSelected].finish) {\n            selectedActivities.push_back(activities[i]);\n            lastSelected = i;\n        }\n    }\n\n    return selectedActivities;\n}\n\nint main() {\n    // Example usage\n    vector<Activity> activities = {\n        {1, 2},\n        {3, 4},\n        {0, 6},\n        {5, 7},\n        {8, 9},\n        {5, 9}\n    };\n\n    vector<Activity> selected = activitySelection(activities);\n\n    cout << \"Selected Activities:\" << endl;\n    for (const auto &activity : selected) {\n        cout << \"Start: \" << activity.start << \", Finish: \" << activity.finish << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=II6ziNqyOxI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/5050848008466544/"
      ]
    ]
  },
  "huffman-coding": {
    "title": "Huffman Coding",
    "short": "Huffman coding is a lossless data compression algorithm that assigns variable-length codes to input characters based on their frequency of occurrence. More frequent characters are assigned shorter codes, and less frequent characters are assigned longer codes, resulting in efficient data representation. It utilizes a greedy approach, constructing a binary tree where each leaf node represents a character and its frequency, ultimately generating prefix codes that enable unambiguous decoding.",
    "time": "Encoding/Decoding: O(n log n), Building Huffman Tree: O(n log n) where n is the number of unique characters.",
    "space": "O(n) where n is the number of unique characters.",
    "code": " #include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n// Structure for a node in the Huffman tree\nstruct HuffmanNode {\n    char data;\n    unsigned frequency;\n    HuffmanNode *left, *right;\n\n    HuffmanNode(char data, unsigned frequency) : data(data), frequency(frequency), left(nullptr), right(nullptr) {}\n};\n\n// Comparison object to be used in the priority queue\nstruct Compare {\n    bool operator()(HuffmanNode* l, HuffmanNode* r) {\n        return (l->frequency > r->frequency);\n    }\n};\n\n// Function to build the Huffman tree\nHuffmanNode* buildHuffmanTree(map<char, int> frequencies) {\n    // Create a priority queue to store the nodes of the tree\n    priority_queue<HuffmanNode*, vector<HuffmanNode*>, Compare> pq;\n\n    // Create a leaf node for each character and add it to the priority queue\n    for (auto const& [character, frequency] : frequencies) {\n        pq.push(new HuffmanNode(character, frequency));\n    }\n\n    // Build the Huffman tree\n    while (pq.size() > 1) {\n        // Extract the two nodes with the lowest frequency\n        HuffmanNode *left = pq.top();\n        pq.pop();\n        HuffmanNode *right = pq.top();\n        pq.pop();\n\n        // Create a new internal node with a frequency equal to the sum of the two nodes' frequencies\n        HuffmanNode *newNode = new HuffmanNode('$', left->frequency + right->frequency);\n        newNode->left = left;\n        newNode->right = right;\n\n        // Add the new node to the priority queue\n        pq.push(newNode);\n    }\n\n    // The root of the Huffman tree is the only node left in the priority queue\n    return pq.top();\n}\n\n// Function to generate Huffman codes from the Huffman tree\nvoid generateHuffmanCodes(HuffmanNode* root, string code, map<char, string> &huffmanCodes) {\n    if (root == nullptr) {\n        return;\n    }\n\n    // If it is a leaf node, then it represents a character\n    if (root->data != '$') {\n        huffmanCodes[root->data] = code;\n    }\n\n    // Recursively traverse the tree\n    generateHuffmanCodes(root->left, code + \"0\", huffmanCodes);\n    generateHuffmanCodes(root->right, code + \"1\", huffmanCodes);\n}\n\nint main() {\n    // Example input\n    string text = \"Huffman coding example\";\n\n    // Calculate character frequencies\n    map<char, int> frequencies;\n    for (char c : text) {\n        frequencies[c]++;\n    }\n\n    // Build the Huffman tree\n    HuffmanNode* root = buildHuffmanTree(frequencies);\n\n    // Generate Huffman codes\n    map<char, string> huffmanCodes;\n    generateHuffmanCodes(root, \"\", huffmanCodes);\n\n    // Print Huffman codes\n    cout << \"Huffman Codes:\" << endl;\n    for (auto const& [character, code] : huffmanCodes) {\n        cout << character << \": \" << code << endl;\n    }\n\n    // Encode the input text\n    string encodedText = \"\";\n    for (char c : text) {\n        encodedText += huffmanCodes[c];\n    }\n\n    cout << \"\\nEncoded Text: \" << encodedText << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/huffman-coding/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=JAHYR6qiWLs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/huffman-tree/"
      ]
    ]
  },
  "fractional-knapsack": {
    "title": "Fractional Knapsack",
    "short": "The Fractional Knapsack problem is an optimization problem where you aim to maximize the value of items you can fit into a knapsack with a limited weight capacity. Unlike the 0/1 knapsack problem, you can take fractions of items. The core idea is to prioritize items with the highest value-to-weight ratio, taking as much of each as possible until the knapsack is full, thereby maximizing the total value within the weight constraint.",
    "time": "O(n log n) for sorting + O(n) for iterating through the sorted items, hence O(n log n).",
    "space": "O(1) excluding the space used for storing the initial items array, or O(n) if sorting algorithms like merge sort are used.",
    "code": "// C++ implementation of the Fractional Knapsack problem\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an item with its weight and value\nstruct Item {\n    int value;\n    int weight;\n};\n\n// Comparison function to sort items based on value-to-weight ratio in descending order\nbool compareItems(const Item& a, const Item& b) {\n    double ratioA = (double)a.value / a.weight;\n    double ratioB = (double)b.value / b.weight;\n    return ratioA > ratioB;\n}\n\n// Function to solve the Fractional Knapsack problem\ndouble fractionalKnapsack(int capacity, vector<Item>& items) {\n    // Sort items based on value-to-weight ratio\n    sort(items.begin(), items.end(), compareItems);\n\n    double totalValue = 0.0;  // Initialize total value\n\n    // Iterate through sorted items\n    for (const auto& item : items) {\n        // If the item's weight is less than or equal to the remaining capacity,\n        // take the whole item\n        if (item.weight <= capacity) {\n            capacity -= item.weight;\n            totalValue += item.value;\n        } else {\n            // Otherwise, take a fraction of the item\n            totalValue += (double)item.value * ((double)capacity / item.weight);\n            capacity = 0; // Knapsack is full\n            break;         // No more space in knapsack\n        }\n    }\n\n    return totalValue;\n}\n\nint main() {\n    int capacity = 50;  // Knapsack capacity\n\n    // Example items\n    vector<Item> items = {\n        {60, 10},\n        {100, 20},\n        {120, 30}\n    };\n\n    // Calculate the maximum value that can be obtained\n    double maxValue = fractionalKnapsack(capacity, items);\n\n    // Print the result\n    cout << \"Maximum value that can be obtained: \" << maxValue << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/fractional-knapsack-problem/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=F_DDzYnxO14"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/knapsack-problems/"
      ]
    ]
  },
  "job-sequencing-with-deadlines": {
    "title": "Job Sequencing with Deadlines",
    "short": "Job Sequencing with Deadlines is a greedy algorithm used to determine the optimal sequence of jobs to maximize profit, given a set of jobs with associated deadlines and profits. The algorithm works by sorting the jobs in descending order of profit and then iterating through the sorted list, attempting to schedule each job as late as possible before its deadline. The primary use case is to maximize earnings when faced with constraints on job completion times.",
    "time": "Average: O(n log n) for sorting and O(n*m) in worst case where n is number of jobs and m is maximum deadline. Best: O(n log n) if all slots are empty, Worst: O(n^2) if slot finding becomes sequential.",
    "space": "O(m) where m is the maximum deadline.",
    "code": " #include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent a job\nstruct Job {\n    char id;      // Job identifier\n    int deadline; // Deadline of the job\n    int profit;   // Profit earned by completing the job\n};\n\n// Function to compare jobs based on profit (for sorting)\nbool comparison(Job a, Job b) {\n    return (a.profit > b.profit);\n}\n\n// Function to schedule jobs to maximize profit\nvoid jobScheduling(vector<Job> jobs, int n) {\n    // Sort jobs in descending order of profit\n    sort(jobs.begin(), jobs.end(), comparison);\n\n    // Find the maximum deadline to determine the size of the schedule\n    int maxDeadline = 0;\n    for (int i = 0; i < n; i++) {\n        maxDeadline = max(maxDeadline, jobs[i].deadline);\n    }\n\n    // Initialize an array to store the schedule (0 indicates an empty slot)\n    vector<bool> slot(maxDeadline, false);\n\n    // Array to store the result (sequence of jobs)\n    vector<char> result(maxDeadline);\n\n    int totalProfit = 0;\n\n    // Iterate through the sorted jobs\n    for (int i = 0; i < n; i++) {\n        // Find a suitable slot for the job (as late as possible before its deadline)\n        for (int j = min(maxDeadline, jobs[i].deadline) - 1; j >= 0; j--) {\n            if (slot[j] == false) {\n                slot[j] = true;          // Mark the slot as occupied\n                result[j] = jobs[i].id;    // Assign the job to the slot\n                totalProfit += jobs[i].profit; // Add the profit to the total\n                break;                     // Move to the next job\n            }\n        }\n    }\n\n    // Print the scheduled jobs and the total profit\n    cout << \"Scheduled jobs: \";\n    for (int i = 0; i < maxDeadline; i++) {\n        if (slot[i]) {\n            cout << result[i] << \" \";\n        }\n    }\n    cout << endl;\n    cout << \"Total profit: \" << totalProfit << endl;\n}\n\nint main() {\n    vector<Job> jobs = {\n        {'a', 2, 100},\n        {'b', 1, 19},\n        {'c', 2, 27},\n        {'d', 1, 25},\n        {'e', 3, 15}\n    };\n\n    int n = jobs.size();\n\n    jobScheduling(jobs, n);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/job-sequencing-problem/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=LjPx3c1L8l8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/job-scheduling-algorithms/"
      ]
    ]
  },
  "dijkstra": {
    "title": "Dijkstra's Algorithm",
    "short": "Dijkstra's algorithm is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge weights, producing a shortest path tree. It works by iteratively selecting the unvisited node with the smallest tentative distance from the source node and updating the distances to its neighbors. Dijkstra's is commonly used in network routing protocols and GPS navigation systems to find the most efficient paths.",
    "time": {
      "average": "O(E + V log V) using a priority queue, O(V^2) with a linear search",
      "best": "O(E + V log V) using a priority queue, O(V^2) with a linear search",
      "worst": "O(E + V log V) using a priority queue, O(V^2) with a linear search"
    },
    "space": "O(V)",
    "code": "// C++ implementation of Dijkstra's algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\n// Structure to represent an edge in the graph\nstruct Edge {\n    int to;\n    int weight;\n};\n\n// Function to implement Dijkstra's algorithm\nvector<int> dijkstra(const vector<vector<Edge>>& graph, int startNode) {\n    int numNodes = graph.size();\n    vector<int> dist(numNodes, numeric_limits<int>::max()); // Initialize distances to infinity\n    dist[startNode] = 0; // Distance from the start node to itself is 0\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // Priority queue to store nodes and their distances\n    pq.push({0, startNode}); // Push the start node with distance 0\n\n    while (!pq.empty()) {\n        int d = pq.top().first; // Current distance\n        int u = pq.top().second; // Current node\n        pq.pop();\n\n        if (d > dist[u]) {\n            continue; // Skip if we have already found a shorter path to this node\n        }\n\n        // Iterate through all the neighbors of the current node\n        for (const Edge& edge : graph[u]) {\n            int v = edge.to; // Neighbor node\n            int weight = edge.weight; // Weight of the edge\n\n            // If we find a shorter path to the neighbor node, update the distance\n            if (dist[v] > dist[u] + weight) {\n                dist[v] = dist[u] + weight; // Update the distance\n                pq.push({dist[v], v}); // Push the neighbor node with the new distance\n            }\n        }\n    }\n\n    return dist; // Return the distances from the start node to all other nodes\n}\n\nint main() {\n    // Example graph represented as an adjacency list\n    vector<vector<Edge>> graph = {\n        {{1, 4}, {2, 2}},\n        {{2, 5}, {3, 10}},\n        {{1, 1}, {3, 8}},\n        {{4, 2}},\n        {{}}\n    };\n\n    int startNode = 0; // Starting node\n\n    // Calculate shortest distances from the start node\n    vector<int> shortestDistances = dijkstra(graph, startNode);\n\n    // Print the shortest distances\n    cout << \"Shortest distances from node \" << startNode << \":\" << endl;\n    for (int i = 0; i < shortestDistances.size(); ++i) {\n        cout << \"To node \" << i << \": \" << shortestDistances[i] << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=pVfj6mNz1gY"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dijkstra/"
      ]
    ]
  },
  "dynamic-programming": {
    "title": "Dynamic Programming",
    "short": "Dynamic programming is an algorithmic paradigm that solves complex problems by breaking them down into overlapping subproblems, solving each subproblem only once, and storing the solutions to avoid redundant computations. It's particularly effective for optimization problems, where the goal is to find the best solution among many possibilities.  Common applications include sequence alignment, shortest path finding, and knapsack problems.",
    "time": "Varies greatly depending on the specific problem. Generally polynomial time, such as O(n^2) or O(n*m), where 'n' and 'm' are input sizes. Individual operations like access are typically O(1).",
    "space": "Varies depending on the problem, but typically O(n) or O(n^2), where 'n' is the input size. Space is used to store the solutions to subproblems.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// A simple example: calculating the nth Fibonacci number using dynamic programming (memoization).\n\n// Recursive function with memoization to calculate Fibonacci numbers.\nint fibonacci(int n, vector<int>& memo) {\n  // Base cases\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n\n  // Check if the result is already memoized\n  if (memo[n] != -1) {\n    return memo[n];\n  }\n\n  // Calculate the Fibonacci number recursively and store it in the memo\n  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n  return memo[n];\n}\n\n// Function to calculate the nth Fibonacci number using dynamic programming.\nint fibonacci_dp(int n) {\n  // Create a memoization table to store calculated Fibonacci numbers.\n  vector<int> memo(n + 1, -1); // Initialize all values to -1 (not calculated).\n\n  // Call the recursive function with memoization.\n  return fibonacci(n, memo);\n}\n\n// Example: 0-1 Knapsack problem using dynamic programming\nint knapsack(int W, vector<int>& weights, vector<int>& values, int n) {\n    // dp[i][w] stores the maximum value that can be obtained with items up to index i\n    // and with a maximum weight of w.\n    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));\n\n    // Build the dp table in bottom-up manner\n    for (int i = 0; i <= n; i++) {\n        for (int w = 0; w <= W; w++) {\n            if (i == 0 || w == 0) {\n                dp[i][w] = 0;\n            } else if (weights[i - 1] <= w) {\n                // If the weight of the current item is less than or equal to the current weight,\n                // we can either include it or exclude it.  We choose the option that gives us the maximum value.\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);\n            } else {\n                // If the weight of the current item is greater than the current weight,\n                // we exclude it.\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n\n    return dp[n][W];\n}\n\nint main() {\n  // Example usage for Fibonacci\n  int n = 10;\n  cout << \"Fibonacci(\" << n << \") = \" << fibonacci_dp(n) << endl;\n\n    // Example Usage for Knapsack\n    vector<int> values = {60, 100, 120};\n    vector<int> weights = {10, 20, 30};\n    int W = 50;\n    int knapsack_n = values.size();\n\n    cout << \"Maximum value in Knapsack: \" << knapsack(W, weights, values, knapsack_n) << endl;\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/dynamic-programming/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=OQ5uA2x0c_I"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dynamic-programming/"
      ]
    ]
  },
  "fibonacci-sequence": {
    "title": "Fibonacci Sequence",
    "short": "The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence begins 0, 1, 1, 2, 3, 5, 8, and so on. It demonstrates a recursive relationship and is frequently used in computer science for demonstrating recursion, dynamic programming, and algorithm analysis. It also has applications in fields like mathematics, nature, and finance.",
    "time": "Naive Recursive: O(2^n), Dynamic Programming: O(n)",
    "space": "Naive Recursive: O(n) (call stack), Dynamic Programming: O(n) (memoization array/vector)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Naive Recursive Implementation (inefficient for large n)\nint fibonacciRecursive(int n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);\n}\n\n// Dynamic Programming Implementation (Memoization) - Efficient\nint fibonacciDP(int n, vector<int>& memo) {\n  if (n <= 1) {\n    return n;\n  }\n\n  // Check if the value is already computed\n  if (memo[n] != -1) {\n    return memo[n];\n  }\n\n  // Compute and store the value in memo\n  memo[n] = fibonacciDP(n - 1, memo) + fibonacciDP(n - 2, memo);\n  return memo[n];\n}\n\n// Iterative Dynamic Programming (Bottom-up) - Most Efficient\nint fibonacciIterative(int n) {\n    if (n <= 1) {\n        return n;\n    }\n\n    vector<int> fib(n + 1);\n    fib[0] = 0;\n    fib[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        fib[i] = fib[i - 1] + fib[i - 2];\n    }\n\n    return fib[n];\n}\n\nint main() {\n  int n = 10; // Calculate the 10th Fibonacci number\n\n  cout << \"Fibonacci sequence up to \" << n << \": \";\n  for(int i = 0; i <= n; ++i) {\n      cout << fibonacciIterative(i) << \" \";\n  }\n  cout << endl;\n\n  cout << \"\\nUsing Naive Recursive (inefficient): Fibonacci(\" << n << \") = \" << fibonacciRecursive(n) << endl;\n\n  // Initialize memoization vector for Dynamic Programming\n  vector<int> memo(n + 1, -1); // Initialize all values to -1 (not computed)\n  cout << \"Using Dynamic Programming (Memoization): Fibonacci(\" << n << \") = \" << fibonacciDP(n, memo) << endl;\n\n  cout << \"Using Iterative Dynamic Programming (Bottom-up): Fibonacci(\" << n << \") = \" << fibonacciIterative(n) << endl;\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=oBT53jJkQGc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/fibonacci-number/"
      ]
    ]
  },
  "coin-change": {
    "title": "Coin Change",
    "short": "The Coin Change problem is a classic dynamic programming problem that asks for the minimum number of coins required to make a specific amount of money, given a set of coin denominations. It explores all possible combinations of coins that add up to the target amount. Dynamic programming, using either a top-down (memoization) or bottom-up (tabulation) approach, allows efficient computation by storing and reusing intermediate results, avoiding redundant calculations and optimizing the search for the optimal solution.",
    "time": "O(amount * number of coins)",
    "space": "O(amount)",
    "code": "// Coin Change Problem using Dynamic Programming (Bottom-Up Approach)\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint coinChange(vector<int>& coins, int amount) {\n    // dp[i] will store the minimum number of coins needed to make amount i\n    vector<int> dp(amount + 1, amount + 1); // Initialize with a value greater than the maximum possible number of coins\n    \n    dp[0] = 0; // Base case: 0 coins are needed to make an amount of 0\n\n    // Iterate through all amounts from 1 to the target amount\n    for (int i = 1; i <= amount; ++i) {\n        // Iterate through each coin denomination\n        for (int coin : coins) {\n            // If the coin value is less than or equal to the current amount\n            if (coin <= i) {\n                // Update dp[i] with the minimum number of coins needed\n                // either the existing value or 1 (current coin) + the number of coins needed to make the remaining amount (i - coin)\n                dp[i] = min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n\n    // If dp[amount] is still the initial value, it means no combination of coins can make the target amount\n    // Return -1 in that case\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n\nint main() {\n    vector<int> coins = {1, 2, 5}; // Example coin denominations\n    int amount = 11; // Example target amount\n\n    int result = coinChange(coins, amount);\n\n    if (result == -1) {\n        cout << \"Cannot make the amount with the given coins.\" << endl;\n    } else {\n        cout << \"Minimum number of coins needed: \" << result << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/coin-change-dp-7/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=H9bfqozjoqs"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dynamic-programming/"
      ]
    ]
  },
  "longest-increasing-subsequence": {
    "title": "Longest Increasing Subsequence (LIS)",
    "short": "The Longest Increasing Subsequence (LIS) problem aims to find the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order. It does not require the subsequence to be contiguous. Dynamic programming and binary search-based approaches are commonly used to solve this problem efficiently. LIS has applications in various domains, including data analysis, bioinformatics, and computer graphics.",
    "time": "O(n log n) (using binary search); O(n^2) (using dynamic programming)",
    "space": "O(n)",
    "code": "// C++ implementation of Longest Increasing Subsequence using binary search\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint longestIncreasingSubsequence(const vector<int>& nums) {\n    // tails[i] is the smallest tail of all increasing subsequences with length i+1.\n    vector<int> tails;\n\n    for (int num : nums) {\n        // If we find a number in `tails` that is greater than or equal to `num`,\n        // we replace it with `num` because `num` allows us to create an increasing\n        // subsequence with the same length but smaller tail.\n        auto it = lower_bound(tails.begin(), tails.end(), num);\n\n        if (it == tails.end()) {\n            // If `num` is greater than all tails, it extends the longest increasing subsequence by 1.\n            tails.push_back(num);\n        } else {\n            // Otherwise, we replace the smallest element >= `num` with `num`.\n            *it = num;\n        }\n    }\n\n    // The length of `tails` is the length of the longest increasing subsequence.\n    return tails.size();\n}\n\nint main() {\n    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18}; // Example input\n    int lisLength = longestIncreasingSubsequence(nums);\n    cout << \"Length of Longest Increasing Subsequence: \" << lisLength << endl; // Output: 4\n\n    vector<int> nums2 = {0,1,0,3,2,3}; //Another test case\n    lisLength = longestIncreasingSubsequence(nums2);\n    cout << \"Length of Longest Increasing Subsequence: \" << lisLength << endl; // Output: 4\n\n    vector<int> nums3 = {7,7,7,7,7,7,7}; //Test case with all same values\n    lisLength = longestIncreasingSubsequence(nums3);\n    cout << \"Length of Longest Increasing Subsequence: \" << lisLength << endl; // Output: 1\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/longest-increasing-subsequence-dp/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=cjWnW0hdF1Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/longest-increasing-subsequence/"
      ]
    ]
  },
  "longest-common-subsequence": {
    "title": "Longest Common Subsequence (LCS)",
    "short": "The Longest Common Subsequence (LCS) problem aims to find the longest subsequence common to two or more sequences. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The dynamic programming approach is typically used to solve it by building a table of LCS lengths for prefixes of the sequences, which is then used to reconstruct the LCS itself. It has applications in bioinformatics (sequence alignment) and diff utilities.",
    "time": "Average: O(m*n), Best: O(m*n), Worst: O(m*n) where m and n are the lengths of the two sequences.",
    "space": "O(m*n)",
    "code": "// C++ implementation of Longest Common Subsequence\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the Longest Common Subsequence of two strings\nstring longestCommonSubsequence(const string& text1, const string& text2) {\n  int m = text1.length();\n  int n = text2.length();\n\n  // Create a 2D vector to store lengths of LCS for subproblems\n  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n  // Build the dp table in bottom-up manner\n  for (int i = 1; i <= m; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      if (text1[i - 1] == text2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1; // If characters match, add 1 to the LCS length of previous prefixes\n      } else {\n        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); // Otherwise, take the maximum LCS length from previous prefixes\n      }\n    }\n  }\n\n  // Reconstruct the LCS string\n  string lcs = \"\";\n  int i = m, j = n;\n  while (i > 0 && j > 0) {\n    if (text1[i - 1] == text2[j - 1]) {\n      lcs = text1[i - 1] + lcs; // If characters match, add it to the LCS\n      i--;\n      j--;\n    } else if (dp[i - 1][j] > dp[i][j - 1]) {\n      i--; // Move up if LCS length from above is greater\n    } else {\n      j--; // Move left if LCS length from the left is greater\n    }\n  }\n\n  return lcs;\n}\n\nint main() {\n  string text1 = \"AGGTAB\";\n  string text2 = \"GXTXAYB\";\n\n  string lcs = longestCommonSubsequence(text1, text2);\n\n  cout << \"Longest Common Subsequence is: \" << lcs << endl; // Output: GTAB\n\n  string text3 = \"abcde\";\n  string text4 = \"ace\";\n\n  lcs = longestCommonSubsequence(text3, text4);\n  cout << \"Longest Common Subsequence is: \" << lcs << endl; // Output: ace\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=NnD96BjUcb0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/longest-common-subsequence/"
      ]
    ]
  },
  "edit-distance": {
    "title": "Edit Distance (Levenshtein Distance)",
    "short": "Edit Distance, also known as Levenshtein distance, quantifies the similarity between two strings by counting the minimum number of single-character edits required to change one string into the other. These edits include insertions, deletions, and substitutions. It's commonly used in spell checking, DNA sequencing, and information retrieval to find approximate string matches.",
    "time": "Average: O(m*n), Best: O(min(m, n)), Worst: O(m*n), where m and n are the lengths of the two strings.",
    "space": "O(m*n)",
    "code": " #include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the minimum of three integers\nint min3(int a, int b, int c) {\n    return min(a, min(b, c));\n}\n\n// Function to calculate the edit distance between two strings\nint editDistance(const string& str1, const string& str2) {\n    int m = str1.length();\n    int n = str2.length();\n\n    // Create a matrix to store the edit distances between prefixes of the strings\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n    // Initialize the first row and column of the matrix\n    for (int i = 0; i <= m; ++i) {\n        dp[i][0] = i; // i deletions to transform str1[0...i-1] to \"\"\n    }\n    for (int j = 0; j <= n; ++j) {\n        dp[0][j] = j; // j insertions to transform \"\" to str2[0...j-1]\n    }\n\n    // Fill in the rest of the matrix using dynamic programming\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (str1[i - 1] == str2[j - 1]) {\n                // If the characters match, no cost is added\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // If the characters don't match, consider insertion, deletion, and substitution\n                dp[i][j] = min3(\n                    dp[i - 1][j] + 1,   // Deletion\n                    dp[i][j - 1] + 1,   // Insertion\n                    dp[i - 1][j - 1] + 1 // Substitution\n                );\n            }\n        }\n    }\n\n    // The edit distance is stored in the bottom-right cell of the matrix\n    return dp[m][n];\n}\n\nint main() {\n    string str1 = \"kitten\";\n    string str2 = \"sitting\";\n\n    int distance = editDistance(str1, str2);\n\n    cout << \"Edit distance between \\\"\" << str1 << \"\\\" and \\\"\" << str2 << \"\\\" is: \" << distance << endl; // Expected: 3\n\n    string str3 = \"intention\";\n    string str4 = \"execution\";\n\n    distance = editDistance(str3, str4);\n\n    cout << \"Edit distance between \\\"\" << str3 << \"\\\" and \\\"\" << str4 << \"\\\" is: \" << distance << endl; // Expected: 5\n\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/edit-distance-dp-5/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=We3YDTzNXEk"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/edit-distance/"
      ]
    ]
  },
  "matrix-chain-multiplication": {
    "title": "Matrix Chain Multiplication",
    "short": "Matrix Chain Multiplication is an optimization problem that aims to find the most efficient way to multiply a sequence of matrices. Because matrix multiplication is associative, the order in which we perform the multiplications can significantly impact the total number of scalar multiplications required. Dynamic programming is typically used to determine the optimal parenthesization, minimizing the computational cost.",
    "time": "O(n^3)",
    "space": "O(n^2)",
    "code": "// C++ implementation of Matrix Chain Multiplication using Dynamic Programming\n#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\n// Function to find the minimum number of scalar multiplications needed to multiply the chain of matrices\nint matrixChainMultiplication(vector<int>& dimensions) {\n    int n = dimensions.size() - 1; // Number of matrices (dimensions includes one extra value)\n\n    // m[i][j] = Minimum number of scalar multiplications needed to compute the matrix A_i A_{i+1} ... A_j\n    vector<vector<int>> m(n, vector<int>(n, 0));\n\n    // s[i][j] = index k at which we split the product A_i A_{i+1} ... A_j for optimal parenthesization\n    vector<vector<int>> s(n, vector<int>(n, 0));\n\n    // l is chain length.  Chain of length 1 is already solved (cost is 0)\n    for (int l = 2; l <= n; l++) {\n        for (int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            m[i][j] = INT_MAX;\n\n            // Try all possible places for parenthesis\n            for (int k = i; k < j; k++) {\n                // q = cost/scalar multiplications to place parenthesis at position k\n                int q = m[i][k] + m[k + 1][j] + dimensions[i] * dimensions[k + 1] * dimensions[j + 1];\n\n                if (q < m[i][j]) {\n                    m[i][j] = q;\n                    s[i][j] = k;\n                }\n            }\n        }\n    }\n\n    // Return the minimum number of multiplications needed to multiply the entire chain\n    return m[0][n - 1];\n}\n\n// Main function to demonstrate the usage of the function\nint main() {\n    // Example: dimensions = {40, 20, 30, 10, 30}  (A1 = 40x20, A2 = 20x30, A3 = 30x10, A4 = 10x30)\n    vector<int> dimensions = {40, 20, 30, 10, 30};\n\n    int result = matrixChainMultiplication(dimensions);\n\n    cout << \"Minimum number of scalar multiplications required: \" << result << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=DcaHhhK-Y84"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/2y3m824/"
      ]
    ]
  },
  "subset-sum": {
    "title": "Subset Sum Problem",
    "short": "The Subset Sum Problem determines if there exists a subset of a given set of non-negative integers that sums up to a target value.  It is typically solved using dynamic programming or recursion.  It's a classic NP-complete problem with applications in knapsack problems and cryptography.",
    "time": "O(n*sum) where n is the number of elements in the set and sum is the target sum.",
    "space": "O(n*sum)",
    "code": " #include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if there exists a subset with the given sum\nbool isSubsetSum(const vector<int>& set, int n, int sum) {\n    // dp[i][j] is true if there is a subset of set[0..i-1]\n    // with sum equal to j\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n\n    // sum 0 is possible with empty set\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    // If sum is not 0 and set is empty, then answer is false\n    for (int i = 1; i <= sum; i++)\n        dp[0][i] = false;\n\n    // Fill the dp table in bottom up manner\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            // If set[i-1] is greater than j, then exclude it\n            if (set[i - 1] > j)\n                dp[i][j] = dp[i - 1][j];\n            else\n                // else include or exclude set[i-1]\n                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - set[i - 1]];\n        }\n    }\n\n    return dp[n][sum];\n}\n\nint main() {\n    vector<int> set = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    int n = set.size();\n\n    if (isSubsetSum(set, n, sum) == true)\n        cout << \"Found a subset with given sum\";\n    else\n        cout << \"No subset with given sum\";\n\n    cout << endl;\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=s6FhG--P7z0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=subset%20sum"
      ]
    ]
  },
  "dp-on-trees": {
    "title": "Dynamic Programming on Trees",
    "short": "Dynamic Programming (DP) on Trees is a powerful technique used to solve optimization problems on tree-structured data. It leverages the recursive nature of trees to break down a larger problem into smaller, overlapping subproblems, solving each subproblem only once and storing its result to avoid redundant computations. Typically, a bottom-up approach is employed, where the solution for a node is computed based on the solutions of its children. This approach is particularly useful for problems involving finding maximum sums, paths, or other optimal substructures within a tree.",
    "time": "O(N) where N is the number of nodes in the tree.",
    "space": "O(N) due to the DP table (often stored at each node) and recursion stack.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent a tree node\nstruct TreeNode {\n    int val;               // Value of the node\n    vector<TreeNode*> children; // Children of the node\n\n    TreeNode(int v) : val(v) {}\n};\n\n// Function to solve the maximum independent set problem using DP on trees\npair<int, int> maxIndependentSet(TreeNode* root) {\n    // Base case: if the node is null, return (0, 0)\n    if (root == nullptr) {\n        return {0, 0}; // {with_root, without_root}\n    }\n\n    // Initialize the DP values\n    int with_root = root->val; // Maximum independent set including the root\n    int without_root = 0;   // Maximum independent set excluding the root\n\n    // Iterate through the children of the current node\n    for (TreeNode* child : root->children) {\n        // Recursively calculate the maximum independent set for the child\n        pair<int, int> child_result = maxIndependentSet(child);\n\n        // If we include the root, we cannot include any of its children\n        with_root += child_result.second;\n\n        // If we exclude the root, we can either include or exclude its children\n        without_root += max(child_result.first, child_result.second);\n    }\n\n    // Return the DP values for the current node\n    return {with_root, without_root};\n}\n\n\nint main() {\n    // Create a sample tree\n    TreeNode* root = new TreeNode(10);\n    TreeNode* child1 = new TreeNode(20);\n    TreeNode* child2 = new TreeNode(30);\n    TreeNode* grandchild1 = new TreeNode(40);\n    TreeNode* grandchild2 = new TreeNode(50);\n    TreeNode* grandchild3 = new TreeNode(60);\n\n    root->children.push_back(child1);\n    root->children.push_back(child2);\n    child1->children.push_back(grandchild1);\n    child1->children.push_back(grandchild2);\n    child2->children.push_back(grandchild3);\n\n    // Calculate the maximum independent set\n    pair<int, int> result = maxIndependentSet(root);\n\n    // Print the result\n    cout << \"Maximum Independent Set: \" << max(result.first, result.second) << endl;\n\n    // Clean up memory (important to prevent memory leaks)\n    delete root; delete child1; delete child2; delete grandchild1; delete grandchild2; delete grandchild3; // Example, proper deallocation is more complex in general\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/dynamic-programming-trees/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=nPtARJ2n9pw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/tree/"
      ]
    ]
  },
  "backtracking-algorithms": {
    "title": "Backtracking Algorithms",
    "short": "Backtracking is a general algorithmic technique for finding all (or some) solutions to computational problems that incrementally builds candidates to the solutions, and abandons ('backtracks') a candidate as soon as it determines that the candidate cannot possibly lead to a valid solution. It explores the solution space by systematically trying different combinations, often using recursion. Backtracking is commonly used for solving constraint satisfaction problems, such as Sudoku, N-Queens, and graph coloring.",
    "time": "O(b^d) where b is the branching factor (average number of choices for each decision point) and d is the depth of the search tree.",
    "space": "O(d) where d is the maximum depth of the recursion tree. (Dominantly caused by the call stack)",
    "code": "// A C++ program to demonstrate the backtracking algorithm\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if it is safe to place a queen at board[row][col]\nbool isSafe(vector<vector<int>>& board, int row, int col, int n) {\n    // Check this row on left side\n    for (int i = 0; i < col; i++)\n        if (board[row][i])\n            return false;\n\n    // Check upper diagonal on left side\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)\n        if (board[i][j])\n            return false;\n\n    // Check lower diagonal on left side\n    for (int i = row, j = col; j >= 0 && i < n; i++, j--)\n        if (board[i][j])\n            return false;\n\n    return true;\n}\n\n// A recursive function to solve N Queen problem\nbool solveNQUtil(vector<vector<int>>& board, int col, int n) {\n    // Base case: If all queens are placed then return true\n    if (col >= n)\n        return true;\n\n    // Consider this column and try placing this queen in all rows\n    // one by one\n    for (int i = 0; i < n; i++) {\n        // Check if the queen can be placed on board[i][col]\n        if (isSafe(board, i, col, n)) {\n            // Place this queen in board[i][col]\n            board[i][col] = 1;\n\n            // Recur to place rest of the queens\n            if (solveNQUtil(board, col + 1, n))\n                return true;\n\n            // If placing queen in board[i][col] doesn't lead to a solution\n            // then remove queen from board[i][col] (Backtrack)\n            board[i][col] = 0; // BACKTRACK\n        }\n    }\n\n    // If the queen cannot be placed in any row in this column col\n    // then return false\n    return false;\n}\n\n// This function solves the N Queen problem using Backtracking.\n// It mainly uses solveNQUtil() to solve the problem. It returns\n// false if queens cannot be placed, otherwise, return true and\n// prints placement of queens in the form of 1s. Please note that there\n// may be more than one solutions, this function prints one of the solutions.\nvoid solveNQ(int n) {\n    vector<vector<int>> board(n, vector<int>(n, 0));\n\n    if (solveNQUtil(board, 0, n) == false) {\n        cout << \"Solution does not exist\";\n        return;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\n            cout << \" \" << board[i][j] << \" \";\n        cout << endl;\n    }\n}\n\n// Driver program to test above function\nint main() {\n    int n = 4; // Example: Solve for 4 queens\n    solveNQ(n);\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/backtracking-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=xWa_qJ8l4qE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/backtracking/"
      ]
    ]
  },
  "permutations": {
    "title": "Permutations",
    "short": "A permutation is an arrangement of objects in a specific order. Finding permutations involves generating all possible orderings of a given set of elements.  Algorithms for generating permutations are commonly used in combinatorial problems, such as generating test cases, solving puzzles, or exploring different configurations.",
    "time": "O(n!)",
    "space": "O(n)",
    "code": "// C++ program to generate all permutations of a given string or array.\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Recursive function to generate permutations\nvoid generatePermutations(vector<int>& nums, int l, int r, vector<vector<int>>& result) {\n    // Base case: If left and right are the same, we have reached a permutation\n    if (l == r) {\n        result.push_back(nums);\n    } else {\n        // Fix one element at each index and recursively generate permutations for the remaining elements\n        for (int i = l; i <= r; i++) {\n            // Swap the current element with the element at index i\n            swap(nums[l], nums[i]);\n\n            // Recursively generate permutations for the remaining elements\n            generatePermutations(nums, l + 1, r, result);\n\n            // Backtrack: Swap back to restore the original order. This is crucial for generating all permutations.\n            swap(nums[l], nums[i]);\n        }\n    }\n}\n\n// Function to find all permutations of a given array\nvector<vector<int>> findPermutations(vector<int>& nums) {\n    vector<vector<int>> result;\n    generatePermutations(nums, 0, nums.size() - 1, result);\n    return result;\n}\n\nint main() {\n    // Example usage\n    vector<int> nums = {1, 2, 3};\n    vector<vector<int>> permutations = findPermutations(nums);\n\n    cout << \"Permutations:\" << endl;\n    for (const auto& permutation : permutations) {\n        cout << \"[\";\n        for (size_t i = 0; i < permutation.size(); ++i) {\n            cout << permutation[i];\n            if (i < permutation.size() - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"]\" << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=sSjp7i3U7qE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/permutation/"
      ]
    ]
  },
  "power-set": {
    "title": "Power Set",
    "short": "The power set of a set S is the set of all subsets of S, including the empty set and S itself. Generating the power set involves systematically creating all possible combinations of elements from the original set.  It is commonly used in combinatorics, algorithm design, and database theory to explore all possible combinations of data elements.",
    "time": "O(2^n * n)",
    "space": "O(2^n * n)",
    "code": " #include <iostream>\n #include <vector>\n #include <algorithm>\n\n using namespace std;\n\n // Function to generate the power set of a given set\n vector<vector<int>> powerSet(vector<int>& set) {\n  vector<vector<int>> result;\n  int n = set.size();\n\n  // The number of subsets in a power set is 2^n\n  for (int i = 0; i < (1 << n); ++i) {\n   vector<int> subset;\n   for (int j = 0; j < n; ++j) {\n    // Check if the j-th bit is set in the current subset number (i)\n    if ((i >> j) & 1) {\n     subset.push_back(set[j]);\n    }\n   }\n   result.push_back(subset);\n  }\n  return result;\n }\n\n int main() {\n  vector<int> mySet = {1, 2, 3};\n  vector<vector<int>> subsets = powerSet(mySet);\n\n  cout << \"Power set of {1, 2, 3}:\\n\";\n  for (const auto& subset : subsets) {\n   cout << \"{\";\n   for (size_t i = 0; i < subset.size(); ++i) {\n    cout << subset[i];\n    if (i < subset.size() - 1) {\n     cout << \", \";\n    }\n   }\n   cout << \"}\\n\";\n  }\n\n  return 0;\n }",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/power-set/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=b7AYbpM5YrE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=Power%20Set"
      ]
    ]
  },
  "n-queens": {
    "title": "N-Queens Problem",
    "short": "The N-Queens problem is a classic constraint satisfaction problem where you aim to place N chess queens on an NN chessboard so that no two queens threaten each other.  This means no two queens can share the same row, column, or diagonal. The problem is solved by systematically exploring possible queen placements, typically using backtracking to prune unpromising branches of the search space. It's often used to illustrate backtracking and constraint satisfaction techniques in algorithms.",
    "time": "O(N!) (Worst-case, as it explores all possible permutations, although backtracking significantly reduces this in practice)",
    "space": "O(N) (to store queen positions in each row)",
    "code": " #include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if it's safe to place a queen at board[row][col]\nbool isSafe(vector<vector<bool>>& board, int row, int col, int n) {\n    // Check same column\n    for (int i = 0; i < row; i++) {\n        if (board[i][col]) {\n            return false;\n        }\n    }\n\n    // Check upper left diagonal\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j]) {\n            return false;\n        }\n    }\n\n    // Check upper right diagonal\n    for (int i = row, j = col; i >= 0 && j < n; i--, j++) {\n        if (board[i][j]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Recursive function to solve N-Queens problem using backtracking\nbool solveNQueensUtil(vector<vector<bool>>& board, int row, int n, vector<vector<string>>& solutions) {\n    // Base case: If all queens are placed (row == n), return true\n    if (row == n) {\n        vector<string> solution;\n        for (int i = 0; i < n; ++i) {\n            string row_str = \"\";\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j]) {\n                    row_str += \"Q\";\n                } else {\n                    row_str += \".\";\n                }\n            }\n            solution.push_back(row_str);\n        }\n        solutions.push_back(solution);\n        return true; // Return true to find all solutions, false to find just one\n    }\n\n    bool res = false; // To track if any solution is found\n\n    // Consider this row and try placing this queen in all columns one by one\n    for (int col = 0; col < n; col++) {\n        // Check if it's safe to place the queen at board[row][col]\n        if (isSafe(board, row, col, n)) {\n            // Place this queen in board[row][col]\n            board[row][col] = true;\n\n            // Recur to place rest of the queens\n            res = solveNQueensUtil(board, row + 1, n, solutions) || res;\n\n            // If placing queen doesn't lead to a solution, then backtrack\n            // and remove queen from board[row][col]\n            board[row][col] = false; // BACKTRACK\n        }\n    }\n\n    // If the queen cannot be placed in any column in this row, return false\n    return res; // Return false if no solution is found for this row\n}\n\n\n// Function to solve N-Queens problem\nvector<vector<string>> solveNQueens(int n) {\n    vector<vector<bool>> board(n, vector<bool>(n, false)); // Initialize chessboard\n    vector<vector<string>> solutions;\n\n    if (!solveNQueensUtil(board, 0, n, solutions)) {\n        cout << \"Solution does not exist\" << endl;\n    }\n\n    return solutions;\n}\n\n\nint main() {\n    int n = 4; // Example: Solve for 4-Queens problem\n    vector<vector<string>> solutions = solveNQueens(n);\n\n    if (!solutions.empty()) {\n        cout << \"Solutions for \" << n << \"-Queens problem:\" << endl;\n        for (const auto& solution : solutions) {\n            for (const string& row : solution) {\n                cout << row << endl;\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No solutions found for \" << n << \"-Queens problem.\" << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=xFJXtB5QN4c"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/n-queens/"
      ]
    ]
  },
  "sudoku-solver": {
    "title": "Sudoku Solver",
    "short": "A Sudoku Solver is an algorithm designed to solve Sudoku puzzles, which are 9x9 grids partially filled with numbers from 1 to 9. The solver typically employs a backtracking algorithm to systematically explore possible solutions. It attempts to fill empty cells with valid numbers, and if a conflict arises, it backtracks to a previous state and tries a different number, eventually finding a valid solution if one exists.",
    "time": "Worst: O(9^(number of empty cells)), Average: Heuristics significantly improve performance in practice. Difficult to provide a precise average case Big O.",
    "space": "O(1)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to print the Sudoku grid\nvoid printGrid(const vector<vector<int>>& grid) {\n    for (int i = 0; i < 9; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            cout << grid[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// Function to check if a number can be placed in a given cell\nbool isValid(const vector<vector<int>>& grid, int row, int col, int num) {\n    // Check row\n    for (int i = 0; i < 9; ++i) {\n        if (grid[row][i] == num) {\n            return false;\n        }\n    }\n\n    // Check column\n    for (int i = 0; i < 9; ++i) {\n        if (grid[i][col] == num) {\n            return false;\n        }\n    }\n\n    // Check 3x3 box\n    int boxRowStart = row - row % 3;\n    int boxColStart = col - col % 3;\n\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (grid[boxRowStart + i][boxColStart + j] == num) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n// Function to solve the Sudoku using backtracking\nbool solveSudoku(vector<vector<int>>& grid) {\n    for (int row = 0; row < 9; ++row) {\n        for (int col = 0; col < 9; ++col) {\n            // Find an empty cell\n            if (grid[row][col] == 0) {\n                // Try filling it with numbers from 1 to 9\n                for (int num = 1; num <= 9; ++num) {\n                    if (isValid(grid, row, col, num)) {\n                        // If the number is valid, place it in the cell\n                        grid[row][col] = num;\n\n                        // Recursively try to solve the rest of the Sudoku\n                        if (solveSudoku(grid)) {\n                            return true; // Solution found\n                        } else {\n                            // If the recursive call fails, backtrack and try a different number\n                            grid[row][col] = 0;\n                        }\n                    }\n                }\n                // If no number can be placed in the cell, it means the Sudoku is unsolvable\n                return false;\n            }\n        }\n    }\n    // If all cells are filled, it means the Sudoku is solved\n    return true;\n}\n\nint main() {\n    // Example Sudoku grid (0 represents an empty cell)\n    vector<vector<int>> grid = {\n        {5, 3, 0, 0, 7, 0, 0, 0, 0},\n        {6, 0, 0, 1, 9, 5, 0, 0, 0},\n        {0, 9, 8, 0, 0, 0, 0, 6, 0},\n        {8, 0, 0, 0, 6, 0, 0, 0, 3},\n        {4, 0, 0, 8, 0, 3, 0, 0, 1},\n        {7, 0, 0, 0, 2, 0, 0, 0, 6},\n        {0, 6, 0, 0, 0, 0, 2, 8, 0},\n        {0, 0, 0, 4, 1, 9, 0, 0, 5},\n        {0, 0, 0, 0, 8, 0, 0, 7, 9}\n    };\n\n    cout << \"Sudoku Puzzle:\\n\";\n    printGrid(grid);\n\n    if (solveSudoku(grid)) {\n        cout << \"\\nSudoku Solution:\\n\";\n        printGrid(grid);\n    } else {\n        cout << \"\\nNo solution exists.\\n\";\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/sudoku-backtracking-7/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=G_UYXzGuqv8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/sudoku/"
      ]
    ]
  },
  "rat-in-a-maze": {
    "title": "Rat in a Maze",
    "short": "The Rat in a Maze problem is a classic example of backtracking algorithms. Given a maze represented as a 2D matrix, where 1 represents a path and 0 represents a blocked cell, the goal is to find a path for a rat to reach the destination from the starting point (usually the top-left corner to the bottom-right corner). The algorithm explores possible paths using recursion and backtracking: if a path leads to a dead end, it backtracks to try a different direction.",
    "time": "Worst Case: O(2^(m+n)), Best Case: O(1), Average Case: O(2^(m+n))",
    "space": "O(m*n) (due to recursion stack)",
    "code": " #include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a cell is safe to move to\nbool isSafe(int row, int col, const vector<vector<int>>& maze, const vector<vector<int>>& solution, int n) {\n    // Check if the cell is within the maze boundaries, is a valid path (maze[row][col] == 1), and hasn't been visited yet (solution[row][col] == 0)\n    return (row >= 0 && row < n && col >= 0 && col < n && maze[row][col] == 1 && solution[row][col] == 0);\n}\n\n// Recursive function to solve the Rat in a Maze problem using backtracking\nbool solveMazeUtil(int row, int col, const vector<vector<int>>& maze, vector<vector<int>>& solution, int n) {\n    // Base case: If the rat reaches the destination (bottom-right corner)\n    if (row == n - 1 && col == n - 1 && maze[row][col] == 1) {\n        solution[row][col] = 1; // Mark the destination as part of the solution\n        return true; // Solution found\n    }\n\n    // Check if the current cell is safe to explore\n    if (isSafe(row, col, maze, solution, n)) {\n        // Mark the current cell as part of the solution path\n        solution[row][col] = 1;\n\n        // Move forward in the row direction\n        if (solveMazeUtil(row + 1, col, maze, solution, n)) {\n            return true; // Solution found\n        }\n\n        // If moving forward in the row direction doesn't lead to a solution, move forward in the column direction\n        if (solveMazeUtil(row, col + 1, maze, solution, n)) {\n            return true; // Solution found\n        }\n\n        // If neither moving forward in the row nor column direction leads to a solution, backtrack:\n        // Unmark the current cell as part of the solution (reset to 0), indicating that this path didn't lead to the destination.\n        solution[row][col] = 0;\n        return false; // No solution found from this cell\n    }\n\n    return false; // The current cell is not safe, so return false.\n}\n\n// Function to solve the Rat in a Maze problem\nbool solveMaze(vector<vector<int>>& maze, int n) {\n    vector<vector<int>> solution(n, vector<int>(n, 0)); // Initialize the solution matrix with all zeros\n\n    if (solveMazeUtil(0, 0, maze, solution, n) == false) {\n        cout << \"Solution doesn't exist\" << endl;\n        return false; // No solution exists\n    }\n\n    // Print the solution matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << solution[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return true; // Solution found and printed\n}\n\nint main() {\n    vector<vector<int>> maze = {\n        {1, 0, 0, 0},\n        {1, 1, 0, 1},\n        {0, 1, 0, 0},\n        {1, 1, 1, 1}\n    };\n\n    int n = maze.size(); // Determine the size of the maze\n\n    solveMaze(maze, n); // Solve the maze and print the solution\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=bLBjG1vK5Fg"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/rat-in-a-maze/"
      ]
    ]
  },
  "m-coloring-problem": {
    "title": "M-Coloring Problem",
    "short": "The M-Coloring Problem is a graph coloring problem that aims to assign colors to the vertices of a graph such that no two adjacent vertices share the same color, using at most 'm' colors. It's a classic NP-complete problem used to demonstrate backtracking algorithms. The algorithm explores different color assignments until a valid coloring is found or all possibilities are exhausted.",
    "time": "O(m^V), where V is the number of vertices and m is the number of colors.",
    "space": "O(V)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a coloring is safe (no adjacent vertices have the same color)\nbool isSafe(int v, vector<vector<int>>& graph, vector<int>& color, int c) {\n    for (int i = 0; i < graph.size(); i++) {\n        if (graph[v][i] && c == color[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Recursive function to solve the M-Coloring problem using backtracking\nbool graphColoringUtil(vector<vector<int>>& graph, int m, vector<int>& color, int v) {\n    // Base case: All vertices are assigned a color\n    if (v == graph.size()) {\n        return true;\n    }\n\n    // Try different colors for the current vertex\n    for (int c = 1; c <= m; c++) {\n        if (isSafe(v, graph, color, c)) {\n            color[v] = c;  // Assign color c to vertex v\n\n            // Recur to assign colors to the remaining vertices\n            if (graphColoringUtil(graph, m, color, v + 1)) {\n                return true;  // Solution found\n            }\n\n            color[v] = 0;  // Backtrack: If assigning color c doesn't lead to a solution, reset the color of vertex v\n        }\n    }\n\n    // No color can be assigned to vertex v, so return false\n    return false;\n}\n\n// Function to solve the M-Coloring problem\nbool graphColoring(vector<vector<int>>& graph, int m) {\n    vector<int> color(graph.size(), 0); // Initialize all vertices to be uncolored (0)\n\n    // Start from the first vertex (index 0)\n    if (graphColoringUtil(graph, m, color, 0) == false) {\n        cout << \"Solution does not exist\\n\";\n        return false;\n    }\n\n    // Print the solution\n    cout << \"Solution Exists: Following are the assigned colors \\n\";\n    for (int i = 0; i < graph.size(); i++) {\n        cout << \"Vertex \" << i << \" --> Color \" << color[i] << endl;\n    }\n    return true;\n}\n\nint main() {\n    // Example graph represented by an adjacency matrix\n    vector<vector<int>> graph = {\n        {0, 1, 1, 1},\n        {1, 0, 1, 0},\n        {1, 1, 0, 1},\n        {1, 0, 1, 0}\n    };\n\n    int m = 3; // Number of colors\n\n    graphColoring(graph, m);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=05m_lb1_yQc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/2v4y5j2/"
      ]
    ]
  },
  "graph-algorithms": {
    "title": "Graph Algorithms",
    "short": "Graph algorithms are a collection of computational procedures used to solve problems related to graph theory. These algorithms operate on graphs, which are data structures consisting of nodes (vertices) connected by edges.  They are used extensively in areas such as network analysis, pathfinding, and data mining, solving problems like finding the shortest path between two points or detecting cycles in a network.",
    "time": "Varies widely based on the specific algorithm. Breadth-First Search (BFS): O(V + E). Depth-First Search (DFS): O(V + E). Dijkstra's Algorithm: O(E log V) (with priority queue). Bellman-Ford Algorithm: O(V * E). Floyd-Warshall Algorithm: O(V^3).",
    "space": "Varies widely. Adjacency List: O(V + E). Adjacency Matrix: O(V^2). BFS: O(V). DFS: O(V) in the worst case (for the call stack).",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\n// Represents an edge in the graph\nstruct Edge {\n    int to;\n    int weight;\n};\n\n// Function to perform Dijkstra's algorithm to find the shortest path from a source node to all other nodes\nvector<int> dijkstra(const vector<vector<Edge>>& graph, int source) {\n    int num_nodes = graph.size();\n    vector<int> dist(num_nodes, numeric_limits<int>::max()); // Initialize distances to infinity\n    dist[source] = 0; // Distance from source to itself is 0\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // Min-priority queue\n    pq.push({0, source}); // (distance, node)\n\n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (d > dist[u]) continue; // Optimization: If we've already found a shorter path to u, skip\n\n        for (const Edge& edge : graph[u]) {\n            int v = edge.to;\n            int weight = edge.weight;\n\n            if (dist[u] != numeric_limits<int>::max() && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    return dist; // Returns the shortest distance from source to each node.\n}\n\nint main() {\n    // Example graph (Adjacency list representation)\n    // graph[i] is a vector of Edges representing all edges starting from node i\n    vector<vector<Edge>> graph = {\n        {{1, 4}, {2, 2}},\n        {{2, 5}, {3, 10}},\n        {{3, 3}},\n        {{}}\n    };\n\n    int source_node = 0;\n\n    vector<int> shortest_distances = dijkstra(graph, source_node);\n\n    cout << \"Shortest distances from node \" << source_node << \":\" << endl;\n    for (int i = 0; i < shortest_distances.size(); ++i) {\n        cout << \"To node \" << i << \": \";\n        if (shortest_distances[i] == numeric_limits<int>::max()) {\n            cout << \"Infinity\" << endl;\n        } else {\n            cout << shortest_distances[i] << endl;\n        }\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=pVfj6mxhdfw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  },
  "graph-representations": {
    "title": "Graph Representations",
    "short": "Graph representations are ways to store graphs in computer memory.  Graphs are mathematical structures used to model pairwise relations between objects. The two primary representations are Adjacency Matrix, which uses a 2D array, and Adjacency List, which uses a list (or array) of lists. The choice between them depends on the graph's density (number of edges relative to vertices) and the specific operations being performed.",
    "time": {
      "Adjacency Matrix": {
        "Access": "O(1)",
        "Search Adjacency": "O(1)",
        "Insertion (Edge)": "O(1)",
        "Deletion (Edge)": "O(1)",
        "Iterate over Adjacencies of a Vertex": "O(V)"
      },
      "Adjacency List": {
        "Access": "N/A (Not directly accessible by index)",
        "Search Adjacency": "O(V)",
        "Insertion (Edge)": "O(1)",
        "Deletion (Edge)": "O(V)",
        "Iterate over Adjacencies of a Vertex": "O(degree(V))"
      }
    },
    "space": {
      "Adjacency Matrix": "O(V^2)",
      "Adjacency List": "O(V + E)"
    },
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <list>\n\n// Adjacency List Representation\nclass Graph {\nprivate:\n    int numVertices;\n    std::list<int> *adj;\n\npublic:\n    Graph(int vertices) : numVertices(vertices) {\n        adj = new std::list<int>[vertices];\n    }\n\n    ~Graph() {\n        delete[] adj;\n    }\n\n    void addEdge(int u, int v) {\n        // Add v to u's list and u to v's list (undirected graph)\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    void printGraph() {\n        for (int v = 0; v < numVertices; ++v) {\n            std::cout << \"Adjacency list of vertex \" << v << \": \";\n            for (int neighbor : adj[v]) {\n                std::cout << neighbor << \" \";\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\n// Adjacency Matrix Representation\nclass GraphMatrix {\nprivate:\n    int numVertices;\n    std::vector<std::vector<bool>> adjMatrix;\n\npublic:\n    GraphMatrix(int vertices) : numVertices(vertices), adjMatrix(vertices, std::vector<bool>(vertices, false)) {}\n\n    void addEdge(int u, int v) {\n        // Set adjMatrix[u][v] and adjMatrix[v][u] to true for undirected graph\n        adjMatrix[u][v] = true;\n        adjMatrix[v][u] = true;\n    }\n\n    void printGraph() {\n        std::cout << \"  \";\n        for(int i = 0; i < numVertices; i++) {\n          std::cout << i << \" \";\n        }\n        std::cout << std::endl;\n        for (int u = 0; u < numVertices; ++u) {\n            std::cout << u << \" \";\n            for (int v = 0; v < numVertices; ++v) {\n                std::cout << adjMatrix[u][v] << \" \";\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\nint main() {\n    // Example usage of Adjacency List\n    Graph g(4); // Create a graph with 4 vertices\n    g.addEdge(0, 1);\n    g.addEdge(0, 2);\n    g.addEdge(1, 2);\n    g.addEdge(2, 3);\n    std::cout << \"Adjacency List Representation:\" << std::endl;\n    g.printGraph();\n\n    std::cout << std::endl;\n\n    // Example usage of Adjacency Matrix\n    GraphMatrix gm(4);\n    gm.addEdge(0, 1);\n    gm.addEdge(0, 2);\n    gm.addEdge(1, 2);\n    gm.addEdge(2, 3);\n    std::cout << \"Adjacency Matrix Representation:\" << std::endl;\n    gm.printGraph();\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/graph-and-its-representations/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=gXEuqjv9l_4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  },
  "bfs-and-dfs": {
    "title": "Breadth-First Search (BFS) and Depth-First Search (DFS)",
    "short": "BFS and DFS are fundamental graph traversal algorithms used to explore all the vertices of a graph. BFS explores the graph level by level, starting from the root node and visiting all its neighbors before moving to the next level. DFS explores as far as possible along each branch before backtracking. BFS is commonly used for finding the shortest path in unweighted graphs, while DFS is used for detecting cycles and topological sorting.",
    "time": "BFS: Average/Best/Worst: O(V + E), DFS: Average/Best/Worst: O(V + E), where V is the number of vertices and E is the number of edges.",
    "space": "BFS: O(W) where W is the maximum width of the graph (worst case O(V)), DFS: O(H) where H is the maximum height/depth of the graph (worst case O(V))",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n// Function to perform Breadth-First Search (BFS)\nvoid bfs(const vector<vector<int>>& adj, int start_node, vector<bool>& visited) {\n    queue<int> q;\n    visited[start_node] = true;\n    q.push(start_node);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        cout << u << \" \"; // Process the current node\n\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\n// Function to perform Depth-First Search (DFS)\nvoid dfs(const vector<vector<int>>& adj, int start_node, vector<bool>& visited) {\n    stack<int> s;\n    s.push(start_node);\n\n    while (!s.empty()) {\n        int u = s.top();\n        s.pop();\n\n        if (!visited[u]) {\n            visited[u] = true;\n            cout << u << \" \"; // Process the current node\n        }\n\n        // Iterate in reverse order to maintain correct DFS order\n        for (int i = adj[u].size() - 1; i >= 0; --i) {\n            int v = adj[u][i];\n            if (!visited[v]) {\n                s.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    // Example graph represented as an adjacency list\n    int num_vertices = 6;\n    vector<vector<int>> adj(num_vertices);\n    adj[0] = {1, 2};\n    adj[1] = {0, 3, 4};\n    adj[2] = {0, 4};\n    adj[3] = {1, 5};\n    adj[4] = {1, 2, 5};\n    adj[5] = {3, 4};\n\n    // BFS traversal starting from node 0\n    cout << \"BFS Traversal starting from node 0: \";\n    vector<bool> visited_bfs(num_vertices, false);\n    bfs(adj, 0, visited_bfs);\n    cout << endl;\n\n    // DFS traversal starting from node 0\n    cout << \"DFS Traversal starting from node 0: \";\n    vector<bool> visited_dfs(num_vertices, false);\n    dfs(adj, 0, visited_dfs);\n    cout << endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=TIbUeeksXcI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/breadth-first-search/"
      ]
    ]
  },
  "minimum-spanning-tree": {
    "title": "Minimum Spanning Tree (MST)",
    "short": "A Minimum Spanning Tree (MST) is a subgraph of a connected, weighted graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. MST algorithms are used to find the most cost-effective way to connect all points in a network, often appearing in network design, clustering, and approximation algorithms. Prim's and Kruskal's algorithms are two common methods to find the MST of a graph.",
    "time": {
      "Prim's (using adjacency matrix)": "O(V^2)",
      "Prim's (using binary heap)": "O(E log V)",
      "Prim's (using Fibonacci heap)": "O(E + V log V)",
      "Kruskal's": "O(E log E) or O(E log V)"
    },
    "space": "O(V)",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an edge in the graph\nstruct Edge {\n    int src, dest, weight;\n};\n\n// Function to find the parent of a vertex in the disjoint set\nint find(vector<int>& parent, int i) {\n    if (parent[i] == i)\n        return i;\n    return parent[i] = find(parent, parent[i]); // Path compression\n}\n\n// Function to perform union of two sets (vertices)\nvoid unite(vector<int>& parent, vector<int>& rank, int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n\n    // Attach smaller rank tree under root of high rank tree\n    // (Union by Rank)\n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n\n    // If ranks are the same, then make one as root and increment its rank\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\n// Function to implement Kruskal's algorithm\nvector<Edge> kruskalMST(vector<Edge>& edges, int numVertices) {\n    vector<Edge> result;\n    vector<int> parent(numVertices);\n    vector<int> rank(numVertices, 0);\n\n    // Initialize each vertex as its own set\n    for (int i = 0; i < numVertices; ++i)\n        parent[i] = i;\n\n    // Sort the edges by weight in non-decreasing order\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n        return a.weight < b.weight;\n    });\n\n    int edgeCount = 0;\n    int i = 0;\n\n    while (edgeCount < numVertices - 1 && i < edges.size()) {\n        Edge currentEdge = edges[i++];\n\n        int srcParent = find(parent, currentEdge.src);\n        int destParent = find(parent, currentEdge.dest);\n\n        // If including this edge doesn't cause cycle, include it\n        // in result and increment the index of result for next edge\n        if (srcParent != destParent) {\n            result.push_back(currentEdge);\n            unite(parent, rank, srcParent, destParent);\n            edgeCount++;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int numVertices = 4;\n    vector<Edge> edges = {\n        {0, 1, 10},\n        {0, 2, 6},\n        {0, 3, 5},\n        {1, 3, 15},\n        {2, 3, 4}\n    };\n\n    vector<Edge> mst = kruskalMST(edges, numVertices);\n\n    cout << \"Edges in the Minimum Spanning Tree:\\n\";\n    int minCost = 0;\n    for (const auto& edge : mst) {\n        cout << edge.src << \" -- \" << edge.dest << \"  Weight: \" << edge.weight << endl;\n        minCost += edge.weight;\n    }\n\n    cout << \"Total cost of MST: \" << minCost << endl;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/minimum-spanning-tree/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=4ZlRH0eK-ds"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/minimum-spanning-tree/"
      ]
    ]
  },
  "bellman-ford": {
    "title": "Bellman-Ford Algorithm",
    "short": "The Bellman-Ford algorithm is a graph search algorithm that computes shortest paths from a single source vertex to all other vertices in a weighted digraph. It's capable of handling graphs with negative edge weights, which Dijkstra's algorithm cannot. It works by iteratively relaxing the edges of the graph, updating distance estimates until the shortest paths are found or a negative-weight cycle is detected.",
    "time": "Average: O(V*E), Best: O(E), Worst: O(V*E) where V is the number of vertices and E is the number of edges.",
    "space": "O(V)",
    "code": "// C++ implementation of the Bellman-Ford algorithm\n#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\n// Structure to represent an edge in the graph\nstruct Edge {\n    int src, dest, weight;\n};\n\n// Function to implement the Bellman-Ford algorithm\nvoid bellmanFord(int V, int E, vector<Edge>& edges, int src) {\n    // Initialize distances from source to all other vertices as infinite\n    vector<int> dist(V, INT_MAX);\n    dist[src] = 0;\n\n    // Relax all edges |V| - 1 times. A simple shortest path from src to any other\n    // vertex can have at-most |V| - 1 edges\n    for (int i = 1; i <= V - 1; i++) {\n        for (int j = 0; j < E; j++) {\n            int u = edges[j].src;\n            int v = edges[j].dest;\n            int weight = edges[j].weight;\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\n                dist[v] = dist[u] + weight;\n        }\n    }\n\n    // Check for negative-weight cycles.  The above step guarantees shortest\n    // distances if graph doesn't contain negative weight cycle.  If we get a\n    // shorter path, then there is a cycle.\n    for (int j = 0; j < E; j++) {\n        int u = edges[j].src;\n        int v = edges[j].dest;\n        int weight = edges[j].weight;\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\n            cout << \"Graph contains negative weight cycle\" << endl;\n            return;\n        }\n    }\n\n    // Print the calculated shortest distances\n    cout << \"Vertex   Distance from Source\" << endl;\n    for (int i = 0; i < V; i++)\n        cout << i << \"\\t\\t\" << dist[i] << endl;\n}\n\n// Driver program to test above function\nint main() {\n    int V = 5;  // Number of vertices in graph\n    int E = 8;  // Number of edges in graph\n\n    vector<Edge> edges(E);\n\n    // Example graph\n    edges[0] = {0, 1, -1};\n    edges[1] = {0, 2, 4};\n    edges[2] = {1, 2, 3};\n    edges[3] = {1, 3, 2};\n    edges[4] = {1, 4, 2};\n    edges[5] = {3, 2, 5};\n    edges[6] = {3, 1, 1};\n    edges[7] = {4, 3, -3};\n\n    bellmanFord(V, E, edges, 0);\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/bellman-ford-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=rtFG9Czydlc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/bellman-ford/"
      ]
    ]
  },
  "floyd-warshall": {
    "title": "Floyd-Warshall Algorithm",
    "short": "The Floyd-Warshall algorithm is a dynamic programming algorithm used to find the shortest paths between all pairs of vertices in a weighted graph. It works by iteratively considering each vertex as an intermediate node in a path, updating the shortest distance between every pair of vertices if a shorter path is found via that intermediate node. It's particularly useful for graphs with negative edge weights (but not negative cycles).",
    "time": "O(V^3)",
    "space": "O(V^2)",
    "code": "// C++ implementation of Floyd-Warshall algorithm\n#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max(); // Define infinity for disconnected vertices\n\n// Function to implement Floyd-Warshall algorithm\nvoid floydWarshall(vector<vector<int>>& graph) {\n  int V = graph.size(); // Number of vertices in the graph\n\n  // dist[i][j] will be the shortest distance from i to j\n  vector<vector<int>> dist = graph;\n\n  // For each vertex k, consider it as an intermediate vertex\n  for (int k = 0; k < V; k++) {\n    // For each vertex i as a source\n    for (int i = 0; i < V; i++) {\n      // For each vertex j as a destination\n      for (int j = 0; j < V; j++) {\n        // If vertex k is on the shortest path from i to j, then update the value of dist[i][j]\n        if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  // Detect negative cycles\n  for (int i = 0; i < V; i++) {\n        if (dist[i][i] < 0) {\n            cout << \"Negative cycle detected!\" << endl;\n            return;\n        }\n  }\n\n  // Print the solution (shortest distances between every pair of vertices)\n  cout << \"Shortest distances between every pair of vertices:\" << endl;\n  for (int i = 0; i < V; i++) {\n    for (int j = 0; j < V; j++) {\n      if (dist[i][j] == INF)\n        cout << \"INF\" << \"\\t\";\n      else\n        cout << dist[i][j] << \"\\t\";\n    }\n    cout << endl;\n  }\n}\n\nint main() {\n  // Example graph represented as an adjacency matrix\n  vector<vector<int>> graph = {\n    {0,   5,   INF, 10},\n    {INF, 0,   3,   INF},\n    {INF, INF, 0,   1},\n    {INF, INF, INF, 0}\n  };\n\n  // Call the Floyd-Warshall function\n  floydWarshall(graph);\n\n  return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/floyd-warshall-algorithm/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=4OQeCuLYj-4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/floyd-warshall/"
      ]
    ]
  },
  "topological-sort": {
    "title": "Topological Sort",
    "short": "Topological sort is an algorithm for ordering the nodes of a directed acyclic graph (DAG) such that for every directed edge from node A to node B, node A appears before node B in the ordering. It's used to schedule jobs or tasks that have dependencies on each other. A typical use case is task scheduling, course scheduling, or dependency resolution in software projects.",
    "time": "O(V + E), where V is the number of vertices (nodes) and E is the number of edges.",
    "space": "O(V), where V is the number of vertices (nodes).",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to perform topological sort using Kahn's Algorithm (BFS).\nvector<int> topologicalSort(int V, const vector<vector<int>>& adj) {\n    vector<int> inDegree(V, 0);\n    // Calculate in-degree for each node.\n    for (int u = 0; u < V; ++u) {\n        for (int v : adj[u]) {\n            inDegree[v]++;\n        }\n    }\n\n    queue<int> q;\n    // Add nodes with in-degree 0 to the queue.\n    for (int i = 0; i < V; ++i) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector<int> topologicalOrder;\n    int count = 0;\n    // Process nodes in the queue.\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        topologicalOrder.push_back(u);\n        count++;\n\n        // Decrement in-degree of adjacent nodes.\n        for (int v : adj[u]) {\n            if (--inDegree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    // Check for cycle.  If count is not equal to V, then there is a cycle.\n    if (count != V) {\n        return {}; // Return an empty vector to indicate a cycle.\n    }\n\n    return topologicalOrder;\n}\n\nint main() {\n    // Example graph represented as an adjacency list.\n    int V = 6; // Number of vertices\n    vector<vector<int>> adj(V);\n\n    // Add edges to the graph.  Represents dependencies.\n    adj[5].push_back(2);\n    adj[5].push_back(0);\n    adj[4].push_back(0);\n    adj[4].push_back(1);\n    adj[2].push_back(3);\n    adj[3].push_back(1);\n\n    // Perform topological sort.\n    vector<int> result = topologicalSort(V, adj);\n\n    // Print the topological order.\n    if (!result.empty()) {\n        cout << \"Topological Order: \";\n        for (int node : result) {\n            cout << node << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"Graph contains a cycle. Topological sort not possible.\\n\";\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/topological-sorting/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=eL-KzMXSXXI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/topological-sort/"
      ]
    ]
  },
  "articulation-points": {
    "title": "Articulation Points (Cut Vertices)",
    "short": "Articulation points, also known as cut vertices, are nodes in a connected graph that, if removed along with their incident edges, would disconnect the graph into two or more connected components.  Finding articulation points is crucial in network analysis to identify critical nodes whose failure would significantly impact network connectivity. The algorithm uses Depth-First Search (DFS) to discover these critical nodes by tracking discovery times and low-link values.",
    "time": "O(V + E), where V is the number of vertices and E is the number of edges.",
    "space": "O(V)",
    "code": "// C++ program to find articulation points in an undirected graph\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Graph {\n    int V; // No. of vertices\n    vector<vector<int>> adj; // Adjacency list representation\n    vector<bool> visited; // Tracks visited nodes during DFS\n    vector<int> disc; // Discovery time of each vertex\n    vector<int> low; // Lowest reachable ancestor of each vertex\n    vector<int> parent; // Parent of each vertex in DFS tree\n    vector<bool> ap; // To store articulation points\n    int time;\n\npublic:\n    Graph(int V);\n    void addEdge(int v, int w);\n    void APUtil(int v);\n    void findAP();\n};\n\nGraph::Graph(int V) {\n    this->V = V;\n    adj.resize(V);\n    visited.resize(V, false);\n    disc.resize(V, -1);\n    low.resize(V, -1);\n    parent.resize(V, -1);\n    ap.resize(V, false);\n    time = 0;\n}\n\nvoid Graph::addEdge(int v, int w) {\n    adj[v].push_back(w);\n    adj[w].push_back(v); // Undirected graph\n}\n\nvoid Graph::APUtil(int u) {\n    visited[u] = true;\n    disc[u] = low[u] = ++time;\n\n    int children = 0; // Count of children in DFS tree\n\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            children++;\n            parent[v] = u;\n            APUtil(v);\n\n            low[u] = min(low[u], low[v]);\n\n            // (1) u is root of DFS tree and has two or more children.\n            if (parent[u] == -1 && children > 1)\n                ap[u] = true;\n\n            // (2) u is not root and low value of one of its child\n            // is more than discovery value of u.\n            if (parent[u] != -1 && low[v] >= disc[u])\n                ap[u] = true;\n        }\n\n        // Update low value of u for parent function calls.\n        else if (v != parent[u])\n            low[u] = min(low[u], disc[v]);\n    }\n}\n\nvoid Graph::findAP() {\n    for (int i = 0; i < V; i++)\n        if (visited[i] == false)\n            APUtil(i,0);\n\n    cout << \"Articulation points are \\n\";\n    for (int i = 0; i < V; i++)\n        if (ap[i])\n            cout << i << \" \";\n    cout << endl;\n}\n\n// Driver program to test above function\nint main() {\n    // Create graphs given in the above diagrams\n    cout << \"Graph 1 \\n\";\n    Graph g1(5);\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.findAP();\n\n    cout << \"\\nGraph 2 \\n\";\n    Graph g2(4);\n    g2.addEdge(0, 1);\n    g2.addEdge(1, 2);\n    g2.addEdge(2, 3);\n    g2.findAP();\n\n    cout << \"\\nGraph 3 \\n\";\n    Graph g3(7);\n    g3.addEdge(0, 1);\n    g3.addEdge(1, 2);\n    g3.addEdge(2, 0);\n    g3.addEdge(1, 3);\n    g3.addEdge(1, 4);\n    g3.addEdge(1, 6);\n    g3.addEdge(3, 5);\n    g3.addEdge(4, 5);\n    g3.findAP();\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=RYaakW5x7uE"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/articulation-point/"
      ]
    ]
  },
  "strongly-connected-components": {
    "title": "Strongly Connected Components (SCC)",
    "short": "A strongly connected component (SCC) of a directed graph is a maximal subgraph in which every pair of vertices is reachable from each other. In essence, an SCC is a 'circle' of vertices. Algorithms like Kosaraju's and Tarjan's are used to identify and extract these components, which are vital in network analysis, dependency resolution, and cycle detection.",
    "time": "O(V + E) for both Kosaraju's and Tarjan's algorithms, where V is the number of vertices and E is the number of edges.",
    "space": "O(V) in most cases, for storing visited nodes, recursion stack, and the components themselves.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\n// Function to add an edge to the graph\nvoid addEdge(vector<vector<int>>& adj, int u, int v) {\n    adj[u].push_back(v);\n}\n\n// Depth First Search (DFS) to populate the stack with vertices in finishing order\nvoid dfs1(vector<vector<int>>& adj, int v, vector<bool>& visited, stack<int>& stack) {\n    visited[v] = true;\n\n    for (int neighbor : adj[v]) {\n        if (!visited[neighbor]) {\n            dfs1(adj, neighbor, visited, stack);\n        }\n    }\n\n    stack.push(v);\n}\n\n// Function to get the transpose of the graph\nvector<vector<int>> getTranspose(vector<vector<int>>& adj, int V) {\n    vector<vector<int>> transposeAdj(V);\n    for (int v = 0; v < V; ++v) {\n        for (int neighbor : adj[v]) {\n            transposeAdj[neighbor].push_back(v);\n        }\n    }\n    return transposeAdj;\n}\n\n// Depth First Search (DFS) to print SCCs\nvoid dfs2(vector<vector<int>>& adj, int v, vector<bool>& visited) {\n    visited[v] = true;\n    cout << v << \" \";\n\n    for (int neighbor : adj[v]) {\n        if (!visited[neighbor]) {\n            dfs2(adj, neighbor, visited);\n        }\n    }\n}\n\n// Function to find and print strongly connected components using Kosaraju's algorithm\nvoid findSCCs(vector<vector<int>>& adj, int V) {\n    stack<int> stack;\n    vector<bool> visited(V, false);\n\n    // Step 1: Populate the stack with vertices in finishing order\n    for (int i = 0; i < V; ++i) {\n        if (!visited[i]) {\n            dfs1(adj, i, visited, stack);\n        }\n    }\n\n    // Step 2: Get the transpose of the graph\n    vector<vector<int>> transposeAdj = getTranspose(adj, V);\n\n    // Step 3: Mark all vertices as not visited for the second DFS\n    for (int i = 0; i < V; ++i) {\n        visited[i] = false;\n    }\n\n    // Step 4: Process vertices in the order defined by the stack\n    while (!stack.empty()) {\n        int v = stack.top();\n        stack.pop();\n\n        if (!visited[v]) {\n            dfs2(transposeAdj, v, visited);\n            cout << endl;\n        }\n    }\n}\n\nint main() {\n    int V = 5; // Number of vertices\n    vector<vector<int>> adj(V);\n\n    // Create a graph\n    addEdge(adj, 1, 0);\n    addEdge(adj, 0, 2);\n    addEdge(adj, 2, 1);\n    addEdge(adj, 0, 3);\n    addEdge(adj, 3, 4);\n\n    cout << \"Strongly Connected Components:\\n\";\n    findSCCs(adj, V);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/strongly-connected-components/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=Rpgvoz6x8mw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/strongly-connected-component/"
      ]
    ]
  },
  "network-flow": {
    "title": "Maximum Flow Problem",
    "short": "The Maximum Flow Problem seeks to find the maximum amount of flow that can be sent from a source node to a sink node in a directed graph with edge capacities.  Algorithms like Ford-Fulkerson and Edmonds-Karp iteratively find augmenting paths (paths with available capacity) and increase the flow along these paths until no more augmenting paths exist. This models scenarios like network throughput maximization, resource allocation, and matching problems.",
    "time": "Ford-Fulkerson: O(E * f) where f is the maximum flow, Edmonds-Karp: O(V * E^2), Dinic's Algorithm: O(V^2 * E)",
    "space": "O(V + E)",
    "code": "// C++ implementation of the Edmonds-Karp algorithm for Maximum Flow\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\n// Function to find an augmenting path using BFS\nbool bfs(const vector<vector<int>>& graph, int s, int t, vector<int>& parent) {\n    int n = graph.size();\n    vector<bool> visited(n, false);\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    parent[s] = -1;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v = 0; v < n; ++v) {\n            if (!visited[v] && graph[u][v] > 0) {\n                q.push(v);\n                parent[v] = u;\n                visited[v] = true;\n            }\n        }\n    }\n\n    // Return true if we reached sink in BFS starting from source\n    return visited[t] == true;\n}\n\n// Function to implement the Edmonds-Karp algorithm\nint edmondsKarp(vector<vector<int>>& graph, int s, int t) {\n    int n = graph.size();\n    vector<vector<int>> residualGraph = graph; // Create a residual graph\n    vector<int> parent(n); // This array is filled by BFS and to store path\n    int max_flow = 0;  // There is no flow initially\n\n    // Augment the flow while there is a path from source to sink\n    while (bfs(residualGraph, s, t, parent)) {\n        // Find the minimum residual capacity along the path filled by BFS\n        int path_flow = numeric_limits<int>::max();\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            path_flow = min(path_flow, residualGraph[u][v]);\n        }\n\n        // Update residual capacities of the edges and reverse edges along the path\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            residualGraph[u][v] -= path_flow;\n            residualGraph[v][u] += path_flow;\n        }\n\n        // Add path flow to overall flow\n        max_flow += path_flow;\n    }\n\n    // Return the overall flow\n    return max_flow;\n}\n\nint main() {\n    // Example graph represented as an adjacency matrix (capacity of edges)\n    vector<vector<int>> graph = {\n        {0, 16, 13, 0, 0, 0},\n        {0, 0, 10, 12, 0, 0},\n        {0, 4, 0, 0, 14, 0},\n        {0, 0, 9, 0, 0, 20},\n        {0, 0, 0, 7, 0, 4},\n        {0, 0, 0, 0, 0, 0}\n    };\n\n    int source = 0; // Source node\n    int sink = 5;   // Sink node\n\n    cout << \"The maximum possible flow is \" << edmondsKarp(graph, source, sink) << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=GiN3jRdgxU4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/max-flow/"
      ]
    ]
  },
  "eulerian": {
    "title": "Eulerian Path and Circuit",
    "short": "An Eulerian path is a path in a graph that visits every edge exactly once. If this path starts and ends at the same vertex, it's called an Eulerian circuit (or cycle). Eulerian paths and circuits exist in undirected graphs if and only if specific degree conditions are met: For a circuit, all vertices must have even degree; for a path, exactly two vertices must have odd degree, with the path starting and ending at these vertices. They are used in network analysis, DNA sequencing, and puzzles like the Seven Bridges of Knigsberg.",
    "time": "O(E), where E is the number of edges.",
    "space": "O(V + E), where V is the number of vertices and E is the number of edges (for storing the graph).",
    "code": " #include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to find an Eulerian path or circuit in a graph.\nclass EulerianPath {\npublic:\n    int num_vertices;\n    vector<vector<int>> adj;\n    vector<pair<int, int>> edges;\n\n    EulerianPath(int n) : num_vertices(n) {\n        adj.resize(num_vertices);\n    }\n\n    void add_edge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u); // For undirected graph\n        edges.push_back({u,v});\n        edges.push_back({v,u});\n    }\n\n    // Check if a graph has an Eulerian path or circuit\n    bool isEulerian() {\n        int odd_degree_count = 0;\n        for (int i = 0; i < num_vertices; ++i) {\n            if (adj[i].size() % 2 != 0) {\n                odd_degree_count++;\n            }\n        }\n\n        // An Eulerian circuit exists if all vertices have even degree.\n        if (odd_degree_count == 0) {\n            return true; //Eulerian Cycle\n        } else if (odd_degree_count == 2) {\n            return true; // Eulerian path\n        } else {\n            return false; // No Eulerian path or circuit\n        }\n    }\n\n    // Depth-First Search to find Eulerian path\n    void findEulerianPathUtil(int u, vector<int>& path, vector<bool>& visited) {\n        for(int i = 0; i < adj[u].size(); ++i) {\n           int v = adj[u][i];\n           pair<int, int> edge1 = {u, v};\n           pair<int, int> edge2 = {v, u};\n           bool found = false;\n\n           for (int j = 0; j < edges.size(); ++j){\n             if (edges[j] == edge1){\n                edges.erase(edges.begin() + j);\n                found = true;\n                break;\n             }\n           }\n\n           if(found){\n             findEulerianPathUtil(v, path, visited);\n           }\n        }\n        path.push_back(u);\n    }\n\n    // Function to find and print an Eulerian path/circuit\n    void findEulerianPath() {\n        if (!isEulerian()) {\n            cout << \"Graph does not have an Eulerian path/circuit\" << endl;\n            return;\n        }\n\n        int start_node = 0; // Starting vertex\n        for (int i = 0; i < num_vertices; ++i) {\n            if (adj[i].size() % 2 != 0) {\n                start_node = i; // Start at a vertex with odd degree if path exists\n                break;\n            }\n        }\n\n        vector<int> path;\n        vector<bool> visited(num_vertices, false);\n        vector<pair<int,int>> temp_edges = edges;\n        findEulerianPathUtil(start_node, path, visited);\n\n        cout << \"Eulerian Path/Circuit: \";\n        for (int i = path.size() - 1; i >= 0; --i) {\n            cout << path[i] << (i == 0 ? \"\" : \" -> \");\n        }\n        cout << endl;\n\n        edges = temp_edges;  //restore the edges for future use.\n    }\n};\n\nint main() {\n    // Example Usage\n    EulerianPath graph1(4); // Create a graph with 4 vertices\n    graph1.add_edge(0, 1);\n    graph1.add_edge(0, 2);\n    graph1.add_edge(1, 2);\n    graph1.add_edge(2, 3);\n    graph1.findEulerianPath();\n\n    EulerianPath graph2(5);\n    graph2.add_edge(1, 0);\n    graph2.add_edge(0, 2);\n    graph2.add_edge(2, 1);\n    graph2.add_edge(0, 3);\n    graph2.add_edge(3, 4);\n    graph2.add_edge(1, 4);\n    graph2.findEulerianPath();\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/eulerian-path-and-circuit/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=nDMj34w-eq0"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  },
  "pattern-matching": {
    "title": "Knuth-Morris-Pratt (KMP) Algorithm",
    "short": "The Knuth-Morris-Pratt (KMP) algorithm is an efficient string searching algorithm that searches for occurrences of a 'pattern' string within a main 'text' string. It avoids re-examining previously matched characters by utilizing a precomputed 'longest proper prefix suffix' (LPS) array. KMP significantly improves the time complexity compared to naive string matching by intelligently shifting the pattern based on the LPS array.",
    "time": "Average: O(n+m), Best: O(n), Worst: O(n+m), where n is the length of the text and m is the length of the pattern.",
    "space": "O(m), where m is the length of the pattern (for the LPS array).",
    "code": "// C++ implementation of the Knuth-Morris-Pratt (KMP) algorithm\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the longest proper prefix suffix (LPS) array\nvector<int> computeLPSArray(const string& pattern) {\n    int m = pattern.length();\n    vector<int> lps(m, 0);\n    int len = 0; // Length of the previous longest prefix suffix\n    int i = 1;\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n// Function to perform the KMP search\nvector<int> KMPSearch(const string& text, const string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> lps = computeLPSArray(pattern);\n    vector<int> occurrences; // Store the starting indices of pattern occurrences\n\n    int i = 0; // index for text\n    int j = 0; // index for pattern\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            j++;\n            i++;\n        }\n        if (j == m) {\n            occurrences.push_back(i - j); // Pattern found at index i-j\n            j = lps[j - 1];\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return occurrences;\n}\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n\n    vector<int> occurrences = KMPSearch(text, pattern);\n\n    if (occurrences.empty()) {\n        cout << \"Pattern not found in the text.\" << endl;\n    } else {\n        cout << \"Pattern found at the following indices: \";\n        for (int index : occurrences) {\n            cout << index << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=GTJrB7IDVdg"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/string-matching/"
      ]
    ]
  },
  "kmp": {
    "title": "Knuth-Morris-Pratt (KMP) Algorithm",
    "short": "The Knuth-Morris-Pratt (KMP) algorithm is a string searching algorithm that efficiently finds occurrences of a pattern within a text. It avoids unnecessary comparisons by utilizing a precomputed \"longest proper prefix suffix\" (LPS) array, allowing it to shift the pattern by more than one position when a mismatch occurs. This optimization significantly improves performance compared to naive string searching algorithms, particularly when the pattern contains repeating substrings.",
    "time": "Average: O(n+m), Best: O(n), Worst: O(n+m) where n is the length of the text and m is the length of the pattern.",
    "space": "O(m) where m is the length of the pattern (for the LPS array).",
    "code": " #include <iostream>\n#include <string>\n#include <vector>\n\n// Function to compute the Longest Proper Prefix Suffix (LPS) array\nstd::vector<int> computeLPSArray(const std::string& pattern) {\n    int m = pattern.length();\n    std::vector<int> lps(m, 0);\n    int len = 0; // Length of the previous longest prefix suffix\n    int i = 1;\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n                // Note that we do not increment i here\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return lps;\n}\n\n// Function to implement the KMP algorithm\nvoid KMPSearch(const std::string& text, const std::string& pattern) {\n    int n = text.length();\n    int m = pattern.length();\n\n    // Precompute the LPS array for the pattern\n    std::vector<int> lps = computeLPSArray(pattern);\n\n    int i = 0; // Index for text\n    int j = 0; // Index for pattern\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            j++;\n            i++;\n        }\n\n        if (j == m) {\n            std::cout << \"Pattern found at index \" << i - j << std::endl;\n            j = lps[j - 1]; // Find the next possible match\n        } else if (i < n && pattern[j] != text[i]) {\n            // Mismatch after j matches\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n}\n\nint main() {\n    std::string text = \"ABABDABACDABABCABAB\";\n    std::string pattern = \"ABABCABAB\";\n    KMPSearch(text, pattern);\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=GTJrBwHkQnc"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/string-matching/"
      ]
    ]
  },
  "rabin-karp": {
    "title": "Rabin-Karp Algorithm",
    "short": "The Rabin-Karp algorithm is a string searching algorithm that uses hashing to find any one of a set of pattern strings in a text. It works by calculating a hash value for the pattern and then sliding a window of the same length through the text, computing the hash value for each window. If the hash values match, a character-by-character comparison is performed to verify a true match, reducing the number of comparisons needed overall.",
    "time": "Average: O(n+m), Best: O(m), Worst: O(nm) where n is the length of the text and m is the length of the pattern.",
    "space": "O(1)",
    "code": "// Rabin-Karp Algorithm Implementation in C++\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to implement the Rabin-Karp Algorithm\nvector<int> rabinKarp(const string& text, const string& pattern, int q, int d) {\n    // q is a prime number for modulo operation, d is the number of characters in the input alphabet (e.g., 256 for ASCII)\n    int n = text.length();\n    int m = pattern.length();\n    vector<int> occurrences;\n\n    // If the pattern is longer than the text, it cannot be found\n    if (m > n) {\n        return occurrences; // Return empty vector\n    }\n\n    int h = 1; // h = d^(m-1) mod q\n    for (int i = 0; i < m - 1; i++) {\n        h = (h * d) % q;\n    }\n\n    int p = 0; // Hash value for pattern\n    int t = 0; // Hash value for text\n\n    // Calculate the hash value of pattern and the first window of text\n    for (int i = 0; i < m; i++) {\n        p = (d * p + pattern[i]) % q;\n        t = (d * t + text[i]) % q;\n    }\n\n    // Slide the pattern over text one by one\n    for (int i = 0; i <= n - m; i++) {\n        // Check the hash values of current window of text and pattern.\n        // If the hash values match then only check for characters on by one\n        if (p == t) {\n            bool match = true;\n            for (int j = 0; j < m; j++) {\n                if (text[i + j] != pattern[j]) {\n                    match = false;\n                    break;\n                }\n            }\n\n            if (match) {\n                occurrences.push_back(i); // Pattern found at index i\n            }\n        }\n\n        // Calculate hash value for the next window of text: Remove leading digit, add trailing digit\n        if (i < n - m) {\n            t = (d * (t - text[i] * h) + text[i + m]) % q; // Rolling Hash Calculation\n            // We might get negative value of t, converting it to positive\n            if (t < 0) {\n                t = (t + q);\n            }\n        }\n    }\n\n    return occurrences;\n}\n\nint main() {\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n    int q = 101; // A prime number\n    int d = 256; // Number of characters in the input alphabet\n\n    vector<int> occurrences = rabinKarp(text, pattern, q, d);\n\n    if (occurrences.empty()) {\n        cout << \"Pattern not found\" << endl;\n    } else {\n        cout << \"Pattern found at indices: \";\n        for (int index : occurrences) {\n            cout << index << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=QHBhPXOGJ1Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/rabin-karp/"
      ]
    ]
  },
  "z-algorithm": {
    "title": "Z Algorithm",
    "short": "The Z algorithm is a linear time string matching algorithm that finds all occurrences of a pattern in a text. It constructs a Z array, where Z[i] represents the length of the longest substring starting at index i of the string S (formed by concatenating pattern and text with a separator) that matches a prefix of S. The algorithm efficiently computes the Z array, enabling the identification of pattern occurrences by checking if any Z[i] equals the pattern's length.",
    "time": "O(n)",
    "space": "O(n)",
    "code": "// C++ implementation of Z algorithm\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to compute the Z array\nvector<int> computeZArray(const string& str) {\n    int n = str.length();\n    vector<int> Z(n, 0);\n    int L = 0, R = 0; //L and R are the left and right boundaries of a window which match with the prefix of str\n\n    for (int i = 1; i < n; ++i) {\n        if (i > R) {\n            // If i is outside the current Z-box.\n            L = R = i;\n            // R-L = 0 in starting, so it will start checking from i=0 for pattern matching\n            while (R < n && str[R - L] == str[R]) {\n                R++;\n            }\n            Z[i] = R - L;\n            R--;\n        } else {\n            // If i is inside the current Z-box.\n            int k = i - L; // k is the corresponding index in the prefix.\n            if (Z[k] < R - i + 1) {\n                // If Z[k] doesn't extend beyond the current Z-box.\n                Z[i] = Z[k];\n            } else {\n                // If Z[k] extends beyond the current Z-box.\n                L = i;\n                while (R < n && str[R - L] == str[R]) {\n                    R++;\n                }\n                Z[i] = R - L;\n                R--;\n            }\n        }\n    }\n    return Z;\n}\n\n// Function to search for a pattern in a text using the Z algorithm\nvoid searchPattern(const string& text, const string& pattern) {\n    string combinedString = pattern + \"$\" + text; // Concatenate pattern, a separator, and text.\n    vector<int> Z = computeZArray(combinedString);\n    int patternLength = pattern.length();\n    int combinedLength = combinedString.length();\n\n    for (int i = patternLength + 1; i < combinedLength; ++i) {\n        if (Z[i] == patternLength) {\n            cout << \"Pattern found at index \" << i - patternLength - 1 << endl; // Adjust index to be relative to the text\n        }\n    }\n}\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n\n    cout << \"Searching for pattern '\" << pattern << \"' in text '\" << text << \"'\\n\";\n    searchPattern(text, pattern);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/z-algorithm-string-pattern-searching/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=JoF2MWMa8_U"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/2206x16/"
      ]
    ]
  },
  "suffix-array": {
    "title": "Suffix Array",
    "short": "A suffix array is a sorted array of all suffixes of a string. It provides an efficient way to perform various string operations, like searching for a pattern within a text. By storing the starting indices of the sorted suffixes, it enables fast substring search and other string-related queries.",
    "time": "Average: O(n log n), Best: O(n log n), Worst: O(n log n) for construction using efficient algorithms like the DC3 algorithm (skew algorithm). Searching for a pattern of length m is typically O(m log n) using binary search.",
    "space": "O(n), where n is the length of the string.",
    "code": "cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent a suffix and its index\nstruct Suffix {\n    int index;\n    string suffix;\n};\n\n// Comparison function to sort suffixes lexicographically\nbool compareSuffixes(const Suffix& a, const Suffix& b) {\n    return a.suffix < b.suffix;\n}\n\n// Function to build the suffix array for a given text\nvector<int> buildSuffixArray(const string& text) {\n    int n = text.length();\n\n    // Create a vector of suffixes\n    vector<Suffix> suffixes(n);\n    for (int i = 0; i < n; ++i) {\n        suffixes[i].index = i;\n        suffixes[i].suffix = text.substr(i);\n    }\n\n    // Sort the suffixes using the custom comparison function\n    sort(suffixes.begin(), suffixes.end(), compareSuffixes);\n\n    // Create the suffix array\n    vector<int> suffixArray(n);\n    for (int i = 0; i < n; ++i) {\n        suffixArray[i] = suffixes[i].index;\n    }\n\n    return suffixArray;\n}\n\n// Function to search for a pattern in the text using the suffix array\nint searchPattern(const string& text, const string& pattern, const vector<int>& suffixArray) {\n    int n = text.length();\n    int m = pattern.length();\n\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int suffixIndex = suffixArray[mid];\n        string suffix = text.substr(suffixIndex, m); // Limit comparison to pattern length\n\n        if (suffix == pattern) {\n            return suffixIndex; // Pattern found\n        } else if (suffix < pattern) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1; // Pattern not found\n}\n\nint main() {\n    string text = \"banana$\"; // Add a sentinel character to ensure uniqueness of suffixes\n    string pattern = \"ana\";\n\n    vector<int> suffixArray = buildSuffixArray(text);\n\n    cout << \"Suffix Array: \";\n    for (int index : suffixArray) {\n        cout << index << \" \";\n    }\n    cout << endl;\n\n    int position = searchPattern(text, pattern, suffixArray);\n\n    if (position != -1) {\n        cout << \"Pattern found at index: \" << position << endl;\n    } else {\n        cout << \"Pattern not found.\" << endl;\n    }\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/suffix-array-set-1-introduction/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=m0X3-8F4FGw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/suffix-array/"
      ]
    ]
  },
  "bit-manipulation": {
    "title": "Bit Manipulation",
    "short": "Bit manipulation involves performing operations at the level of individual bits within integers. It utilizes operators like AND, OR, XOR, NOT, left shift, and right shift to efficiently modify and analyze binary data. Bit manipulation is often employed to optimize algorithms by leveraging low-level hardware capabilities, enabling faster calculations and compact data representation in tasks like set operations, data compression, and cryptography.",
    "time": "Operations typically take O(1) time as they are basic CPU instructions.",
    "space": "O(1)",
    "code": "// C++ Bit Manipulation Example\n#include <iostream>\n\nusing namespace std;\n\n// Function to check if a number is even or odd using bit manipulation\nbool isEven(int n) {\n    // If the least significant bit is 0, the number is even\n    return (n & 1) == 0;\n}\n\n// Function to get the i-th bit of a number (0-indexed)\nint getBit(int n, int i) {\n    return (n >> i) & 1;\n}\n\n// Function to set the i-th bit of a number to 1\nint setBit(int n, int i) {\n    return (n | (1 << i));\n}\n\n// Function to clear the i-th bit of a number to 0\nint clearBit(int n, int i) {\n    return (n & (~(1 << i)));\n}\n\n// Function to update (set or clear) the i-th bit of a number\nint updateBit(int n, int i, int v) {\n    // Clear the i-th bit first\n    n = clearBit(n, i);\n    // Set the i-th bit to v\n    return (n | (v << i));\n}\n\n// Function to count the number of set bits (1s) in a number\nint countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        n &= (n - 1); // Clears the least significant set bit\n        count++;\n    }\n    return count;\n}\n\nint main() {\n    int num = 10; // Binary representation: 1010\n\n    cout << \"Number: \" << num << endl;\n    cout << \"Is even: \" << isEven(num) << endl;\n    cout << \"Bit at index 1: \" << getBit(num, 1) << endl;\n\n    int setBitNum = setBit(num, 1); // Set bit at index 1\n    cout << \"Number after setting bit 1: \" << setBitNum << endl;\n\n    int clearBitNum = clearBit(num, 3); // Clear bit at index 3\n    cout << \"Number after clearing bit 3: \" << clearBitNum << endl;\n\n    int updateBitNum = updateBit(num, 0, 1); // Update bit at index 0 to 1\n    cout << \"Number after updating bit 0 to 1: \" << updateBitNum << endl;\n\n    int num2 = 31; //Binary: 11111\n    cout << \"Number of set bits in \" << num2 << \" : \" << countSetBits(num2) << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=NLkq3685pCw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/bit-manipulation/"
      ]
    ]
  },
  "basic-operations": {
    "title": "Array Basic Operations",
    "short": "Arrays are fundamental data structures that store a fixed-size sequential collection of elements of the same type. Basic array operations involve accessing, searching, inserting, and deleting elements. Understanding these operations is crucial for efficient data manipulation and lays the groundwork for more complex algorithms. Arrays are widely used due to their simplicity and direct access capabilities.",
    "time": {
      "Access": "O(1)",
      "Search": "O(n) (Unsorted), O(log n) (Sorted with Binary Search)",
      "Insertion": "O(n) (Worst Case - requires shifting)",
      "Deletion": "O(n) (Worst Case - requires shifting)"
    },
    "space": "O(n)",
    "code": " #include <iostream>\n #include <vector>\n #include <algorithm>\n\n using namespace std;\n\n int main() {\n   // Array (implemented using std::vector in C++ for dynamic sizing)\n   vector<int> arr = {10, 20, 30, 40, 50};\n\n   // 1. Accessing an element (O(1))\n   cout << \"Element at index 2: \" << arr[2] << endl;\n\n   // 2. Searching for an element (O(n) - Linear Search)\n   int key = 30;\n   int index = -1;\n   for (int i = 0; i < arr.size(); ++i) {\n     if (arr[i] == key) {\n       index = i;\n       break;\n     }\n   }\n\n   if (index != -1) {\n     cout << \"Element \" << key << \" found at index: \" << index << endl;\n   } else {\n     cout << \"Element \" << key << \" not found in the array.\" << endl;\n   }\n\n   // 3. Inserting an element at the end (Amortized O(1) - vector capacity matters)\n   arr.push_back(60);\n   cout << \"Array after inserting 60 at the end: \";\n   for (int x : arr) cout << x << \" \";\n   cout << endl;\n\n   // 4. Inserting an element at a specific position (O(n))\n   arr.insert(arr.begin() + 2, 25); // Insert 25 at index 2\n   cout << \"Array after inserting 25 at index 2: \";\n   for (int x : arr) cout << x << \" \";\n   cout << endl;\n\n   // 5. Deleting an element by index (O(n))\n   arr.erase(arr.begin() + 3); // Delete element at index 3\n   cout << \"Array after deleting element at index 3: \";\n   for (int x : arr) cout << x << \" \";\n   cout << endl;\n\n   // 6. Deleting an element by value (O(n))\n   auto it = find(arr.begin(), arr.end(), 40);\n   if (it != arr.end()) {\n     arr.erase(it);\n     cout << \"Array after deleting element 40: \";\n     for (int x : arr) cout << x << \" \";\n     cout << endl;\n   } else {\n     cout << \"Element 40 not found for deletion.\" << endl;\n   }\n\n   return 0;\n }",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/array-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=j2wqX9L16io"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/array/"
      ]
    ]
  },
  "set": {
    "title": "Set",
    "short": "A set is an abstract data type that stores a collection of unique elements. It provides efficient operations for checking membership, adding new elements, and removing existing elements.  Sets ensure that no duplicate elements are present, making them useful for tasks such as deduplication and membership testing.",
    "time": "Access: O(n) or O(1) (unordered_set), Search: O(n) or O(1) (unordered_set), Insertion: O(log n) or O(1) (unordered_set), Deletion: O(log n) or O(1) (unordered_set)",
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <set>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n  // Demonstrate the use of std::set (ordered set)\n  cout << \"Demonstrating std::set (ordered set):\\n\";\n  set<int> mySet;\n\n  // Insert elements into the set\n  mySet.insert(30);\n  mySet.insert(10);\n  mySet.insert(20);\n  mySet.insert(10); // Duplicate element, won't be inserted\n\n  // Print the elements of the set (they will be sorted)\n  cout << \"Set elements: \";\n  for (int element : mySet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  // Check if an element is present in the set\n  int searchElement = 20;\n  if (mySet.count(searchElement)) {\n    cout << searchElement << \" is present in the set.\\n\";\n  } else {\n    cout << searchElement << \" is not present in the set.\\n\";\n  }\n\n  // Delete an element from the set\n  mySet.erase(20);\n  cout << \"Set after deleting 20: \";\n  for (int element : mySet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  // Demonstrate the use of std::unordered_set (unordered set)\n  cout << \"\\nDemonstrating std::unordered_set (unordered set):\\n\";\n  unordered_set<int> myUnorderedSet;\n\n  // Insert elements into the unordered_set\n  myUnorderedSet.insert(30);\n  myUnorderedSet.insert(10);\n  myUnorderedSet.insert(20);\n  myUnorderedSet.insert(10); // Duplicate element, won't be inserted\n\n  // Print the elements of the unordered_set (order is not guaranteed)\n  cout << \"Unordered set elements: \";\n  for (int element : myUnorderedSet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  // Check if an element is present in the unordered_set\n  searchElement = 20;\n  if (myUnorderedSet.count(searchElement)) {\n    cout << searchElement << \" is present in the unordered set.\\n\";\n  } else {\n    cout << searchElement << \" is not present in the unordered set.\\n\";\n  }\n\n  // Delete an element from the unordered_set\n  myUnorderedSet.erase(20);\n  cout << \"Unordered set after deleting 20: \";\n  for (int element : myUnorderedSet) {\n    cout << element << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/set-in-cpp-stl/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=I1R8W9K6-3U"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/set/"
      ]
    ]
  },
  "counting-set-bits": {
    "title": "Counting Set Bits",
    "short": "Counting set bits, also known as the Hamming weight, is the problem of determining the number of bits that are set to 1 in a binary representation of an integer. This has applications in various fields, including cryptography, error correction, and population counting. Efficient algorithms can significantly reduce the computation time compared to naively iterating through all bits.",
    "time": "Depends on the algorithm. Naive: O(n) where n is the number of bits. Brian Kernighan's Algorithm: O(k) where k is the number of set bits. Lookup Table: O(1) for fixed-size integers.",
    "space": "O(1) for most algorithms, except lookup table which can be O(2^n) where n is the number of bits in the lookup.",
    "code": "// C++ program to count set bits (1s) in an integer\n#include <iostream>\n#include <vector>\n\n// Method 1: Naive Approach (Iterate through all bits)\nunsigned int countSetBitsNaive(unsigned int n) {\n    unsigned int count = 0;\n    while (n) {\n        count += n & 1; // Check the last bit\n        n >>= 1;         // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Method 2: Brian Kernighan's Algorithm\n// This algorithm is more efficient as it iterates only through set bits.\nunsigned int countSetBitsBrianKernighan(unsigned int n) {\n    unsigned int count = 0;\n    while (n) {\n        n &= (n - 1); // Unsets the rightmost set bit\n        count++;\n    }\n    return count;\n}\n\n// Method 3: Lookup Table Method (for 8-bit integers)\n// Precompute the set bit counts for all possible 8-bit values.\nunsigned int countSetBitsLookupTable(unsigned int n, const std::vector<unsigned int>& lookupTable) {\n    return lookupTable[n & 0xFF]; // Access the lookup table\n}\n\n// Method 4: Using Bitset\n#include <bitset>\nunsigned int countSetBitsBitset(unsigned int n) {\n    std::bitset<32> b(n); // Assuming 32-bit integer\n    return b.count();\n}\n\n\nint main() {\n    unsigned int n = 31; // Example number (binary: 000...0011111)\n    std::cout << \"Number: \" << n << std::endl;\n\n    std::cout << \"Naive Approach: \" << countSetBitsNaive(n) << std::endl;\n    std::cout << \"Brian Kernighan's Algorithm: \" << countSetBitsBrianKernighan(n) << std::endl;\n\n    // Example usage of Lookup Table method\n    std::vector<unsigned int> lookupTable(256); // Table for 8-bit values\n    for (int i = 0; i < 256; ++i) {\n        lookupTable[i] = countSetBitsNaive(i); // Precompute counts for each value\n    }\n\n    std::cout << \"Lookup Table (low 8 bits): \" << countSetBitsLookupTable(n & 0xFF, lookupTable) << std::endl;\n    std::cout << \"Bitset Approach: \" << countSetBitsBitset(n) << std::endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/count-set-bits-in-an-integer/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=jEuC3FhcqZY"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/bit-manipulation/"
      ]
    ]
  },
  "bitmask-dp": {
    "title": "Bitmask Dynamic Programming",
    "short": "Bitmask Dynamic Programming is a dynamic programming technique that uses bit manipulation to represent the state of a subset or combination of elements. It is particularly useful for problems involving subsets, permutations, or combinations where the size of the input is relatively small (typically up to 20-25) due to exponential state space. By using bits to encode the inclusion or exclusion of elements, the DP state can be represented as an integer, allowing for efficient storage and manipulation of states.",
    "time": "O(2^N * N * complexity_of_operation)",
    "space": "O(2^N * N) or O(2^N) depending on the problem and optimization",
    "code": "// C++ implementation of Bitmask DP for the Traveling Salesman Problem (TSP)\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\n// Function to solve TSP using Bitmask DP\nint tsp(vector<vector<int>>& dist, int n) {\n    // dp[mask][i] stores the minimum cost to visit all cities represented by 'mask'\n    // ending at city 'i'\n    vector<vector<int>> dp((1 << n), vector<int>(n, INT_MAX));\n\n    // Base case: starting from city 0, no cities visited yet (only city 0)\n    dp[1][0] = 0;\n\n    // Iterate through all possible masks (subsets of cities)\n    for (int mask = 1; mask < (1 << n); ++mask) {\n        // Iterate through all possible ending cities 'i'\n        for (int i = 0; i < n; ++i) {\n            // If city 'i' is not in the mask, skip\n            if (!(mask & (1 << i))) continue;\n\n            // Iterate through all possible previous cities 'j'\n            for (int j = 0; j < n; ++j) {\n                // If city 'j' is the same as city 'i' or not in the mask, skip\n                if (i == j || !(mask & (1 << j))) continue;\n\n                // Calculate the cost of going from city 'j' to city 'i'\n                // Update dp[mask][i] with the minimum cost\n                dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 << i)][j] + dist[j][i]);\n            }\n        }\n    }\n\n    // Find the minimum cost to visit all cities and return to city 0\n    int minCost = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        minCost = min(minCost, dp[(1 << n) - 1][i] + dist[i][0]);\n    }\n\n    return minCost;\n}\n\nint main() {\n    // Example distance matrix (replace with your input)\n    vector<vector<int>> dist = {\n        {0, 10, 15, 20},\n        {10, 0, 35, 25},\n        {15, 35, 0, 30},\n        {20, 25, 30, 0}\n    };\n\n    int n = dist.size(); // Number of cities\n\n    // Solve TSP and print the result\n    int minCost = tsp(dist, n);\n    cout << \"Minimum cost for TSP: \" << minCost << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/travelling-salesman-problem-using-dynamic-programming/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=JE0JE8ce1V8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/dynamic-programming/"
      ]
    ]
  },
  "tree": {
    "title": "Tree Data Structure",
    "short": "A tree is a hierarchical data structure consisting of nodes connected by edges. It resembles an upside-down tree, with a root node at the top and branches extending downwards. Trees are used to represent hierarchical relationships, such as organizational charts, file systems, and parse trees in compilers. They offer efficient ways to organize and search data based on these hierarchical relationships.",
    "time": {
      "Access": "O(n) in worst case (skewed tree), O(log n) in average case (balanced tree)",
      "Search": "O(n) in worst case (skewed tree), O(log n) in average case (balanced tree)",
      "Insertion": "O(n) in worst case (skewed tree), O(log n) in average case (balanced tree)",
      "Deletion": "O(n) in worst case (skewed tree), O(log n) in average case (balanced tree)"
    },
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n#include <queue>\n\n// Definition of a generic tree node\ntemplate <typename T>\nstruct TreeNode {\n    T data;\n    std::vector<TreeNode<T>*> children;\n\n    TreeNode(T data) : data(data) {}\n    ~TreeNode() {\n        for (TreeNode<T>* child : children) {\n            delete child;\n        }\n    }\n};\n\n// Function to print the tree level by level\ntemplate <typename T>\nvoid printLevelWise(TreeNode<T>* root) {\n    if (root == nullptr) {\n        return;\n    }\n\n    std::queue<TreeNode<T>*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        TreeNode<T>* node = q.front();\n        q.pop();\n        std::cout << node->data << \": \";\n        for (TreeNode<T>* child : node->children) {\n            std::cout << child->data << \" \";\n            q.push(child);\n        }\n        std::cout << std::endl;\n    }\n}\n\n// Function to count the number of nodes in the tree\ntemplate <typename T>\nint countNodes(TreeNode<T>* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n\n    int count = 1;\n    for (TreeNode<T>* child : root->children) {\n        count += countNodes(child);\n    }\n    return count;\n}\n\nint main() {\n    // Create a sample tree\n    TreeNode<int>* root = new TreeNode<int>(1);\n    TreeNode<int>* child1 = new TreeNode<int>(2);\n    TreeNode<int>* child2 = new TreeNode<int>(3);\n\n    root->children.push_back(child1);\n    root->children.push_back(child2);\n\n    TreeNode<int>* grandchild1 = new TreeNode<int>(4);\n    child1->children.push_back(grandchild1);\n\n    // Print the tree level wise\n    std::cout << \"Tree Level Wise:\" << std::endl;\n    printLevelWise(root);\n\n    // Count the number of nodes\n    std::cout << \"\\nNumber of nodes: \" << countNodes(root) << std::endl;\n\n    // Remember to free the memory allocated for the tree nodes (handled by the destructor)\n    delete root;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/tree-data-structure/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=qH6yxkw0v-s"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/tree/"
      ]
    ]
  },
  "inorder": {
    "title": "Inorder Tree Traversal",
    "short": "Inorder traversal is a depth-first tree traversal method used to visit all nodes of a binary tree. It follows the pattern: left subtree, root node, right subtree. This traversal is commonly used to retrieve elements from a Binary Search Tree (BST) in sorted order, making it essential for various tree-based algorithms and data manipulation tasks.",
    "time": "Access: N/A, Search: N/A, Insertion: N/A, Deletion: N/A, Traversal: O(N)",
    "space": "O(H) where H is the height of the tree. In the worst case (skewed tree), this becomes O(N).",
    "code": "// C++ program for inorder tree traversal\n#include <iostream>\n\nusing namespace std;\n\n// A binary tree node structure\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\n// Function to perform inorder traversal\nvoid inorderTraversal(Node* root) {\n    if (root == nullptr) {\n        return;\n    }\n\n    // Traverse the left subtree\n    inorderTraversal(root->left);\n\n    // Visit the root node\n    cout << root->data << \" \";\n\n    // Traverse the right subtree\n    inorderTraversal(root->right);\n}\n\n// Example usage (main function)\nint main() {\n    // Construct a sample binary tree\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->left->left = new Node(4);\n    root->left->right = new Node(5);\n\n    cout << \"Inorder traversal of the binary tree is: \";\n    inorderTraversal(root);\n    cout << endl;\n\n    // Clean up memory (important to avoid memory leaks)\n    delete root->left->left;\n    delete root->left->right;\n    delete root->left;\n    delete root->right;\n    delete root;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/inorder-tree-traversal/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=gm8DUJJhmY4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/tree/"
      ]
    ]
  },
  "morris-traversal": {
    "title": "Morris Traversal",
    "short": "Morris Traversal is a space-optimized in-order tree traversal algorithm for binary trees. It avoids using recursion or a stack, achieving O(1) space complexity. The algorithm leverages the concept of creating temporary links (threaded links) between nodes to allow traversal without storing nodes in a stack.",
    "time": "Average: O(n), Best: O(n), Worst: O(n)",
    "space": "O(1)",
    "code": "cpp\n#include <iostream>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nvoid morrisInorder(TreeNode* root) {\n    TreeNode* current = root;\n    while (current != nullptr) {\n        if (current->left == nullptr) {\n            // If left subtree is empty, print current node and move to right subtree\n            std::cout << current->val << \" \";\n            current = current->right;\n        } else {\n            // Find the inorder predecessor of current\n            TreeNode* predecessor = current->left;\n            while (predecessor->right != nullptr && predecessor->right != current) {\n                predecessor = predecessor->right;\n            }\n\n            if (predecessor->right == nullptr) {\n                // Create the thread to current\n                predecessor->right = current;\n                current = current->left;\n            } else {\n                // Thread already exists, so break it and print current\n                predecessor->right = nullptr;\n                std::cout << current->val << \" \";\n                current = current->right;\n            }\n        }\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    // Example usage\n    TreeNode* root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    root->left->left = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n\n    std::cout << \"Morris Inorder Traversal: \";\n    morrisInorder(root);\n\n    // Clean up memory (important to prevent memory leaks!)\n    delete root->left->left;\n    delete root->left->right;\n    delete root->left;\n    delete root->right;\n    delete root;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/morris-traversal-for-inorder/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=80Zug6D1cZ4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/tree/"
      ]
    ]
  },
  "threaded-binary-trees": {
    "title": "Threaded Binary Tree",
    "short": "A threaded binary tree is a binary tree variant where null pointers are replaced by pointers to other nodes in the tree, forming threads.  These threads point to the inorder predecessor (left thread) and inorder successor (right thread) of the node.  This allows for non-recursive inorder traversal without using a stack, improving efficiency and saving space, particularly beneficial when dealing with resource-constrained environments or very large trees.",
    "time": {
      "Access": "O(n)",
      "Search": "O(n) average, O(1) best, O(n) worst",
      "Insertion": "O(n)",
      "Deletion": "O(n)"
    },
    "space": "O(n)",
    "code": "cpp\n#include <iostream>\n\n// Structure for a node in the threaded binary tree\nstruct ThreadedNode {\n    int data;\n    ThreadedNode* left;\n    ThreadedNode* right;\n    bool leftThread;\n    bool rightThread;\n\n    ThreadedNode(int value) : data(value), left(nullptr), right(nullptr), leftThread(true), rightThread(true) {}\n};\n\n// Function to perform inorder traversal of a threaded binary tree\nvoid inorderTraversal(ThreadedNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n\n    // Find the leftmost node in the tree\n    ThreadedNode* current = root;\n    while (current->left != nullptr && !current->leftThread) {\n        current = current->left;\n    }\n\n    // Traverse the tree using threads\n    while (current != nullptr) {\n        std::cout << current->data << \" \";\n\n        // If right thread is present, go to the inorder successor\n        if (current->rightThread) {\n            current = current->right;\n        } else {\n            // Otherwise, go to the leftmost node in the right subtree\n            current = current->right;\n            while (current != nullptr && current->left != nullptr && !current->leftThread) {\n                current = current->left;\n            }\n        }\n    }\n    std::cout << std::endl;\n}\n\n// Function to insert a new node into the threaded binary tree\nThreadedNode* insert(ThreadedNode* root, int value) {\n    ThreadedNode* newNode = new ThreadedNode(value);\n    if (root == nullptr) {\n        return newNode;\n    }\n\n    ThreadedNode* current = root;\n    ThreadedNode* parent = nullptr;\n\n    // Find the appropriate position to insert the new node\n    while (current != nullptr) {\n        parent = current;\n        if (value < current->data) {\n            if (current->leftThread) {\n                break;\n            } else {\n                current = current->left;\n            }\n        } else {\n            if (current->rightThread) {\n                break;\n            } else {\n                current = current->right;\n            }\n        }\n    }\n\n    // Insert the new node as the left child\n    if (value < parent->data) {\n        newNode->left = parent->left;\n        newNode->right = parent;\n        parent->left = newNode;\n        parent->leftThread = false;\n    } else {\n        // Insert the new node as the right child\n        newNode->right = parent->right;\n        newNode->left = parent;\n        parent->right = newNode;\n        parent->rightThread = false;\n    }\n\n    return root;\n}\n\n// Main function to demonstrate the threaded binary tree\nint main() {\n    ThreadedNode* root = nullptr;\n\n    // Insert some nodes into the tree\n    root = insert(root, 20);\n    root = insert(root, 10);\n    root = insert(root, 30);\n    root = insert(root, 5);\n    root = insert(root, 15);\n    root = insert(root, 25);\n    root = insert(root, 35);\n\n    // Perform inorder traversal of the tree\n    std::cout << \"Inorder traversal: \";\n    inorderTraversal(root);\n\n    // Clean up memory (important! needs proper tree deletion implementation)\n    // In a real-world scenario, you'd want to implement a proper tree deletion function\n    // to avoid memory leaks. This is omitted here for brevity but crucial for robust code.\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/threaded-binary-tree/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=X8tM-8Ld_E8"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?search=binary%20tree"
      ]
    ]
  },
  "common-algorithms": {
    "title": "Binary Search",
    "short": "Binary search is an efficient algorithm for finding a specific element within a sorted array. It repeatedly divides the search interval in half. If the middle element matches the target value, the search is successful. Otherwise, the search continues in either the left or right half of the array, depending on whether the target value is less than or greater than the middle element. This process continues until the target is found or the search interval is empty.",
    "time": "Average: O(log n), Best: O(1), Worst: O(log n)",
    "space": "O(1)",
    "code": "// Binary Search Implementation\n#include <iostream>\n#include <vector>\n\nint binarySearch(const std::vector<int>& arr, int target) {\n    // Initialize left and right pointers\n    int left = 0;\n    int right = arr.size() - 1;\n\n    // Iterate while the left pointer is less than or equal to the right pointer\n    while (left <= right) {\n        // Calculate the middle index\n        int mid = left + (right - left) / 2; // Prevent potential overflow\n\n        // Check if the middle element is equal to the target\n        if (arr[mid] == target) {\n            return mid; // Target found, return the index\n        }\n\n        // If the target is less than the middle element, search the left half\n        if (target < arr[mid]) {\n            right = mid - 1;\n        } else {\n            // If the target is greater than the middle element, search the right half\n            left = mid + 1;\n        }\n    }\n\n    // Target not found, return -1\n    return -1;\n}\n\nint main() {\n    // Example usage\n    std::vector<int> sortedArray = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int targetValue = 23;\n\n    // Perform binary search\n    int index = binarySearch(sortedArray, targetValue);\n\n    // Print the result\n    if (index != -1) {\n        std::cout << \"Target \" << targetValue << \" found at index \" << index << std::endl;\n    } else {\n        std::cout << \"Target \" << targetValue << \" not found in the array.\" << std::endl;\n    }\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/binary-search/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=oSU5jGiGfjI"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/binary-search/"
      ]
    ]
  },
  "kadane": {
    "title": "Kadane's Algorithm",
    "short": "Kadane's algorithm is a dynamic programming algorithm used to find the maximum sum of a contiguous subarray within a one-dimensional array of numbers. It works by iterating through the array, maintaining two variables: the current maximum ending at the current position and the overall maximum found so far. The algorithm efficiently solves the maximum subarray problem in linear time, making it a powerful tool for array analysis.",
    "time": "O(n)",
    "space": "O(1)",
    "code": "// C++ implementation of Kadane's Algorithm\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint kadane(const vector<int>& arr) {\n    // Initialize max_so_far to the smallest possible integer to handle cases with all negative numbers.\n    int max_so_far = -2147483648; //INT_MIN\n    int current_max = 0;\n\n    // Iterate through the array\n    for (int i = 0; i < arr.size(); ++i) {\n        // Update current_max by adding the current element.\n        current_max += arr[i];\n\n        // If current_max is greater than max_so_far, update max_so_far.\n        if (current_max > max_so_far) {\n            max_so_far = current_max;\n        }\n\n        // If current_max becomes negative, reset it to 0.\n        // A negative current_max indicates that the current subarray is not contributing to a larger sum.\n        if (current_max < 0) {\n            current_max = 0;\n        }\n    }\n\n    // Return the overall maximum sum found.\n    return max_so_far;\n}\n\nint main() {\n    vector<int> arr = {-2, -3, 4, -1, -2, 1, 5, -3};\n\n    // Find the maximum contiguous subarray sum using Kadane's Algorithm\n    int max_sum = kadane(arr);\n\n    // Print the result\n    cout << \"Maximum contiguous subarray sum: \" << max_sum << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=86CQq3pKSUw"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/kadanes-algorithm/"
      ]
    ]
  },
  "fast-exponentiation": {
    "title": "Fast Exponentiation (Exponentiation by Squaring)",
    "short": "Fast exponentiation, also known as exponentiation by squaring, is an efficient algorithm for computing large integer powers of a number.  It leverages the property that x^n can be expressed as (x^(n/2))^2 if n is even, and x * (x^((n-1)/2))^2 if n is odd.  This method significantly reduces the number of multiplications required compared to the naive approach, making it suitable for applications in cryptography, number theory, and computer algebra where modular exponentiation is essential.",
    "time": "O(log n)",
    "space": "O(1)",
    "code": "// Fast Exponentiation (Exponentiation by Squaring)\n#include <iostream>\n\n// Iterative version\nlong long fastPowerIterative(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent > 0) {\n        // If exponent is odd, multiply base with result\n        if (exponent % 2 == 1) {\n            result *= base;\n        }\n\n        // Divide the exponent by 2 and square the base\n        base *= base;\n        exponent /= 2;\n    }\n    return result;\n}\n\n// Recursive version\nlong long fastPowerRecursive(long long base, long long exponent) {\n    // Base case: if exponent is 0, return 1\n    if (exponent == 0) {\n        return 1;\n    }\n\n    // If exponent is even\n    if (exponent % 2 == 0) {\n        long long halfPower = fastPowerRecursive(base, exponent / 2);\n        return halfPower * halfPower;\n    } else {\n        // If exponent is odd\n        return base * fastPowerRecursive(base, exponent - 1);\n    }\n}\n\n// Fast Exponentiation with Modulo (Modular Exponentiation)\nlong long fastPowerModulo(long long base, long long exponent, long long modulus) {\n    long long result = 1;\n    base = base % modulus; // Ensure base is within the modulus range\n    while (exponent > 0) {\n        // If exponent is odd, multiply base with result\n        if (exponent % 2 == 1) {\n            result = (result * base) % modulus;\n        }\n\n        // Divide the exponent by 2 and square the base\n        base = (base * base) % modulus;\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main() {\n    long long base = 2;\n    long long exponent = 10;\n    long long modulus = 1000000007; // A common prime modulus\n\n    std::cout << \"Iterative: \" << fastPowerIterative(base, exponent) << std::endl;\n    std::cout << \"Recursive: \" << fastPowerRecursive(base, exponent) << std::endl;\n    std::cout << \"Modulo: \" << fastPowerModulo(base, exponent, modulus) << std::endl;\n\n    //Example with large numbers:\n    base = 5;\n    exponent = 100000;\n    std::cout << \"Modulo with large exponent: \" << fastPowerModulo(base, exponent, modulus) << std::endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/exponential-squaring-fast-exponentiation/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=e0IgKl2mU9w"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/powx-n/"
      ]
    ]
  },
  "randomized-algorithms": {
    "title": "Randomized Algorithms",
    "short": "Randomized algorithms are algorithms that employ randomness as part of their logic. This is typically achieved by using a random number generator to make decisions during execution. These algorithms are often used when deterministic algorithms are too complex or time-consuming, or when dealing with problems where randomness is inherent, such as Monte Carlo simulations and probabilistic analysis. They provide probabilistic guarantees on performance rather than absolute guarantees.",
    "time": "Varies depending on the specific algorithm. Common examples include: QuickSort (Average: O(n log n), Best: O(n log n), Worst: O(n^2)), Randomized Select (Average: O(n), Worst: O(n^2)), Karger's Algorithm (Expected: O(n^2 log n))",
    "space": "Varies depending on the specific algorithm. Generally, it's O(log n) to O(n) for algorithms using recursion.",
    "code": "// A C++ implementation of Randomized QuickSort\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\n\n// Function to partition the array around a pivot\nint partition(vector<int>& arr, int low, int high) {\n    // Choose the last element as the pivot\n    int pivot = arr[high];\n    int i = (low - 1); // Index of smaller element\n\n    for (int j = low; j <= high - 1; j++) {\n        // If current element is smaller than or equal to pivot\n        if (arr[j] <= pivot) {\n            i++; // increment index of smaller element\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\n// Function to randomly choose a pivot and partition\nint randomizedPartition(vector<int>& arr, int low, int high) {\n    // Generate a random index between low and high\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> distrib(low, high);\n    int randomIndex = distrib(gen);\n\n    // Swap the random element with the last element (pivot)\n    swap(arr[randomIndex], arr[high]);\n\n    // Call the standard partition function\n    return partition(arr, low, high);\n}\n\n// Randomized QuickSort function\nvoid randomizedQuickSort(vector<int>& arr, int low, int high) {\n    if (low < high) {\n        // Partition the array around a randomly chosen pivot\n        int pi = randomizedPartition(arr, low, high);\n\n        // Recursively sort the two sub-arrays\n        randomizedQuickSort(arr, low, pi - 1);\n        randomizedQuickSort(arr, pi + 1, high);\n    }\n}\n\n// Main function for testing\nint main() {\n    vector<int> arr = {10, 7, 8, 9, 1, 5};\n    int n = arr.size();\n\n    cout << \"Unsorted array: \";\n    for (int x : arr) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    randomizedQuickSort(arr, 0, n - 1);\n\n    cout << \"Sorted array: \";\n    for (int x : arr) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/randomized-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=jgvKjGE-D1c"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/?topicSlugs=random"
      ]
    ]
  },
  "lru-cache-implementation": {
    "title": "LRU (Least Recently Used) Cache",
    "short": "An LRU cache is a data structure that manages a fixed-size cache of key-value pairs, evicting the least recently used item when the cache is full. It utilizes a combination of a hash map (dictionary) and a doubly linked list. The hash map provides O(1) average-case access to cached items, while the doubly linked list maintains the order of items based on their usage. LRU caches are widely used in web servers, databases, and operating systems to improve performance by storing frequently accessed data for quick retrieval.",
    "time": "Access: O(1) average, O(n) worst (very rare in practice); Search: O(1) average, O(n) worst (same as access); Insertion: O(1); Deletion: O(1)",
    "space": "O(capacity)",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <list>\n\nclass LRUCache {\nprivate:\n    int capacity;\n    std::unordered_map<int, int> cache;\n    std::list<int> lruList; // Stores keys in LRU order (most recent at front)\n    std::unordered_map<int, std::list<int>::iterator> lruMap; // Maps keys to their iterator in the lruList\n\npublic:\n    LRUCache(int capacity) : capacity(capacity) {}\n\n    int get(int key) {\n        // If the key exists, move it to the front of the LRU list and return the value\n        if (cache.find(key) != cache.end()) {\n            // Move the key to the front of the list (most recently used)\n            lruList.erase(lruMap[key]);\n            lruList.push_front(key);\n            lruMap[key] = lruList.begin();\n            return cache[key];\n        } else {\n            // Key not found\n            return -1;\n        }\n    }\n\n    void put(int key, int value) {\n        // If the key already exists, update the value and move it to the front of the list\n        if (cache.find(key) != cache.end()) {\n            cache[key] = value;\n            lruList.erase(lruMap[key]);\n            lruList.push_front(key);\n            lruMap[key] = lruList.begin();\n        } else {\n            // If the cache is full, remove the least recently used item\n            if (cache.size() == capacity) {\n                // Remove the last element from the list (least recently used)\n                int lruKey = lruList.back();\n                cache.erase(lruKey);\n                lruMap.erase(lruKey);\n                lruList.pop_back();\n            }\n            // Add the new key-value pair to the cache and the front of the list\n            cache[key] = value;\n            lruList.push_front(key);\n            lruMap[key] = lruList.begin();\n        }\n    }\n};\n\nint main() {\n    LRUCache cache(2); // Capacity of 2\n\n    cache.put(1, 1);    // cache is {1=1}\n    cache.put(2, 2);    // cache is {1=1, 2=2}\n    std::cout << cache.get(1) << std::endl;       // returns 1\n    cache.put(3, 3);    // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n    std::cout << cache.get(2) << std::endl;       // returns -1 (not found)\n    cache.put(4, 4);    // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\n    std::cout << cache.get(1) << std::endl;       // returns -1 (not found)\n    std::cout << cache.get(3) << std::endl;       // returns 3\n    std::cout << cache.get(4) << std::endl;       // returns 4\n\n    return 0;\n}",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/lru-cache/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=7ABFKPK2hD4"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/lru-cache/"
      ]
    ]
  },
  "practice-and-patterns": {
    "title": "Design Patterns (Creational, Structural, Behavioral)",
    "short": "Design patterns are reusable solutions to commonly occurring problems in software design. They are blueprints that can be customized to solve a particular design problem in a specific context. Design patterns are generally categorized into three types: Creational (concerned with object creation mechanisms), Structural (dealing with class and object composition), and Behavioral (focused on algorithms and the assignment of responsibilities between objects). They enhance code reusability, maintainability, and flexibility by providing well-established architectural choices.",
    "time": "N/A (Design patterns are architectural constructs, not algorithms with time complexities)",
    "space": "N/A (Design patterns are architectural constructs, not data structures with space complexities)",
    "code": "// Example demonstrating the Singleton Creational Pattern\n#include <iostream>\n#include <string>\n\nclass Singleton {\nprivate:\n    // Static member pointer to hold the singleton instance.\n    static Singleton* instance;\n\n    // Private constructor to prevent direct instantiation.\n    Singleton(const std::string& data) : data_(data) {}\n\n    // Prevent copy construction.\n    Singleton(const Singleton&) = delete;\n\n    // Prevent assignment.\n    Singleton& operator=(const Singleton&) = delete;\n\n    std::string data_;\n\npublic:\n    // Static method to get the singleton instance.\n    static Singleton* getInstance(const std::string& data) {\n        // Lazy initialization: create the instance only when it's needed.\n        if (instance == nullptr) {\n            instance = new Singleton(data);\n        }\n        return instance;\n    }\n\n    // Method to access the data.\n    std::string getData() const {\n        return data_;\n    }\n\n    // Static method to destroy the singleton instance (optional).\n    static void destroyInstance() {\n      delete instance;\n      instance = nullptr;\n    }\n\n};\n\n// Initialize the static member pointer to nullptr.\nSingleton* Singleton::instance = nullptr;\n\n// Example demonstrating the Adapter Structural Pattern\nclass Adaptee {\npublic:\n    std::string specificRequest() const {\n        return \".eetpadA eht fo etauqedaer ylno ,tseuqeR\";\n    }\n};\n\nclass Target {\npublic:\n    virtual std::string request() const {\n        return \"Target: The default target's behavior.\";\n    }\n};\n\nclass Adapter : public Target {\nprivate:\n    Adaptee* adaptee;\n\npublic:\n    Adapter(Adaptee* adaptee) : adaptee(adaptee) {}\n\n    std::string request() const override {\n        std::string to_reverse = this->adaptee->specificRequest();\n        std::reverse(to_reverse.begin(), to_reverse.end());\n        return \"Adapter: (TRANSLATED) \" + to_reverse;\n    }\n};\n\n// Example demonstrating the Observer Behavioral Pattern\n#include <vector>\n\nclass Observer {\n public:\n  virtual void update(const std::string &message_from_subject) = 0;\n};\n\nclass Subject {\n public:\n  virtual void attach(Observer *observer) = 0;\n  virtual void detach(Observer *observer) = 0;\n  virtual void notify() = 0;\n};\n\nclass ConcreteSubject : public Subject {\n private:\n  std::vector<Observer *> observers_;\n  std::string message_;\n\n public:\n  void attach(Observer *observer) override {\n    observers_.push_back(observer);\n  }\n\n  void detach(Observer *observer) override {\n    observers_.erase(std::remove(observers_.begin(), observers_.end(), observer), observers_.end());\n  }\n\n  void notify() override {\n    for (Observer *observer : observers_) {\n      observer->update(message_);\n    }\n  }\n\n  void createMessage(std::string message = \"Empty\") {\n      this->message_ = message;\n      notify();\n  }\n};\n\nclass ConcreteObserver : public Observer {\n private:\n  std::string name_;\n  std::string message_from_subject_;\n  ConcreteSubject *subject_;\n\n public:\n  ConcreteObserver(ConcreteSubject *subject, std::string name) : subject_(subject), name_(name) {\n    subject_->attach(this);\n  }\n  ~ConcreteObserver() {\n    subject_->detach(this);\n  }\n\n  void update(const std::string &message_from_subject) override {\n    message_from_subject_ = message_from_subject;\n    std::cout << name_ << \": New message from subject: \" << message_from_subject_ << \"\\n\";\n  }\n};\n\n\nint main() {\n    // Singleton Example\n    Singleton* singleton1 = Singleton::getInstance(\"First Instance\");\n    Singleton* singleton2 = Singleton::getInstance(\"Second Instance\"); // Will still return the first instance\n    std::cout << \"Singleton Data: \" << singleton1->getData() << std::endl;\n    std::cout << \"Singleton Data (singleton2): \" << singleton2->getData() << std::endl;\n    Singleton::destroyInstance();\n\n    // Adapter Example\n    Adaptee* adaptee = new Adaptee();\n    Target* target = new Adapter(adaptee);\n    std::cout << target->request() << std::endl;\n    delete adaptee;\n    delete target;\n\n     // Observer Example\n    ConcreteSubject *subject = new ConcreteSubject;\n\n    ConcreteObserver *observer1 = new ConcreteObserver(subject, \"Observer 1\");\n    ConcreteObserver *observer2 = new ConcreteObserver(subject, \"Observer 2\");\n    ConcreteObserver *observer3 = new ConcreteObserver(subject, \"Observer 3\");\n\n    subject->createMessage(\"Hello World! Observers updated.\");\n\n    delete observer1;\n    delete observer2;\n    delete observer3;\n    delete subject;\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Design Patterns",
        "https://www.geeksforgeeks.org/design-patterns-set-1-introduction/"
      ],
      [
        "Derek Banas YouTube - Design Patterns",
        "https://www.youtube.com/playlist?list=PLF206E90617C7E4A7"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/design-patterns/"
      ]
    ]
  },
  "mock-interview-rounds": {
    "title": "Simulating Mock Interview Rounds",
    "short": "Simulating mock interview rounds involves creating a system that mimics the structure and assessment criteria of real technical interviews. This is typically done using a combination of data structures to store candidate information, questions, and evaluation metrics, along with algorithms for question selection, timing, and scoring. The goal is to provide a realistic practice environment for job seekers, allowing them to improve their problem-solving skills and confidence.",
    "time": "Varies significantly depending on the specific implementations of the underlying data structures and algorithms used for question selection, timing, and scoring. Generally, O(1) for accessing candidate/question data if using hash maps or arrays. Question selection might be O(n) in the worst case if needing to iterate through the entire question bank.",
    "space": "O(n), where n is the total number of candidates, questions, and evaluation metrics stored. The size of these data structures directly impacts the overall space complexity.",
    "code": "cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <random>\n#include <chrono>\n#include <algorithm>\n#include <map>\n\n// Structure to represent a question\nstruct Question {\n    std::string text;\n    std::string topic;\n    int difficulty;\n};\n\n// Structure to represent a candidate\nstruct Candidate {\n    std::string name;\n    std::map<std::string, int> skills; // Skill ratings (e.g., \"Data Structures\": 4, \"Algorithms\": 3)\n};\n\n// Function to simulate a mock interview\nvoid simulateMockInterview(const Candidate& candidate, const std::vector<Question>& questionBank) {\n    std::cout << \"Starting mock interview for candidate: \" << candidate.name << std::endl;\n\n    // Seed for random number generation\n    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n    std::default_random_engine generator(seed);\n\n    // Select 3 random questions from the question bank\n    std::vector<Question> selectedQuestions;\n    std::sample(questionBank.begin(), questionBank.end(), std::back_inserter(selectedQuestions), 3, generator);\n\n    for (int i = 0; i < 3; ++i) {\n        std::cout << \"\\nQuestion \" << i + 1 << \": \" << selectedQuestions[i].text << std::endl;\n        std::cout << \"(Topic: \" << selectedQuestions[i].topic << \", Difficulty: \" << selectedQuestions[i].difficulty << \")\\n\";\n\n        // Simulate candidate answering the question (pause for input)\n        std::cout << \"(Simulating candidate's answer... Press Enter to continue)\";\n        std::cin.get();\n\n        // Simulate evaluation (replace with actual evaluation logic)\n        int score = 0;\n        if (selectedQuestions[i].difficulty <= 2) {\n            score = 70 + (rand() % 31); // Simple score between 70 and 100\n        } else {\n            score = 50 + (rand() % 51); // Score between 50 and 100 for harder questions\n        }\n        std::cout << \"Evaluation: Candidate scored \" << score << \" out of 100.\\n\";\n    }\n\n    std::cout << \"\\nMock interview completed for candidate: \" << candidate.name << std::endl;\n}\n\nint main() {\n    // Sample question bank\n    std::vector<Question> questionBank = {\n        {\"Explain the difference between a stack and a queue.\", \"Data Structures\", 1},\n        {\"Describe the concept of recursion.\", \"Algorithms\", 2},\n        {\"What is dynamic programming?\", \"Algorithms\", 3},\n        {\"Implement a binary search algorithm.\", \"Algorithms\", 4},\n        {\"Explain the concept of a hash table.\", \"Data Structures\", 3}\n    };\n\n    // Sample candidate\n    Candidate candidate = {\n        \"Alice\",\n        {{\"Data Structures\", 4}, {\"Algorithms\", 3}}\n    };\n\n    // Run the mock interview\n    simulateMockInterview(candidate, questionBank);\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/how-to-prepare-for-technical-interviews/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=09wG4p_y4Hg"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problemset/all/"
      ]
    ]
  },
  "time-and-space-complexity-analysis": {
    "title": "Time and Space Complexity Analysis",
    "short": "Time and space complexity analysis is a critical technique in computer science used to estimate the resources (time and memory) an algorithm requires as a function of the input size. It involves expressing resource usage using asymptotic notations like Big O, Big Omega, and Big Theta. Understanding these complexities helps in comparing algorithms and choosing the most efficient one for a given problem, especially as the input size grows significantly.",
    "time": "N/A - This is an analysis technique, not a specific algorithm.",
    "space": "N/A - This is an analysis technique, not a specific algorithm.",
    "code": "// Example illustrating time complexity analysis.\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to find the maximum element in a vector (O(n) time complexity).\nint findMax(const vector<int>& arr) {\n    if (arr.empty()) {\n        return -1; // Or throw an exception, depending on requirements.\n    }\n    int maxVal = arr[0]; // Initialization: O(1)\n    for (int i = 1; i < arr.size(); ++i) { // Loop iterates 'n' times, where 'n' is the size of the vector.\n        if (arr[i] > maxVal) { // Comparison: O(1) per iteration.\n            maxVal = arr[i]; // Assignment: O(1) per iteration.\n        }\n    }\n    return maxVal; // Return: O(1)\n    // Overall: O(1) + n * O(1) + O(1) which simplifies to O(n).\n}\n\n// Function to check if an element exists in a vector (O(n) time complexity).\nbool contains(const vector<int>& arr, int target) {\n    for (int num : arr) { // Iterates through each element in the vector. 'n' iterations.\n        if (num == target) { // Constant time comparison per element.\n            return true; // Found, return true.\n        }\n    }\n    return false; // Not found.\n    // Overall time complexity: O(n)\n}\n\n// Function to print all pairs of elements in a vector (O(n^2) time complexity).\nvoid printPairs(const vector<int>& arr) {\n    for (int i = 0; i < arr.size(); ++i) { // Outer loop: n iterations.\n        for (int j = 0; j < arr.size(); ++j) { // Inner loop: n iterations for each outer loop iteration.\n            cout << \"(\" << arr[i] << \", \" << arr[j] << \") \" << endl; // Printing a pair: O(1).\n        }\n    }\n    // Overall time complexity: O(n * n) = O(n^2)\n}\n\n// Example of O(1) time complexity\nint accessElement(const vector<int>& arr, int index) {\n    if (index >= 0 && index < arr.size()) {\n        return arr[index]; // Direct access by index: O(1)\n    }\n    return -1; // Or throw an exception.\n}\n\n\nint main() {\n    vector<int> numbers = {5, 2, 9, 1, 5, 6};\n\n    cout << \"Maximum element: \" << findMax(numbers) << endl;\n    cout << \"Contains 9: \" << contains(numbers, 9) << endl;\n    cout << \"Contains 10: \" << contains(numbers, 10) << endl;\n    cout << \"Accessing element at index 2: \" << accessElement(numbers, 2) << endl;\n    cout << \"Accessing element at index 10: \" << accessElement(numbers, 10) << endl;  //out of bounds example\n\n    cout << \"Pairs:\" << endl;\n    printPairs(numbers);\n\n    return 0;\n}\n\n// Space Complexity examples:\n// The `findMax` function has O(1) space complexity because it uses a fixed number of variables regardless of the input size.\n// The `contains` function has O(1) space complexity because it uses a fixed number of variables regardless of the input size.\n// The `printPairs` function has O(1) space complexity because it prints to the console but doesn't store anything dependent on the input size, aside from loop counters that take O(1).\n// The `accessElement` function has O(1) space complexity because it does not allocate any dynamic space.\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=v4cd17u9wOU"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/problem-list/xoq0x12/"
      ]
    ]
  },
  "edge": {
    "title": "Edge (Graph Data Structure)",
    "short": "An edge is a fundamental component of graph data structures, representing a connection or relationship between two vertices (nodes). It defines how information or flow can travel between these vertices. Edges can be either directed, indicating a one-way relationship, or undirected, indicating a two-way relationship. They are crucial for representing various real-world scenarios like networks, social connections, and dependencies.",
    "time": "Access: O(1) (assuming direct access through adjacency list/matrix), Search: O(degree(v)) in adjacency list, O(1) in adjacency matrix (checking existence), Insertion: O(1) (in most implementations), Deletion: O(degree(v)) in adjacency list, O(1) in adjacency matrix",
    "space": "O(1) (for storing a single edge, but the graph itself can have space complexity O(V+E) or O(V^2))",
    "code": "// A simple C++ implementation of an Edge class for graph representation\n#include <iostream>\n\nclass Edge {\npublic:\n    int source; // The vertex from where the edge originates\n    int destination; // The vertex where the edge terminates\n    int weight; // Optional: The weight or cost associated with the edge\n\n    // Constructor to initialize the edge\n    Edge(int src, int dest, int w = 1) : source(src), destination(dest), weight(w) {}\n\n    // A method to print the edge details\n    void printEdge() const {\n        std::cout << \"Edge: \" << source << \" -> \" << destination << \" (Weight: \" << weight << \")\" << std::endl;\n    }\n};\n\n// A simple main function to demonstrate the usage\nint main() {\n    // Create an edge from vertex 0 to vertex 1 with a weight of 5\n    Edge myEdge(0, 1, 5);\n\n    // Print the edge details\n    myEdge.printEdge();\n\n    // Example usage with another edge\n    Edge anotherEdge(2, 3); // default weight = 1\n    anotherEdge.printEdge();\n\n    return 0;\n}\n",
    "links": [
      [
        "GeeksforGeeks Article",
        "https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/"
      ],
      [
        "YouTube Tutorial",
        "https://www.youtube.com/watch?v=gXEuZWf7p-Y"
      ],
      [
        "LeetCode Problems",
        "https://leetcode.com/tag/graph/"
      ]
    ]
  }
}